/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: libc::c_int = 1;
pub const _FEATURES_H: libc::c_int = 1;
pub const _DEFAULT_SOURCE: libc::c_int = 1;
pub const __GLIBC_USE_ISOC2X: libc::c_int = 0;
pub const __USE_ISOC11: libc::c_int = 1;
pub const __USE_ISOC99: libc::c_int = 1;
pub const __USE_ISOC95: libc::c_int = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_int = 1;
pub const _POSIX_SOURCE: libc::c_int = 1;
pub const _POSIX_C_SOURCE: libc::c_int = 200809;
pub const __USE_POSIX: libc::c_int = 1;
pub const __USE_POSIX2: libc::c_int = 1;
pub const __USE_POSIX199309: libc::c_int = 1;
pub const __USE_POSIX199506: libc::c_int = 1;
pub const __USE_XOPEN2K: libc::c_int = 1;
pub const __USE_XOPEN2K8: libc::c_int = 1;
pub const _ATFILE_SOURCE: libc::c_int = 1;
pub const __WORDSIZE: libc::c_int = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_int = 1;
pub const __SYSCALL_WORDSIZE: libc::c_int = 64;
pub const __TIMESIZE: libc::c_int = 64;
pub const __USE_MISC: libc::c_int = 1;
pub const __USE_ATFILE: libc::c_int = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_int = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: libc::c_int = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: libc::c_int = 0;
pub const _STDC_PREDEF_H: libc::c_int = 1;
pub const __STDC_IEC_559__: libc::c_int = 1;
pub const __STDC_IEC_60559_BFP__: libc::c_int = 201404;
pub const __STDC_IEC_559_COMPLEX__: libc::c_int = 1;
pub const __STDC_IEC_60559_COMPLEX__: libc::c_int = 201404;
pub const __STDC_ISO_10646__: libc::c_int = 201706;
pub const __GNU_LIBRARY__: libc::c_int = 6;
pub const __GLIBC__: libc::c_int = 2;
pub const __GLIBC_MINOR__: libc::c_int = 36;
pub const _SYS_CDEFS_H: libc::c_int = 1;
pub const __glibc_c99_flexarr_available: libc::c_int = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: libc::c_int = 0;
pub const __HAVE_GENERIC_SELECTION: libc::c_int = 1;
pub const __GLIBC_USE_LIB_EXT2: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_EXT: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: libc::c_int = 0;
pub const _BITS_TYPES_H: libc::c_int = 1;
pub const _BITS_TYPESIZES_H: libc::c_int = 1;
pub const __OFF_T_MATCHES_OFF64_T: libc::c_int = 1;
pub const __INO_T_MATCHES_INO64_T: libc::c_int = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: libc::c_int = 1;
pub const __STATFS_MATCHES_STATFS64: libc::c_int = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: libc::c_int = 1;
pub const __FD_SETSIZE: libc::c_int = 1024;
pub const _BITS_TIME64_H: libc::c_int = 1;
pub const _BITS_WCHAR_H: libc::c_int = 1;
pub const _BITS_STDINT_INTN_H: libc::c_int = 1;
pub const _BITS_STDINT_UINTN_H: libc::c_int = 1;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT8_MAX: libc::c_int = 127;
pub const INT16_MAX: libc::c_int = 32767;
pub const INT32_MAX: libc::c_int = 2147483647;
pub const UINT8_MAX: libc::c_int = 255;
pub const UINT16_MAX: libc::c_int = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: libc::c_int = 127;
pub const INT_LEAST16_MAX: libc::c_int = 32767;
pub const INT_LEAST32_MAX: libc::c_int = 2147483647;
pub const UINT_LEAST8_MAX: libc::c_int = 255;
pub const UINT_LEAST16_MAX: libc::c_int = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_int = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_int = 255;
pub const UINT_FAST16_MAX: libc::c_int = -1;
pub const UINT_FAST32_MAX: libc::c_int = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_int = 2147483647;
pub const SIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_int = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const FF_LAMBDA_SHIFT: libc::c_int = 7;
pub const FF_LAMBDA_SCALE: libc::c_int = 128;
pub const FF_QP2LAMBDA: libc::c_int = 118;
pub const FF_LAMBDA_MAX: libc::c_int = 32767;
pub const FF_QUALITY_SCALE: libc::c_int = 128;
pub const AV_TIME_BASE: libc::c_int = 1000000;
pub const _ERRNO_H: libc::c_int = 1;
pub const _BITS_ERRNO_H: libc::c_int = 1;
pub const EPERM: libc::c_int = 1;
pub const ENOENT: libc::c_int = 2;
pub const ESRCH: libc::c_int = 3;
pub const EINTR: libc::c_int = 4;
pub const EIO: libc::c_int = 5;
pub const ENXIO: libc::c_int = 6;
pub const E2BIG: libc::c_int = 7;
pub const ENOEXEC: libc::c_int = 8;
pub const EBADF: libc::c_int = 9;
pub const ECHILD: libc::c_int = 10;
pub const EAGAIN: libc::c_int = 11;
pub const ENOMEM: libc::c_int = 12;
pub const EACCES: libc::c_int = 13;
pub const EFAULT: libc::c_int = 14;
pub const ENOTBLK: libc::c_int = 15;
pub const EBUSY: libc::c_int = 16;
pub const EEXIST: libc::c_int = 17;
pub const EXDEV: libc::c_int = 18;
pub const ENODEV: libc::c_int = 19;
pub const ENOTDIR: libc::c_int = 20;
pub const EISDIR: libc::c_int = 21;
pub const EINVAL: libc::c_int = 22;
pub const ENFILE: libc::c_int = 23;
pub const EMFILE: libc::c_int = 24;
pub const ENOTTY: libc::c_int = 25;
pub const ETXTBSY: libc::c_int = 26;
pub const EFBIG: libc::c_int = 27;
pub const ENOSPC: libc::c_int = 28;
pub const ESPIPE: libc::c_int = 29;
pub const EROFS: libc::c_int = 30;
pub const EMLINK: libc::c_int = 31;
pub const EPIPE: libc::c_int = 32;
pub const EDOM: libc::c_int = 33;
pub const ERANGE: libc::c_int = 34;
pub const EDEADLK: libc::c_int = 35;
pub const ENAMETOOLONG: libc::c_int = 36;
pub const ENOLCK: libc::c_int = 37;
pub const ENOSYS: libc::c_int = 38;
pub const ENOTEMPTY: libc::c_int = 39;
pub const ELOOP: libc::c_int = 40;
pub const EWOULDBLOCK: libc::c_int = 11;
pub const ENOMSG: libc::c_int = 42;
pub const EIDRM: libc::c_int = 43;
pub const ECHRNG: libc::c_int = 44;
pub const EL2NSYNC: libc::c_int = 45;
pub const EL3HLT: libc::c_int = 46;
pub const EL3RST: libc::c_int = 47;
pub const ELNRNG: libc::c_int = 48;
pub const EUNATCH: libc::c_int = 49;
pub const ENOCSI: libc::c_int = 50;
pub const EL2HLT: libc::c_int = 51;
pub const EBADE: libc::c_int = 52;
pub const EBADR: libc::c_int = 53;
pub const EXFULL: libc::c_int = 54;
pub const ENOANO: libc::c_int = 55;
pub const EBADRQC: libc::c_int = 56;
pub const EBADSLT: libc::c_int = 57;
pub const EDEADLOCK: libc::c_int = 35;
pub const EBFONT: libc::c_int = 59;
pub const ENOSTR: libc::c_int = 60;
pub const ENODATA: libc::c_int = 61;
pub const ETIME: libc::c_int = 62;
pub const ENOSR: libc::c_int = 63;
pub const ENONET: libc::c_int = 64;
pub const ENOPKG: libc::c_int = 65;
pub const EREMOTE: libc::c_int = 66;
pub const ENOLINK: libc::c_int = 67;
pub const EADV: libc::c_int = 68;
pub const ESRMNT: libc::c_int = 69;
pub const ECOMM: libc::c_int = 70;
pub const EPROTO: libc::c_int = 71;
pub const EMULTIHOP: libc::c_int = 72;
pub const EDOTDOT: libc::c_int = 73;
pub const EBADMSG: libc::c_int = 74;
pub const EOVERFLOW: libc::c_int = 75;
pub const ENOTUNIQ: libc::c_int = 76;
pub const EBADFD: libc::c_int = 77;
pub const EREMCHG: libc::c_int = 78;
pub const ELIBACC: libc::c_int = 79;
pub const ELIBBAD: libc::c_int = 80;
pub const ELIBSCN: libc::c_int = 81;
pub const ELIBMAX: libc::c_int = 82;
pub const ELIBEXEC: libc::c_int = 83;
pub const EILSEQ: libc::c_int = 84;
pub const ERESTART: libc::c_int = 85;
pub const ESTRPIPE: libc::c_int = 86;
pub const EUSERS: libc::c_int = 87;
pub const ENOTSOCK: libc::c_int = 88;
pub const EDESTADDRREQ: libc::c_int = 89;
pub const EMSGSIZE: libc::c_int = 90;
pub const EPROTOTYPE: libc::c_int = 91;
pub const ENOPROTOOPT: libc::c_int = 92;
pub const EPROTONOSUPPORT: libc::c_int = 93;
pub const ESOCKTNOSUPPORT: libc::c_int = 94;
pub const EOPNOTSUPP: libc::c_int = 95;
pub const EPFNOSUPPORT: libc::c_int = 96;
pub const EAFNOSUPPORT: libc::c_int = 97;
pub const EADDRINUSE: libc::c_int = 98;
pub const EADDRNOTAVAIL: libc::c_int = 99;
pub const ENETDOWN: libc::c_int = 100;
pub const ENETUNREACH: libc::c_int = 101;
pub const ENETRESET: libc::c_int = 102;
pub const ECONNABORTED: libc::c_int = 103;
pub const ECONNRESET: libc::c_int = 104;
pub const ENOBUFS: libc::c_int = 105;
pub const EISCONN: libc::c_int = 106;
pub const ENOTCONN: libc::c_int = 107;
pub const ESHUTDOWN: libc::c_int = 108;
pub const ETOOMANYREFS: libc::c_int = 109;
pub const ETIMEDOUT: libc::c_int = 110;
pub const ECONNREFUSED: libc::c_int = 111;
pub const EHOSTDOWN: libc::c_int = 112;
pub const EHOSTUNREACH: libc::c_int = 113;
pub const EALREADY: libc::c_int = 114;
pub const EINPROGRESS: libc::c_int = 115;
pub const ESTALE: libc::c_int = 116;
pub const EUCLEAN: libc::c_int = 117;
pub const ENOTNAM: libc::c_int = 118;
pub const ENAVAIL: libc::c_int = 119;
pub const EISNAM: libc::c_int = 120;
pub const EREMOTEIO: libc::c_int = 121;
pub const EDQUOT: libc::c_int = 122;
pub const ENOMEDIUM: libc::c_int = 123;
pub const EMEDIUMTYPE: libc::c_int = 124;
pub const ECANCELED: libc::c_int = 125;
pub const ENOKEY: libc::c_int = 126;
pub const EKEYEXPIRED: libc::c_int = 127;
pub const EKEYREVOKED: libc::c_int = 128;
pub const EKEYREJECTED: libc::c_int = 129;
pub const EOWNERDEAD: libc::c_int = 130;
pub const ENOTRECOVERABLE: libc::c_int = 131;
pub const ERFKILL: libc::c_int = 132;
pub const EHWPOISON: libc::c_int = 133;
pub const ENOTSUP: libc::c_int = 95;
pub const _INTTYPES_H: libc::c_int = 1;
pub const ____gwchar_t_defined: libc::c_int = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const _LIBC_LIMITS_H_: libc::c_int = 1;
pub const MB_LEN_MAX: libc::c_int = 16;
pub const _BITS_POSIX1_LIM_H: libc::c_int = 1;
pub const _POSIX_AIO_LISTIO_MAX: libc::c_int = 2;
pub const _POSIX_AIO_MAX: libc::c_int = 1;
pub const _POSIX_ARG_MAX: libc::c_int = 4096;
pub const _POSIX_CHILD_MAX: libc::c_int = 25;
pub const _POSIX_DELAYTIMER_MAX: libc::c_int = 32;
pub const _POSIX_HOST_NAME_MAX: libc::c_int = 255;
pub const _POSIX_LINK_MAX: libc::c_int = 8;
pub const _POSIX_LOGIN_NAME_MAX: libc::c_int = 9;
pub const _POSIX_MAX_CANON: libc::c_int = 255;
pub const _POSIX_MAX_INPUT: libc::c_int = 255;
pub const _POSIX_MQ_OPEN_MAX: libc::c_int = 8;
pub const _POSIX_MQ_PRIO_MAX: libc::c_int = 32;
pub const _POSIX_NAME_MAX: libc::c_int = 14;
pub const _POSIX_NGROUPS_MAX: libc::c_int = 8;
pub const _POSIX_OPEN_MAX: libc::c_int = 20;
pub const _POSIX_PATH_MAX: libc::c_int = 256;
pub const _POSIX_PIPE_BUF: libc::c_int = 512;
pub const _POSIX_RE_DUP_MAX: libc::c_int = 255;
pub const _POSIX_RTSIG_MAX: libc::c_int = 8;
pub const _POSIX_SEM_NSEMS_MAX: libc::c_int = 256;
pub const _POSIX_SEM_VALUE_MAX: libc::c_int = 32767;
pub const _POSIX_SIGQUEUE_MAX: libc::c_int = 32;
pub const _POSIX_SSIZE_MAX: libc::c_int = 32767;
pub const _POSIX_STREAM_MAX: libc::c_int = 8;
pub const _POSIX_SYMLINK_MAX: libc::c_int = 255;
pub const _POSIX_SYMLOOP_MAX: libc::c_int = 8;
pub const _POSIX_TIMER_MAX: libc::c_int = 32;
pub const _POSIX_TTY_NAME_MAX: libc::c_int = 9;
pub const _POSIX_TZNAME_MAX: libc::c_int = 6;
pub const _POSIX_CLOCKRES_MIN: libc::c_int = 20000000;
pub const NR_OPEN: libc::c_int = 1024;
pub const NGROUPS_MAX: libc::c_int = 65536;
pub const ARG_MAX: libc::c_int = 131072;
pub const LINK_MAX: libc::c_int = 127;
pub const MAX_CANON: libc::c_int = 255;
pub const MAX_INPUT: libc::c_int = 255;
pub const NAME_MAX: libc::c_int = 255;
pub const PATH_MAX: libc::c_int = 4096;
pub const PIPE_BUF: libc::c_int = 4096;
pub const XATTR_NAME_MAX: libc::c_int = 255;
pub const XATTR_SIZE_MAX: libc::c_int = 65536;
pub const XATTR_LIST_MAX: libc::c_int = 65536;
pub const RTSIG_MAX: libc::c_int = 32;
pub const _POSIX_THREAD_KEYS_MAX: libc::c_int = 128;
pub const PTHREAD_KEYS_MAX: libc::c_int = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const _POSIX_THREAD_THREADS_MAX: libc::c_int = 64;
pub const AIO_PRIO_DELTA_MAX: libc::c_int = 20;
pub const PTHREAD_STACK_MIN: libc::c_int = 16384;
pub const DELAYTIMER_MAX: libc::c_int = 2147483647;
pub const TTY_NAME_MAX: libc::c_int = 32;
pub const LOGIN_NAME_MAX: libc::c_int = 256;
pub const HOST_NAME_MAX: libc::c_int = 64;
pub const MQ_PRIO_MAX: libc::c_int = 32768;
pub const SEM_VALUE_MAX: libc::c_int = 2147483647;
pub const _BITS_POSIX2_LIM_H: libc::c_int = 1;
pub const _POSIX2_BC_BASE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_DIM_MAX: libc::c_int = 2048;
pub const _POSIX2_BC_SCALE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_STRING_MAX: libc::c_int = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: libc::c_int = 2;
pub const _POSIX2_EXPR_NEST_MAX: libc::c_int = 32;
pub const _POSIX2_LINE_MAX: libc::c_int = 2048;
pub const _POSIX2_RE_DUP_MAX: libc::c_int = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: libc::c_int = 14;
pub const BC_BASE_MAX: libc::c_int = 99;
pub const BC_DIM_MAX: libc::c_int = 2048;
pub const BC_SCALE_MAX: libc::c_int = 99;
pub const BC_STRING_MAX: libc::c_int = 1000;
pub const COLL_WEIGHTS_MAX: libc::c_int = 255;
pub const EXPR_NEST_MAX: libc::c_int = 32;
pub const LINE_MAX: libc::c_int = 2048;
pub const CHARCLASS_NAME_MAX: libc::c_int = 2048;
pub const RE_DUP_MAX: libc::c_int = 32767;
pub const _MATH_H: libc::c_int = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: libc::c_int = 1;
pub const __HAVE_FLOAT128: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT128: libc::c_int = 0;
pub const __HAVE_FLOAT64X: libc::c_int = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: libc::c_int = 1;
pub const __HAVE_FLOAT16: libc::c_int = 0;
pub const __HAVE_FLOAT32: libc::c_int = 1;
pub const __HAVE_FLOAT64: libc::c_int = 1;
pub const __HAVE_FLOAT32X: libc::c_int = 1;
pub const __HAVE_FLOAT128X: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT16: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT32: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT64: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT32X: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT64X: libc::c_int = 0;
pub const __HAVE_DISTINCT_FLOAT128X: libc::c_int = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: libc::c_int = 0;
pub const __FP_LOGB0_IS_MIN: libc::c_int = 1;
pub const __FP_LOGBNAN_IS_MIN: libc::c_int = 1;
pub const FP_ILOGB0: libc::c_int = -2147483648;
pub const FP_ILOGBNAN: libc::c_int = -2147483648;
pub const __MATH_DECLARING_DOUBLE: libc::c_int = 1;
pub const __MATH_DECLARING_FLOATN: libc::c_int = 0;
pub const __MATH_DECLARE_LDOUBLE: libc::c_int = 1;
pub const MATH_ERRNO: libc::c_int = 1;
pub const MATH_ERREXCEPT: libc::c_int = 2;
pub const math_errhandling: libc::c_int = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STDIO_H: libc::c_int = 1;
pub const __GNUC_VA_LIST: libc::c_int = 1;
pub const _____fpos_t_defined: libc::c_int = 1;
pub const ____mbstate_t_defined: libc::c_int = 1;
pub const _____fpos64_t_defined: libc::c_int = 1;
pub const ____FILE_defined: libc::c_int = 1;
pub const __FILE_defined: libc::c_int = 1;
pub const __struct_FILE_defined: libc::c_int = 1;
pub const _IO_EOF_SEEN: libc::c_int = 16;
pub const _IO_ERR_SEEN: libc::c_int = 32;
pub const _IO_USER_LOCK: libc::c_int = 32768;
pub const _IOFBF: libc::c_int = 0;
pub const _IOLBF: libc::c_int = 1;
pub const _IONBF: libc::c_int = 2;
pub const BUFSIZ: libc::c_int = 8192;
pub const EOF: libc::c_int = -1;
pub const SEEK_SET: libc::c_int = 0;
pub const SEEK_CUR: libc::c_int = 1;
pub const SEEK_END: libc::c_int = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: libc::c_int = 1;
pub const L_tmpnam: libc::c_int = 20;
pub const TMP_MAX: libc::c_int = 238328;
pub const FILENAME_MAX: libc::c_int = 4096;
pub const L_ctermid: libc::c_int = 9;
pub const FOPEN_MAX: libc::c_int = 16;
pub const _STDLIB_H: libc::c_int = 1;
pub const WNOHANG: libc::c_int = 1;
pub const WUNTRACED: libc::c_int = 2;
pub const WSTOPPED: libc::c_int = 2;
pub const WEXITED: libc::c_int = 4;
pub const WCONTINUED: libc::c_int = 8;
pub const WNOWAIT: libc::c_int = 16777216;
pub const __WNOTHREAD: libc::c_int = 536870912;
pub const __WALL: libc::c_int = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: libc::c_int = 65535;
pub const __WCOREFLAG: libc::c_int = 128;
pub const __ldiv_t_defined: libc::c_int = 1;
pub const __lldiv_t_defined: libc::c_int = 1;
pub const RAND_MAX: libc::c_int = 2147483647;
pub const EXIT_FAILURE: libc::c_int = 1;
pub const EXIT_SUCCESS: libc::c_int = 0;
pub const _SYS_TYPES_H: libc::c_int = 1;
pub const __clock_t_defined: libc::c_int = 1;
pub const __clockid_t_defined: libc::c_int = 1;
pub const __time_t_defined: libc::c_int = 1;
pub const __timer_t_defined: libc::c_int = 1;
pub const __BIT_TYPES_DEFINED__: libc::c_int = 1;
pub const _ENDIAN_H: libc::c_int = 1;
pub const _BITS_ENDIAN_H: libc::c_int = 1;
pub const __LITTLE_ENDIAN: libc::c_int = 1234;
pub const __BIG_ENDIAN: libc::c_int = 4321;
pub const __PDP_ENDIAN: libc::c_int = 3412;
pub const _BITS_ENDIANNESS_H: libc::c_int = 1;
pub const __BYTE_ORDER: libc::c_int = 1234;
pub const __FLOAT_WORD_ORDER: libc::c_int = 1234;
pub const LITTLE_ENDIAN: libc::c_int = 1234;
pub const BIG_ENDIAN: libc::c_int = 4321;
pub const PDP_ENDIAN: libc::c_int = 3412;
pub const BYTE_ORDER: libc::c_int = 1234;
pub const _BITS_BYTESWAP_H: libc::c_int = 1;
pub const _BITS_UINTN_IDENTITY_H: libc::c_int = 1;
pub const _SYS_SELECT_H: libc::c_int = 1;
pub const __sigset_t_defined: libc::c_int = 1;
pub const __timeval_defined: libc::c_int = 1;
pub const _STRUCT_TIMESPEC: libc::c_int = 1;
pub const FD_SETSIZE: libc::c_int = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: libc::c_int = 1;
pub const _THREAD_SHARED_TYPES_H: libc::c_int = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: libc::c_int = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: libc::c_int = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: libc::c_int = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: libc::c_int = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: libc::c_int = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: libc::c_int = 4;
pub const __SIZEOF_PTHREAD_COND_T: libc::c_int = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: libc::c_int = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: libc::c_int = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: libc::c_int = 4;
pub const _THREAD_MUTEX_INTERNAL_H: libc::c_int = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: libc::c_int = 1;
pub const __have_pthread_attr_t: libc::c_int = 1;
pub const _ALLOCA_H: libc::c_int = 1;
pub const _STRING_H: libc::c_int = 1;
pub const _BITS_TYPES_LOCALE_T_H: libc::c_int = 1;
pub const _BITS_TYPES___LOCALE_T_H: libc::c_int = 1;
pub const _STRINGS_H: libc::c_int = 1;
pub const AV_HAVE_BIGENDIAN: libc::c_int = 0;
pub const AV_HAVE_FAST_UNALIGNED: libc::c_int = 1;
pub const LIBAVUTIL_VERSION_MAJOR: libc::c_int = 57;
pub const LIBAVUTIL_VERSION_MINOR: libc::c_int = 28;
pub const LIBAVUTIL_VERSION_MICRO: libc::c_int = 100;
pub const AVERROR_EXPERIMENTAL: libc::c_int = -733130664;
pub const AVERROR_INPUT_CHANGED: libc::c_int = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: libc::c_int = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: usize = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const AV_LOG_QUIET: libc::c_int = -8;
pub const AV_LOG_PANIC: libc::c_int = 0;
pub const AV_LOG_FATAL: libc::c_int = 8;
pub const AV_LOG_ERROR: libc::c_int = 16;
pub const AV_LOG_WARNING: libc::c_int = 24;
pub const AV_LOG_INFO: libc::c_int = 32;
pub const AV_LOG_VERBOSE: libc::c_int = 40;
pub const AV_LOG_DEBUG: libc::c_int = 48;
pub const AV_LOG_TRACE: libc::c_int = 56;
pub const AV_LOG_MAX_OFFSET: libc::c_int = 64;
pub const AV_LOG_SKIP_REPEATED: libc::c_int = 1;
pub const AV_LOG_PRINT_LEVEL: libc::c_int = 2;
pub const AVPALETTE_SIZE: libc::c_int = 1024;
pub const AVPALETTE_COUNT: libc::c_int = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: libc::c_int = 32;
pub const AV_BUFFER_FLAG_READONLY: libc::c_int = 1;
pub const AV_DICT_MATCH_CASE: libc::c_int = 1;
pub const AV_DICT_IGNORE_SUFFIX: libc::c_int = 2;
pub const AV_DICT_DONT_STRDUP_KEY: libc::c_int = 4;
pub const AV_DICT_DONT_STRDUP_VAL: libc::c_int = 8;
pub const AV_DICT_DONT_OVERWRITE: libc::c_int = 16;
pub const AV_DICT_APPEND: libc::c_int = 32;
pub const AV_DICT_MULTIKEY: libc::c_int = 64;
pub const AV_CH_LAYOUT_NATIVE: libc::c_ulonglong = 9223372036854775808;
pub const AV_NUM_DATA_POINTERS: libc::c_int = 8;
pub const AV_FRAME_FLAG_CORRUPT: libc::c_int = 1;
pub const AV_FRAME_FLAG_DISCARD: libc::c_int = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: libc::c_int = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: libc::c_int = 2;
pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: libc::c_int = 4;
pub const FF_DECODE_ERROR_DECODE_SLICES: libc::c_int = 8;
pub const LIBAVCODEC_VERSION_MAJOR: libc::c_int = 59;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: libc::c_uint = 1;
pub const AV_CODEC_CAP_DR1: libc::c_uint = 2;
pub const AV_CODEC_CAP_TRUNCATED: libc::c_uint = 8;
pub const AV_CODEC_CAP_DELAY: libc::c_uint = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: libc::c_uint = 64;
pub const AV_CODEC_CAP_SUBFRAMES: libc::c_uint = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: libc::c_uint = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: libc::c_uint = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: libc::c_uint = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: libc::c_uint = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: libc::c_uint = 16384;
pub const AV_CODEC_CAP_OTHER_THREADS: libc::c_uint = 32768;
pub const AV_CODEC_CAP_AUTO_THREADS: libc::c_uint = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: libc::c_uint = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: libc::c_uint = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: libc::c_uint = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: u32 = 2147483648;
pub const AV_CODEC_CAP_HARDWARE: libc::c_uint = 262144;
pub const AV_CODEC_CAP_HYBRID: libc::c_uint = 524288;
pub const AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE: libc::c_uint = 1048576;
pub const AV_CODEC_CAP_ENCODER_FLUSH: libc::c_uint = 2097152;
pub const AV_CODEC_PROP_INTRA_ONLY: libc::c_int = 1;
pub const AV_CODEC_PROP_LOSSY: libc::c_int = 2;
pub const AV_CODEC_PROP_LOSSLESS: libc::c_int = 4;
pub const AV_CODEC_PROP_REORDER: libc::c_int = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: libc::c_int = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: libc::c_int = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: libc::c_int = 64;
pub const AV_PKT_FLAG_KEY: libc::c_int = 1;
pub const AV_PKT_FLAG_CORRUPT: libc::c_int = 2;
pub const AV_PKT_FLAG_DISCARD: libc::c_int = 4;
pub const AV_PKT_FLAG_TRUSTED: libc::c_int = 8;
pub const AV_PKT_FLAG_DISPOSABLE: libc::c_int = 16;
pub const LIBAVCODEC_VERSION_MINOR: libc::c_int = 37;
pub const LIBAVCODEC_VERSION_MICRO: libc::c_int = 100;
pub const AV_INPUT_BUFFER_MIN_SIZE: libc::c_int = 16384;
pub const AV_CODEC_FLAG_UNALIGNED: libc::c_uint = 1;
pub const AV_CODEC_FLAG_QSCALE: libc::c_uint = 2;
pub const AV_CODEC_FLAG_4MV: libc::c_uint = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: libc::c_uint = 8;
pub const AV_CODEC_FLAG_QPEL: libc::c_uint = 16;
pub const AV_CODEC_FLAG_DROPCHANGED: libc::c_uint = 32;
pub const AV_CODEC_FLAG_PASS1: libc::c_uint = 512;
pub const AV_CODEC_FLAG_PASS2: libc::c_uint = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: libc::c_uint = 2048;
pub const AV_CODEC_FLAG_GRAY: libc::c_uint = 8192;
pub const AV_CODEC_FLAG_PSNR: libc::c_uint = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: libc::c_uint = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: libc::c_uint = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: libc::c_uint = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: libc::c_uint = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: libc::c_uint = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: libc::c_uint = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: libc::c_uint = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const AV_CODEC_FLAG2_FAST: libc::c_int = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: libc::c_int = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: libc::c_int = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: libc::c_int = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: libc::c_int = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: libc::c_int = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: libc::c_int = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: libc::c_int = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: libc::c_int = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: libc::c_int = 1073741824;
pub const AV_CODEC_EXPORT_DATA_MVS: libc::c_int = 1;
pub const AV_CODEC_EXPORT_DATA_PRFT: libc::c_int = 2;
pub const AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS: libc::c_int = 4;
pub const AV_CODEC_EXPORT_DATA_FILM_GRAIN: libc::c_int = 8;
pub const AV_GET_BUFFER_FLAG_REF: libc::c_int = 1;
pub const AV_GET_ENCODE_BUFFER_FLAG_REF: libc::c_int = 1;
pub const FF_COMPRESSION_DEFAULT: libc::c_int = -1;
pub const FF_CMP_SAD: libc::c_int = 0;
pub const FF_CMP_SSE: libc::c_int = 1;
pub const FF_CMP_SATD: libc::c_int = 2;
pub const FF_CMP_DCT: libc::c_int = 3;
pub const FF_CMP_PSNR: libc::c_int = 4;
pub const FF_CMP_BIT: libc::c_int = 5;
pub const FF_CMP_RD: libc::c_int = 6;
pub const FF_CMP_ZERO: libc::c_int = 7;
pub const FF_CMP_VSAD: libc::c_int = 8;
pub const FF_CMP_VSSE: libc::c_int = 9;
pub const FF_CMP_NSSE: libc::c_int = 10;
pub const FF_CMP_W53: libc::c_int = 11;
pub const FF_CMP_W97: libc::c_int = 12;
pub const FF_CMP_DCTMAX: libc::c_int = 13;
pub const FF_CMP_DCT264: libc::c_int = 14;
pub const FF_CMP_MEDIAN_SAD: libc::c_int = 15;
pub const FF_CMP_CHROMA: libc::c_int = 256;
pub const SLICE_FLAG_CODED_ORDER: libc::c_int = 1;
pub const SLICE_FLAG_ALLOW_FIELD: libc::c_int = 2;
pub const SLICE_FLAG_ALLOW_PLANE: libc::c_int = 4;
pub const FF_MB_DECISION_SIMPLE: libc::c_int = 0;
pub const FF_MB_DECISION_BITS: libc::c_int = 1;
pub const FF_MB_DECISION_RD: libc::c_int = 2;
pub const FF_BUG_AUTODETECT: libc::c_int = 1;
pub const FF_BUG_XVID_ILACE: libc::c_int = 4;
pub const FF_BUG_UMP4: libc::c_int = 8;
pub const FF_BUG_NO_PADDING: libc::c_int = 16;
pub const FF_BUG_AMV: libc::c_int = 32;
pub const FF_BUG_QPEL_CHROMA: libc::c_int = 64;
pub const FF_BUG_STD_QPEL: libc::c_int = 128;
pub const FF_BUG_QPEL_CHROMA2: libc::c_int = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: libc::c_int = 512;
pub const FF_BUG_EDGE: libc::c_int = 1024;
pub const FF_BUG_HPEL_CHROMA: libc::c_int = 2048;
pub const FF_BUG_DC_CLIP: libc::c_int = 4096;
pub const FF_BUG_MS: libc::c_int = 8192;
pub const FF_BUG_TRUNCATED: libc::c_int = 16384;
pub const FF_BUG_IEDGE: libc::c_int = 32768;
pub const FF_COMPLIANCE_VERY_STRICT: libc::c_int = 2;
pub const FF_COMPLIANCE_STRICT: libc::c_int = 1;
pub const FF_COMPLIANCE_NORMAL: libc::c_int = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: libc::c_int = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: libc::c_int = -2;
pub const FF_EC_GUESS_MVS: libc::c_int = 1;
pub const FF_EC_DEBLOCK: libc::c_int = 2;
pub const FF_EC_FAVOR_INTER: libc::c_int = 256;
pub const FF_DEBUG_PICT_INFO: libc::c_int = 1;
pub const FF_DEBUG_RC: libc::c_int = 2;
pub const FF_DEBUG_BITSTREAM: libc::c_int = 4;
pub const FF_DEBUG_MB_TYPE: libc::c_int = 8;
pub const FF_DEBUG_QP: libc::c_int = 16;
pub const FF_DEBUG_DCT_COEFF: libc::c_int = 64;
pub const FF_DEBUG_SKIP: libc::c_int = 128;
pub const FF_DEBUG_STARTCODE: libc::c_int = 256;
pub const FF_DEBUG_ER: libc::c_int = 1024;
pub const FF_DEBUG_MMCO: libc::c_int = 2048;
pub const FF_DEBUG_BUGS: libc::c_int = 4096;
pub const FF_DEBUG_BUFFERS: libc::c_int = 32768;
pub const FF_DEBUG_THREADS: libc::c_int = 65536;
pub const FF_DEBUG_GREEN_MD: libc::c_int = 8388608;
pub const FF_DEBUG_NOMC: libc::c_int = 16777216;
pub const AV_EF_CRCCHECK: libc::c_int = 1;
pub const AV_EF_BITSTREAM: libc::c_int = 2;
pub const AV_EF_BUFFER: libc::c_int = 4;
pub const AV_EF_EXPLODE: libc::c_int = 8;
pub const AV_EF_IGNORE_ERR: libc::c_int = 32768;
pub const AV_EF_CAREFUL: libc::c_int = 65536;
pub const AV_EF_COMPLIANT: libc::c_int = 131072;
pub const AV_EF_AGGRESSIVE: libc::c_int = 262144;
pub const FF_DCT_AUTO: libc::c_int = 0;
pub const FF_DCT_FASTINT: libc::c_int = 1;
pub const FF_DCT_INT: libc::c_int = 2;
pub const FF_DCT_MMX: libc::c_int = 3;
pub const FF_DCT_ALTIVEC: libc::c_int = 5;
pub const FF_DCT_FAAN: libc::c_int = 6;
pub const FF_IDCT_AUTO: libc::c_int = 0;
pub const FF_IDCT_INT: libc::c_int = 1;
pub const FF_IDCT_SIMPLE: libc::c_int = 2;
pub const FF_IDCT_SIMPLEMMX: libc::c_int = 3;
pub const FF_IDCT_ARM: libc::c_int = 7;
pub const FF_IDCT_ALTIVEC: libc::c_int = 8;
pub const FF_IDCT_SIMPLEARM: libc::c_int = 10;
pub const FF_IDCT_XVID: libc::c_int = 14;
pub const FF_IDCT_SIMPLEARMV5TE: libc::c_int = 16;
pub const FF_IDCT_SIMPLEARMV6: libc::c_int = 17;
pub const FF_IDCT_FAAN: libc::c_int = 20;
pub const FF_IDCT_SIMPLENEON: libc::c_int = 22;
pub const FF_IDCT_NONE: libc::c_int = 24;
pub const FF_IDCT_SIMPLEAUTO: libc::c_int = 128;
pub const FF_THREAD_FRAME: libc::c_int = 1;
pub const FF_THREAD_SLICE: libc::c_int = 2;
pub const FF_PROFILE_UNKNOWN: libc::c_int = -99;
pub const FF_PROFILE_RESERVED: libc::c_int = -100;
pub const FF_PROFILE_AAC_MAIN: libc::c_int = 0;
pub const FF_PROFILE_AAC_LOW: libc::c_int = 1;
pub const FF_PROFILE_AAC_SSR: libc::c_int = 2;
pub const FF_PROFILE_AAC_LTP: libc::c_int = 3;
pub const FF_PROFILE_AAC_HE: libc::c_int = 4;
pub const FF_PROFILE_AAC_HE_V2: libc::c_int = 28;
pub const FF_PROFILE_AAC_LD: libc::c_int = 22;
pub const FF_PROFILE_AAC_ELD: libc::c_int = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: libc::c_int = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: libc::c_int = 131;
pub const FF_PROFILE_DNXHD: libc::c_int = 0;
pub const FF_PROFILE_DNXHR_LB: libc::c_int = 1;
pub const FF_PROFILE_DNXHR_SQ: libc::c_int = 2;
pub const FF_PROFILE_DNXHR_HQ: libc::c_int = 3;
pub const FF_PROFILE_DNXHR_HQX: libc::c_int = 4;
pub const FF_PROFILE_DNXHR_444: libc::c_int = 5;
pub const FF_PROFILE_DTS: libc::c_int = 20;
pub const FF_PROFILE_DTS_ES: libc::c_int = 30;
pub const FF_PROFILE_DTS_96_24: libc::c_int = 40;
pub const FF_PROFILE_DTS_HD_HRA: libc::c_int = 50;
pub const FF_PROFILE_DTS_HD_MA: libc::c_int = 60;
pub const FF_PROFILE_DTS_EXPRESS: libc::c_int = 70;
pub const FF_PROFILE_MPEG2_422: libc::c_int = 0;
pub const FF_PROFILE_MPEG2_HIGH: libc::c_int = 1;
pub const FF_PROFILE_MPEG2_SS: libc::c_int = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: libc::c_int = 3;
pub const FF_PROFILE_MPEG2_MAIN: libc::c_int = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: libc::c_int = 5;
pub const FF_PROFILE_H264_CONSTRAINED: libc::c_int = 512;
pub const FF_PROFILE_H264_INTRA: libc::c_int = 2048;
pub const FF_PROFILE_H264_BASELINE: libc::c_int = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: libc::c_int = 578;
pub const FF_PROFILE_H264_MAIN: libc::c_int = 77;
pub const FF_PROFILE_H264_EXTENDED: libc::c_int = 88;
pub const FF_PROFILE_H264_HIGH: libc::c_int = 100;
pub const FF_PROFILE_H264_HIGH_10: libc::c_int = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: libc::c_int = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: libc::c_int = 118;
pub const FF_PROFILE_H264_HIGH_422: libc::c_int = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: libc::c_int = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: libc::c_int = 128;
pub const FF_PROFILE_H264_HIGH_444: libc::c_int = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: libc::c_int = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: libc::c_int = 2292;
pub const FF_PROFILE_H264_CAVLC_444: libc::c_int = 44;
pub const FF_PROFILE_VC1_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_VC1_MAIN: libc::c_int = 1;
pub const FF_PROFILE_VC1_COMPLEX: libc::c_int = 2;
pub const FF_PROFILE_VC1_ADVANCED: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: libc::c_int = 1;
pub const FF_PROFILE_MPEG4_CORE: libc::c_int = 2;
pub const FF_PROFILE_MPEG4_MAIN: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_N_BIT: libc::c_int = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: libc::c_int = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: libc::c_int = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: libc::c_int = 7;
pub const FF_PROFILE_MPEG4_HYBRID: libc::c_int = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: libc::c_int = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: libc::c_int = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: libc::c_int = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: libc::c_int = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: libc::c_int = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: libc::c_int = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: libc::c_int = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: libc::c_int = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: libc::c_int = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: libc::c_int = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: libc::c_int = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: libc::c_int = 4;
pub const FF_PROFILE_VP9_0: libc::c_int = 0;
pub const FF_PROFILE_VP9_1: libc::c_int = 1;
pub const FF_PROFILE_VP9_2: libc::c_int = 2;
pub const FF_PROFILE_VP9_3: libc::c_int = 3;
pub const FF_PROFILE_HEVC_MAIN: libc::c_int = 1;
pub const FF_PROFILE_HEVC_MAIN_10: libc::c_int = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: libc::c_int = 3;
pub const FF_PROFILE_HEVC_REXT: libc::c_int = 4;
pub const FF_PROFILE_VVC_MAIN_10: libc::c_int = 1;
pub const FF_PROFILE_VVC_MAIN_10_444: libc::c_int = 33;
pub const FF_PROFILE_AV1_MAIN: libc::c_int = 0;
pub const FF_PROFILE_AV1_HIGH: libc::c_int = 1;
pub const FF_PROFILE_AV1_PROFESSIONAL: libc::c_int = 2;
pub const FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT: libc::c_int = 192;
pub const FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT: libc::c_int = 193;
pub const FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT: libc::c_int = 194;
pub const FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS: libc::c_int = 195;
pub const FF_PROFILE_MJPEG_JPEG_LS: libc::c_int = 247;
pub const FF_PROFILE_SBC_MSBC: libc::c_int = 1;
pub const FF_PROFILE_PRORES_PROXY: libc::c_int = 0;
pub const FF_PROFILE_PRORES_LT: libc::c_int = 1;
pub const FF_PROFILE_PRORES_STANDARD: libc::c_int = 2;
pub const FF_PROFILE_PRORES_HQ: libc::c_int = 3;
pub const FF_PROFILE_PRORES_4444: libc::c_int = 4;
pub const FF_PROFILE_PRORES_XQ: libc::c_int = 5;
pub const FF_PROFILE_ARIB_PROFILE_A: libc::c_int = 0;
pub const FF_PROFILE_ARIB_PROFILE_C: libc::c_int = 1;
pub const FF_PROFILE_KLVA_SYNC: libc::c_int = 0;
pub const FF_PROFILE_KLVA_ASYNC: libc::c_int = 1;
pub const FF_LEVEL_UNKNOWN: libc::c_int = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: libc::c_int = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: libc::c_int = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: libc::c_int = 1;
pub const FF_SUB_CHARENC_MODE_IGNORE: libc::c_int = 2;
pub const FF_DEBUG_VIS_MV_P_FOR: libc::c_int = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: libc::c_int = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: libc::c_int = 4;
pub const FF_CODEC_PROPERTY_LOSSLESS: libc::c_int = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: libc::c_int = 2;
pub const FF_CODEC_PROPERTY_FILM_GRAIN: libc::c_int = 4;
pub const FF_SUB_TEXT_FMT_ASS: libc::c_int = 0;
pub const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL: libc::c_int = 512;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: libc::c_int = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: libc::c_int = 2;
pub const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH: libc::c_int = 4;
pub const AV_SUBTITLE_FLAG_FORCED: libc::c_int = 1;
pub const AV_PARSER_PTS_NB: libc::c_int = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: libc::c_int = 1;
pub const PARSER_FLAG_ONCE: libc::c_int = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: libc::c_int = 4;
pub const PARSER_FLAG_USE_CODEC_TS: libc::c_int = 4096;
pub const DV_PROFILE_BYTES: libc::c_int = 480;
pub const VORBIS_FLAG_HEADER: libc::c_int = 1;
pub const VORBIS_FLAG_COMMENT: libc::c_int = 2;
pub const VORBIS_FLAG_SETUP: libc::c_int = 4;
pub const LIBAVDEVICE_VERSION_MAJOR: libc::c_int = 59;
pub const LIBAVDEVICE_VERSION_MINOR: libc::c_int = 7;
pub const LIBAVDEVICE_VERSION_MICRO: libc::c_int = 100;
pub const AV_OPT_FLAG_ENCODING_PARAM: libc::c_int = 1;
pub const AV_OPT_FLAG_DECODING_PARAM: libc::c_int = 2;
pub const AV_OPT_FLAG_AUDIO_PARAM: libc::c_int = 8;
pub const AV_OPT_FLAG_VIDEO_PARAM: libc::c_int = 16;
pub const AV_OPT_FLAG_SUBTITLE_PARAM: libc::c_int = 32;
pub const AV_OPT_FLAG_EXPORT: libc::c_int = 64;
pub const AV_OPT_FLAG_READONLY: libc::c_int = 128;
pub const AV_OPT_FLAG_BSF_PARAM: libc::c_int = 256;
pub const AV_OPT_FLAG_RUNTIME_PARAM: libc::c_int = 32768;
pub const AV_OPT_FLAG_FILTERING_PARAM: libc::c_int = 65536;
pub const AV_OPT_FLAG_DEPRECATED: libc::c_int = 131072;
pub const AV_OPT_FLAG_CHILD_CONSTS: libc::c_int = 262144;
pub const AV_OPT_SEARCH_CHILDREN: libc::c_int = 1;
pub const AV_OPT_SEARCH_FAKE_OBJ: libc::c_int = 2;
pub const AV_OPT_ALLOW_NULL: libc::c_int = 4;
pub const AV_OPT_MULTI_COMPONENT_RANGE: libc::c_int = 4096;
pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: libc::c_int = 1;
pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: libc::c_int = 2;
pub const _TIME_H: libc::c_int = 1;
pub const _BITS_TIME_H: libc::c_int = 1;
pub const CLOCK_REALTIME: libc::c_int = 0;
pub const CLOCK_MONOTONIC: libc::c_int = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: libc::c_int = 2;
pub const CLOCK_THREAD_CPUTIME_ID: libc::c_int = 3;
pub const CLOCK_MONOTONIC_RAW: libc::c_int = 4;
pub const CLOCK_REALTIME_COARSE: libc::c_int = 5;
pub const CLOCK_MONOTONIC_COARSE: libc::c_int = 6;
pub const CLOCK_BOOTTIME: libc::c_int = 7;
pub const CLOCK_REALTIME_ALARM: libc::c_int = 8;
pub const CLOCK_BOOTTIME_ALARM: libc::c_int = 9;
pub const CLOCK_TAI: libc::c_int = 11;
pub const TIMER_ABSTIME: libc::c_int = 1;
pub const __struct_tm_defined: libc::c_int = 1;
pub const __itimerspec_defined: libc::c_int = 1;
pub const TIME_UTC: libc::c_int = 1;
pub const LIBAVFORMAT_VERSION_MAJOR: libc::c_int = 59;
pub const FF_API_R_FRAME_RATE: libc::c_int = 1;
pub const AVIO_SEEKABLE_NORMAL: libc::c_int = 1;
pub const AVIO_SEEKABLE_TIME: libc::c_int = 2;
pub const AVSEEK_SIZE: libc::c_int = 65536;
pub const AVSEEK_FORCE: libc::c_int = 131072;
pub const AVIO_FLAG_READ: libc::c_int = 1;
pub const AVIO_FLAG_WRITE: libc::c_int = 2;
pub const AVIO_FLAG_READ_WRITE: libc::c_int = 3;
pub const AVIO_FLAG_NONBLOCK: libc::c_int = 8;
pub const AVIO_FLAG_DIRECT: libc::c_int = 32768;
pub const LIBAVFORMAT_VERSION_MINOR: libc::c_int = 27;
pub const LIBAVFORMAT_VERSION_MICRO: libc::c_int = 100;
pub const AVPROBE_SCORE_EXTENSION: libc::c_int = 50;
pub const AVPROBE_SCORE_MIME: libc::c_int = 75;
pub const AVPROBE_SCORE_MAX: libc::c_int = 100;
pub const AVPROBE_PADDING_SIZE: libc::c_int = 32;
pub const AVFMT_NOFILE: libc::c_int = 1;
pub const AVFMT_NEEDNUMBER: libc::c_int = 2;
pub const AVFMT_EXPERIMENTAL: libc::c_int = 4;
pub const AVFMT_SHOW_IDS: libc::c_int = 8;
pub const AVFMT_GLOBALHEADER: libc::c_int = 64;
pub const AVFMT_NOTIMESTAMPS: libc::c_int = 128;
pub const AVFMT_GENERIC_INDEX: libc::c_int = 256;
pub const AVFMT_TS_DISCONT: libc::c_int = 512;
pub const AVFMT_VARIABLE_FPS: libc::c_int = 1024;
pub const AVFMT_NODIMENSIONS: libc::c_int = 2048;
pub const AVFMT_NOSTREAMS: libc::c_int = 4096;
pub const AVFMT_NOBINSEARCH: libc::c_int = 8192;
pub const AVFMT_NOGENSEARCH: libc::c_int = 16384;
pub const AVFMT_NO_BYTE_SEEK: libc::c_int = 32768;
pub const AVFMT_ALLOW_FLUSH: libc::c_int = 65536;
pub const AVFMT_TS_NONSTRICT: libc::c_int = 131072;
pub const AVFMT_TS_NEGATIVE: libc::c_int = 262144;
pub const AVFMT_SEEK_TO_PTS: libc::c_int = 67108864;
pub const AVINDEX_KEYFRAME: libc::c_int = 1;
pub const AVINDEX_DISCARD_FRAME: libc::c_int = 2;
pub const AV_DISPOSITION_DEFAULT: libc::c_int = 1;
pub const AV_DISPOSITION_DUB: libc::c_int = 2;
pub const AV_DISPOSITION_ORIGINAL: libc::c_int = 4;
pub const AV_DISPOSITION_COMMENT: libc::c_int = 8;
pub const AV_DISPOSITION_LYRICS: libc::c_int = 16;
pub const AV_DISPOSITION_KARAOKE: libc::c_int = 32;
pub const AV_DISPOSITION_FORCED: libc::c_int = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: libc::c_int = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: libc::c_int = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: libc::c_int = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: libc::c_int = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: libc::c_int = 2048;
pub const AV_DISPOSITION_NON_DIEGETIC: libc::c_int = 4096;
pub const AV_DISPOSITION_CAPTIONS: libc::c_int = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: libc::c_int = 131072;
pub const AV_DISPOSITION_METADATA: libc::c_int = 262144;
pub const AV_DISPOSITION_DEPENDENT: libc::c_int = 524288;
pub const AV_DISPOSITION_STILL_IMAGE: libc::c_int = 1048576;
pub const AV_PTS_WRAP_IGNORE: libc::c_int = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: libc::c_int = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: libc::c_int = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const AVSTREAM_EVENT_FLAG_NEW_PACKETS: libc::c_int = 2;
pub const AV_PROGRAM_RUNNING: libc::c_int = 1;
pub const AVFMTCTX_NOHEADER: libc::c_int = 1;
pub const AVFMTCTX_UNSEEKABLE: libc::c_int = 2;
pub const AVFMT_FLAG_GENPTS: libc::c_int = 1;
pub const AVFMT_FLAG_IGNIDX: libc::c_int = 2;
pub const AVFMT_FLAG_NONBLOCK: libc::c_int = 4;
pub const AVFMT_FLAG_IGNDTS: libc::c_int = 8;
pub const AVFMT_FLAG_NOFILLIN: libc::c_int = 16;
pub const AVFMT_FLAG_NOPARSE: libc::c_int = 32;
pub const AVFMT_FLAG_NOBUFFER: libc::c_int = 64;
pub const AVFMT_FLAG_CUSTOM_IO: libc::c_int = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: libc::c_int = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: libc::c_int = 512;
pub const AVFMT_FLAG_BITEXACT: libc::c_int = 1024;
pub const AVFMT_FLAG_SORT_DTS: libc::c_int = 65536;
pub const AVFMT_FLAG_PRIV_OPT: libc::c_int = 131072;
pub const AVFMT_FLAG_FAST_SEEK: libc::c_int = 524288;
pub const AVFMT_FLAG_SHORTEST: libc::c_int = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: libc::c_int = 2097152;
pub const FF_FDEBUG_TS: libc::c_int = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: libc::c_int = -1;
pub const AVFMT_AVOID_NEG_TS_DISABLED: libc::c_int = 0;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: libc::c_int = 2;
pub const AVSEEK_FLAG_BACKWARD: libc::c_int = 1;
pub const AVSEEK_FLAG_BYTE: libc::c_int = 2;
pub const AVSEEK_FLAG_ANY: libc::c_int = 4;
pub const AVSEEK_FLAG_FRAME: libc::c_int = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: libc::c_int = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: libc::c_int = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: libc::c_int = 1;
pub const LIBAVFILTER_VERSION_MAJOR: libc::c_int = 8;
pub const LIBAVFILTER_VERSION_MINOR: libc::c_int = 44;
pub const LIBAVFILTER_VERSION_MICRO: libc::c_int = 100;
pub const AVFILTER_FLAG_DYNAMIC_INPUTS: libc::c_int = 1;
pub const AVFILTER_FLAG_DYNAMIC_OUTPUTS: libc::c_int = 2;
pub const AVFILTER_FLAG_SLICE_THREADS: libc::c_int = 4;
pub const AVFILTER_FLAG_METADATA_ONLY: libc::c_int = 8;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC: libc::c_int = 65536;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL: libc::c_int = 131072;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE: libc::c_int = 196608;
pub const AVFILTER_THREAD_SLICE: libc::c_int = 1;
pub const AVFILTER_CMD_FLAG_ONE: libc::c_int = 1;
pub const AVFILTER_CMD_FLAG_FAST: libc::c_int = 2;
pub const AV_BUFFERSINK_FLAG_PEEK: libc::c_int = 1;
pub const AV_BUFFERSINK_FLAG_NO_REQUEST: libc::c_int = 2;
pub const AV_BF_ROUNDS: libc::c_int = 16;
pub const AV_ESCAPE_FLAG_WHITESPACE: libc::c_int = 1;
pub const AV_ESCAPE_FLAG_STRICT: libc::c_int = 2;
pub const AV_ESCAPE_FLAG_XML_SINGLE_QUOTES: libc::c_int = 4;
pub const AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES: libc::c_int = 8;
pub const AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES: libc::c_int = 1;
pub const AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS: libc::c_int = 2;
pub const AV_UTF8_FLAG_ACCEPT_SURROGATES: libc::c_int = 4;
pub const AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES: libc::c_int = 8;
pub const AV_UTF8_FLAG_ACCEPT_ALL: libc::c_int = 7;
pub const AV_BPRINT_SIZE_AUTOMATIC: libc::c_int = 1;
pub const AV_BPRINT_SIZE_COUNT_ONLY: libc::c_int = 0;
pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
pub const AV_CPU_FLAG_MMX: libc::c_int = 1;
pub const AV_CPU_FLAG_MMXEXT: libc::c_int = 2;
pub const AV_CPU_FLAG_MMX2: libc::c_int = 2;
pub const AV_CPU_FLAG_3DNOW: libc::c_int = 4;
pub const AV_CPU_FLAG_SSE: libc::c_int = 8;
pub const AV_CPU_FLAG_SSE2: libc::c_int = 16;
pub const AV_CPU_FLAG_SSE2SLOW: libc::c_int = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: libc::c_int = 32;
pub const AV_CPU_FLAG_SSE3: libc::c_int = 64;
pub const AV_CPU_FLAG_SSE3SLOW: libc::c_int = 536870912;
pub const AV_CPU_FLAG_SSSE3: libc::c_int = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: libc::c_int = 67108864;
pub const AV_CPU_FLAG_ATOM: libc::c_int = 268435456;
pub const AV_CPU_FLAG_SSE4: libc::c_int = 256;
pub const AV_CPU_FLAG_SSE42: libc::c_int = 512;
pub const AV_CPU_FLAG_AESNI: libc::c_int = 524288;
pub const AV_CPU_FLAG_AVX: libc::c_int = 16384;
pub const AV_CPU_FLAG_AVXSLOW: libc::c_int = 134217728;
pub const AV_CPU_FLAG_XOP: libc::c_int = 1024;
pub const AV_CPU_FLAG_FMA4: libc::c_int = 2048;
pub const AV_CPU_FLAG_CMOV: libc::c_int = 4096;
pub const AV_CPU_FLAG_AVX2: libc::c_int = 32768;
pub const AV_CPU_FLAG_FMA3: libc::c_int = 65536;
pub const AV_CPU_FLAG_BMI1: libc::c_int = 131072;
pub const AV_CPU_FLAG_BMI2: libc::c_int = 262144;
pub const AV_CPU_FLAG_AVX512: libc::c_int = 1048576;
pub const AV_CPU_FLAG_AVX512ICL: libc::c_int = 2097152;
pub const AV_CPU_FLAG_SLOW_GATHER: libc::c_int = 33554432;
pub const AV_CPU_FLAG_ALTIVEC: libc::c_int = 1;
pub const AV_CPU_FLAG_VSX: libc::c_int = 2;
pub const AV_CPU_FLAG_POWER8: libc::c_int = 4;
pub const AV_CPU_FLAG_ARMV5TE: libc::c_int = 1;
pub const AV_CPU_FLAG_ARMV6: libc::c_int = 2;
pub const AV_CPU_FLAG_ARMV6T2: libc::c_int = 4;
pub const AV_CPU_FLAG_VFP: libc::c_int = 8;
pub const AV_CPU_FLAG_VFPV3: libc::c_int = 16;
pub const AV_CPU_FLAG_NEON: libc::c_int = 32;
pub const AV_CPU_FLAG_ARMV8: libc::c_int = 64;
pub const AV_CPU_FLAG_VFP_VM: libc::c_int = 128;
pub const AV_CPU_FLAG_SETEND: libc::c_int = 65536;
pub const AV_CPU_FLAG_MMI: libc::c_int = 1;
pub const AV_CPU_FLAG_MSA: libc::c_int = 2;
pub const AV_CPU_FLAG_LSX: libc::c_int = 1;
pub const AV_CPU_FLAG_LASX: libc::c_int = 2;
pub const AV_FIFO_FLAG_AUTO_GROW: libc::c_int = 1;
pub const AV_HASH_MAX_SIZE: libc::c_int = 64;
pub const AV_PIX_FMT_FLAG_BE: libc::c_int = 1;
pub const AV_PIX_FMT_FLAG_PAL: libc::c_int = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: libc::c_int = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: libc::c_int = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: libc::c_int = 16;
pub const AV_PIX_FMT_FLAG_RGB: libc::c_int = 32;
pub const AV_PIX_FMT_FLAG_ALPHA: libc::c_int = 128;
pub const AV_PIX_FMT_FLAG_BAYER: libc::c_int = 256;
pub const AV_PIX_FMT_FLAG_FLOAT: libc::c_int = 512;
pub const FF_LOSS_RESOLUTION: libc::c_int = 1;
pub const FF_LOSS_DEPTH: libc::c_int = 2;
pub const FF_LOSS_COLORSPACE: libc::c_int = 4;
pub const FF_LOSS_ALPHA: libc::c_int = 8;
pub const FF_LOSS_COLORQUANT: libc::c_int = 16;
pub const FF_LOSS_CHROMA: libc::c_int = 32;
pub const AV_LZO_INPUT_DEPLETED: libc::c_int = 1;
pub const AV_LZO_OUTPUT_FULL: libc::c_int = 2;
pub const AV_LZO_INVALID_BACKPTR: libc::c_int = 4;
pub const AV_LZO_ERROR: libc::c_int = 8;
pub const AV_LZO_INPUT_PADDING: libc::c_int = 8;
pub const AV_LZO_OUTPUT_PADDING: libc::c_int = 12;
pub const AV_STEREO3D_FLAG_INVERT: libc::c_int = 1;
pub const AV_TIMECODE_STR_SIZE: libc::c_int = 23;
pub const LIBSWRESAMPLE_VERSION_MAJOR: libc::c_int = 4;
pub const LIBSWRESAMPLE_VERSION_MINOR: libc::c_int = 7;
pub const LIBSWRESAMPLE_VERSION_MICRO: libc::c_int = 100;
pub const SWR_FLAG_RESAMPLE: libc::c_int = 1;
pub const LIBSWSCALE_VERSION_MAJOR: libc::c_int = 6;
pub const LIBSWSCALE_VERSION_MINOR: libc::c_int = 7;
pub const LIBSWSCALE_VERSION_MICRO: libc::c_int = 100;
pub const SWS_FAST_BILINEAR: libc::c_int = 1;
pub const SWS_BILINEAR: libc::c_int = 2;
pub const SWS_BICUBIC: libc::c_int = 4;
pub const SWS_X: libc::c_int = 8;
pub const SWS_POINT: libc::c_int = 16;
pub const SWS_AREA: libc::c_int = 32;
pub const SWS_BICUBLIN: libc::c_int = 64;
pub const SWS_GAUSS: libc::c_int = 128;
pub const SWS_SINC: libc::c_int = 256;
pub const SWS_LANCZOS: libc::c_int = 512;
pub const SWS_SPLINE: libc::c_int = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: libc::c_int = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: libc::c_int = 16;
pub const SWS_PARAM_DEFAULT: libc::c_int = 123456;
pub const SWS_PRINT_INFO: libc::c_int = 4096;
pub const SWS_FULL_CHR_H_INT: libc::c_int = 8192;
pub const SWS_FULL_CHR_H_INP: libc::c_int = 16384;
pub const SWS_DIRECT_BGR: libc::c_int = 32768;
pub const SWS_ACCURATE_RND: libc::c_int = 262144;
pub const SWS_BITEXACT: libc::c_int = 524288;
pub const SWS_ERROR_DIFFUSION: libc::c_int = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: libc::c_int = 1;
pub const SWS_CS_FCC: libc::c_int = 4;
pub const SWS_CS_ITU601: libc::c_int = 5;
pub const SWS_CS_ITU624: libc::c_int = 5;
pub const SWS_CS_SMPTE170M: libc::c_int = 5;
pub const SWS_CS_SMPTE240M: libc::c_int = 7;
pub const SWS_CS_DEFAULT: libc::c_int = 5;
pub const SWS_CS_BT2020: libc::c_int = 9;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __suseconds64_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSampleFormat {
    AV_SAMPLE_FMT_NONE = -1,
    AV_SAMPLE_FMT_U8 = 0,
    AV_SAMPLE_FMT_S16 = 1,
    AV_SAMPLE_FMT_S32 = 2,
    AV_SAMPLE_FMT_FLT = 3,
    AV_SAMPLE_FMT_DBL = 4,
    AV_SAMPLE_FMT_U8P = 5,
    AV_SAMPLE_FMT_S16P = 6,
    AV_SAMPLE_FMT_S32P = 7,
    AV_SAMPLE_FMT_FLTP = 8,
    AV_SAMPLE_FMT_DBLP = 9,
    AV_SAMPLE_FMT_S64 = 10,
    AV_SAMPLE_FMT_S64P = 11,
    AV_SAMPLE_FMT_NB = 12,
}
extern "C" {
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_sample_fmt(name: *const libc::c_char) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_alt_sample_fmt(sample_fmt: AVSampleFormat, planar: libc::c_int)
        -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_sample_fmt_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_get_buffer_size(
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut libc::c_int,
        buf: *const u8,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *mut u8,
        dst_offset: libc::c_int,
        src_offset: libc::c_int,
        nb_samples: libc::c_int,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: libc::c_int,
        nb_samples: libc::c_int,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avutil_version() -> libc::c_uint;
}
extern "C" {
    pub fn av_version_info() -> *const libc::c_char;
}
extern "C" {
    pub fn avutil_configuration() -> *const libc::c_char;
}
extern "C" {
    pub fn avutil_license() -> *const libc::c_char;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVMediaType {
    AVMEDIA_TYPE_UNKNOWN = -1,
    AVMEDIA_TYPE_VIDEO = 0,
    AVMEDIA_TYPE_AUDIO = 1,
    AVMEDIA_TYPE_DATA = 2,
    AVMEDIA_TYPE_SUBTITLE = 3,
    AVMEDIA_TYPE_ATTACHMENT = 4,
    AVMEDIA_TYPE_NB = 5,
}
extern "C" {
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPictureType {
    AV_PICTURE_TYPE_NONE = 0,
    AV_PICTURE_TYPE_I = 1,
    AV_PICTURE_TYPE_P = 2,
    AV_PICTURE_TYPE_B = 3,
    AV_PICTURE_TYPE_S = 4,
    AV_PICTURE_TYPE_SI = 5,
    AV_PICTURE_TYPE_SP = 6,
    AV_PICTURE_TYPE_BI = 7,
}
extern "C" {
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> libc::c_char;
}
pub type __gwchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> uintmax_t;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub static mut signgam: libc::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = _bindgen_ty_1::FP_NAN;
pub const FP_INFINITE: _bindgen_ty_1 = _bindgen_ty_1::FP_INFINITE;
pub const FP_ZERO: _bindgen_ty_1 = _bindgen_ty_1::FP_ZERO;
pub const FP_SUBNORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_SUBNORMAL;
pub const FP_NORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_NORMAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: libc::c_int,
        __old: *const libc::c_char,
        __newfd: libc::c_int,
        __new: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __pfx: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const libc::c_char,
        __modes: *const libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut libc::c_void,
        __len: usize,
        __modes: *const libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut libc::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut libc::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: libc::c_int,
        __fmt: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: libc::c_int, __fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(__w: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut libc::c_void,
        __size: libc::c_ulong,
        __n: libc::c_ulong,
        __stream: *mut FILE,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const libc::c_void,
        __size: libc::c_ulong,
        __n: libc::c_ulong,
        __s: *mut FILE,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: libc::c_long, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const libc::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const libc::c_char) -> libc::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: libc::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__high as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_schar,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = libc::c_uint;
pub type __thrd_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __once_flag {
    pub __data: libc::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: libc::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: libc::c_int,
    pub rand_deg: libc::c_int,
    pub rand_sep: libc::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: libc::c_uint, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut libc::c_char, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut libc::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct drand48_data {
    pub __x: [libc::c_ushort; 3usize],
    pub __old_x: [libc::c_ushort; 3usize],
    pub __c: libc::c_ushort,
    pub __init: libc::c_ushort,
    pub __a: libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: libc::c_long, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut libc::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut libc::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn alloca(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut libc::c_void,
        __alignment: usize,
        __size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(__status: libc::c_int, __arg: *mut libc::c_void),
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn exit(__status: libc::c_int);
}
extern "C" {
    pub fn quick_exit(__status: libc::c_int);
}
extern "C" {
    pub fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn clearenv() -> libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut libc::c_char, __suffixlen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(__command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const libc::c_char,
        __resolved: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut libc::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(__x: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(__x: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: libc::c_int, __buf: *mut libc::c_char)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut libc::c_char, __wchar: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut libc::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut libc::c_char,
        __tokens: *const *mut libc::c_char,
        __valuep: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __l: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const libc::c_char, __n: libc::c_ulong) -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __reject: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const libc::c_char, __accept: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __accept: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut libc::c_char, __delim: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: libc::c_int,
        __buf: *mut libc::c_char,
        __buflen: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: libc::c_int, __l: locale_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const libc::c_void, __dest: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut libc::c_void, __n: libc::c_ulong);
}
extern "C" {
    pub fn index(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ffs(__i: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn av_log2(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn av_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_mallocz(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_mallocz_array(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_realloc(ptr: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_reallocp(ptr: *mut libc::c_void, size: usize) -> libc::c_int;
}
extern "C" {
    pub fn av_realloc_f(ptr: *mut libc::c_void, nelem: usize, elsize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_realloc_array(ptr: *mut libc::c_void, nmemb: usize, size: usize)
        -> *mut libc::c_void;
}
extern "C" {
    pub fn av_reallocp_array(ptr: *mut libc::c_void, nmemb: usize, size: usize) -> libc::c_int;
}
extern "C" {
    pub fn av_fast_realloc(
        ptr: *mut libc::c_void,
        size: *mut libc::c_uint,
        min_size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_fast_malloc(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    pub fn av_fast_mallocz(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    pub fn av_free(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn av_freep(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn av_strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn av_strndup(s: *const libc::c_char, len: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn av_memdup(p: *const libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_memcpy_backptr(dst: *mut u8, back: libc::c_int, cnt: libc::c_int);
}
extern "C" {
    pub fn av_dynarray_add(
        tab_ptr: *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem: *mut libc::c_void,
    );
}
extern "C" {
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_size_mult(a: usize, b: usize, r: *mut usize) -> libc::c_int;
}
extern "C" {
    pub fn av_max_alloc(max: usize);
}
extern "C" {
    pub fn av_strerror(
        errnum: libc::c_int,
        errbuf: *mut libc::c_char,
        errbuf_size: usize,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVRational {
    pub num: libc::c_int,
    pub den: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVRational() {
    assert_eq!(
        ::std::mem::size_of::<AVRational>(),
        8usize,
        concat!("Size of: ", stringify!(AVRational))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRational>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRational))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).den as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(den)
        )
    );
}
extern "C" {
    pub fn av_reduce(
        dst_num: *mut libc::c_int,
        dst_den: *mut libc::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_d2q(d: f64, max: libc::c_int) -> AVRational;
}
extern "C" {
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> libc::c_int;
}
extern "C" {
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational) -> libc::c_int;
}
extern "C" {
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
extern "C" {
    pub fn av_gcd_q(
        a: AVRational,
        b: AVRational,
        max_den: libc::c_int,
        def: AVRational,
    ) -> AVRational;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat32>(),
        4usize,
        concat!("Size of: ", stringify!(av_intfloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(av_intfloat32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat64>(),
        8usize,
        concat!("Size of: ", stringify!(av_intfloat64))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(av_intfloat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(f)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVRounding {
    AV_ROUND_ZERO = 0,
    AV_ROUND_INF = 1,
    AV_ROUND_DOWN = 2,
    AV_ROUND_UP = 3,
    AV_ROUND_NEAR_INF = 5,
    AV_ROUND_PASS_MINMAX = 8192,
}
extern "C" {
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_compare_ts(ts_a: i64, tb_a: AVRational, ts_b: i64, tb_b: AVRational) -> libc::c_int;
}
extern "C" {
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: libc::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVClassCategory {
    AV_CLASS_CATEGORY_NA = 0,
    AV_CLASS_CATEGORY_INPUT = 1,
    AV_CLASS_CATEGORY_OUTPUT = 2,
    AV_CLASS_CATEGORY_MUXER = 3,
    AV_CLASS_CATEGORY_DEMUXER = 4,
    AV_CLASS_CATEGORY_ENCODER = 5,
    AV_CLASS_CATEGORY_DECODER = 6,
    AV_CLASS_CATEGORY_FILTER = 7,
    AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8,
    AV_CLASS_CATEGORY_SWSCALER = 9,
    AV_CLASS_CATEGORY_SWRESAMPLER = 10,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43,
    AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44,
    AV_CLASS_CATEGORY_DEVICE_INPUT = 45,
    AV_CLASS_CATEGORY_NB = 46,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVClass {
    pub class_name: *const libc::c_char,
    pub item_name:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void) -> *const libc::c_char>,
    pub option: *const AVOption,
    pub version: libc::c_int,
    pub log_level_offset_offset: libc::c_int,
    pub parent_log_context_offset: libc::c_int,
    pub category: AVClassCategory,
    pub get_category:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void) -> AVClassCategory>,
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut libc::c_void,
            key: *const libc::c_char,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut libc::c_void, prev: *mut libc::c_void) -> *mut libc::c_void,
    >,
    pub child_class_iterate:
        ::std::option::Option<unsafe extern "C" fn(iter: *mut *mut libc::c_void) -> *const AVClass>,
}
#[test]
fn bindgen_test_layout_AVClass() {
    assert_eq!(
        ::std::mem::size_of::<AVClass>(),
        72usize,
        concat!("Size of: ", stringify!(AVClass))
    );
    assert_eq!(
        ::std::mem::align_of::<AVClass>(),
        8usize,
        concat!("Alignment of ", stringify!(AVClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).class_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).item_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(item_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).option as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).log_level_offset_offset as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(log_level_offset_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVClass>())).parent_log_context_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(parent_log_context_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).category as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).get_category as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(get_category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).query_ranges as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(query_ranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_class_iterate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_class_iterate)
        )
    );
}
extern "C" {
    pub fn av_log(avcl: *mut libc::c_void, level: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    pub fn av_log_once(
        avcl: *mut libc::c_void,
        initial_level: libc::c_int,
        subsequent_level: libc::c_int,
        state: *mut libc::c_int,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    pub fn av_vlog(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn av_log_get_level() -> libc::c_int;
}
extern "C" {
    pub fn av_log_set_level(level: libc::c_int);
}
extern "C" {
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: libc::c_int,
                arg3: *const libc::c_char,
                arg4: *mut __va_list_tag,
            ),
        >,
    );
}
extern "C" {
    pub fn av_log_default_callback(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn av_default_item_name(ctx: *mut libc::c_void) -> *const libc::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut libc::c_void) -> AVClassCategory;
}
extern "C" {
    pub fn av_log_format_line(
        ptr: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
        line: *mut libc::c_char,
        line_size: libc::c_int,
        print_prefix: *mut libc::c_int,
    );
}
extern "C" {
    pub fn av_log_format_line2(
        ptr: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
        line: *mut libc::c_char,
        line_size: libc::c_int,
        print_prefix: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: libc::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> libc::c_int;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_Y400A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_GBR24P: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_GBRP;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPixelFormat {
    AV_PIX_FMT_NONE = -1,
    AV_PIX_FMT_YUV420P = 0,
    AV_PIX_FMT_YUYV422 = 1,
    AV_PIX_FMT_RGB24 = 2,
    AV_PIX_FMT_BGR24 = 3,
    AV_PIX_FMT_YUV422P = 4,
    AV_PIX_FMT_YUV444P = 5,
    AV_PIX_FMT_YUV410P = 6,
    AV_PIX_FMT_YUV411P = 7,
    AV_PIX_FMT_GRAY8 = 8,
    AV_PIX_FMT_MONOWHITE = 9,
    AV_PIX_FMT_MONOBLACK = 10,
    AV_PIX_FMT_PAL8 = 11,
    AV_PIX_FMT_YUVJ420P = 12,
    AV_PIX_FMT_YUVJ422P = 13,
    AV_PIX_FMT_YUVJ444P = 14,
    AV_PIX_FMT_UYVY422 = 15,
    AV_PIX_FMT_UYYVYY411 = 16,
    AV_PIX_FMT_BGR8 = 17,
    AV_PIX_FMT_BGR4 = 18,
    AV_PIX_FMT_BGR4_BYTE = 19,
    AV_PIX_FMT_RGB8 = 20,
    AV_PIX_FMT_RGB4 = 21,
    AV_PIX_FMT_RGB4_BYTE = 22,
    AV_PIX_FMT_NV12 = 23,
    AV_PIX_FMT_NV21 = 24,
    AV_PIX_FMT_ARGB = 25,
    AV_PIX_FMT_RGBA = 26,
    AV_PIX_FMT_ABGR = 27,
    AV_PIX_FMT_BGRA = 28,
    AV_PIX_FMT_GRAY16BE = 29,
    AV_PIX_FMT_GRAY16LE = 30,
    AV_PIX_FMT_YUV440P = 31,
    AV_PIX_FMT_YUVJ440P = 32,
    AV_PIX_FMT_YUVA420P = 33,
    AV_PIX_FMT_RGB48BE = 34,
    AV_PIX_FMT_RGB48LE = 35,
    AV_PIX_FMT_RGB565BE = 36,
    AV_PIX_FMT_RGB565LE = 37,
    AV_PIX_FMT_RGB555BE = 38,
    AV_PIX_FMT_RGB555LE = 39,
    AV_PIX_FMT_BGR565BE = 40,
    AV_PIX_FMT_BGR565LE = 41,
    AV_PIX_FMT_BGR555BE = 42,
    AV_PIX_FMT_BGR555LE = 43,
    AV_PIX_FMT_VAAPI = 44,
    AV_PIX_FMT_YUV420P16LE = 45,
    AV_PIX_FMT_YUV420P16BE = 46,
    AV_PIX_FMT_YUV422P16LE = 47,
    AV_PIX_FMT_YUV422P16BE = 48,
    AV_PIX_FMT_YUV444P16LE = 49,
    AV_PIX_FMT_YUV444P16BE = 50,
    AV_PIX_FMT_DXVA2_VLD = 51,
    AV_PIX_FMT_RGB444LE = 52,
    AV_PIX_FMT_RGB444BE = 53,
    AV_PIX_FMT_BGR444LE = 54,
    AV_PIX_FMT_BGR444BE = 55,
    AV_PIX_FMT_YA8 = 56,
    AV_PIX_FMT_BGR48BE = 57,
    AV_PIX_FMT_BGR48LE = 58,
    AV_PIX_FMT_YUV420P9BE = 59,
    AV_PIX_FMT_YUV420P9LE = 60,
    AV_PIX_FMT_YUV420P10BE = 61,
    AV_PIX_FMT_YUV420P10LE = 62,
    AV_PIX_FMT_YUV422P10BE = 63,
    AV_PIX_FMT_YUV422P10LE = 64,
    AV_PIX_FMT_YUV444P9BE = 65,
    AV_PIX_FMT_YUV444P9LE = 66,
    AV_PIX_FMT_YUV444P10BE = 67,
    AV_PIX_FMT_YUV444P10LE = 68,
    AV_PIX_FMT_YUV422P9BE = 69,
    AV_PIX_FMT_YUV422P9LE = 70,
    AV_PIX_FMT_GBRP = 71,
    AV_PIX_FMT_GBRP9BE = 72,
    AV_PIX_FMT_GBRP9LE = 73,
    AV_PIX_FMT_GBRP10BE = 74,
    AV_PIX_FMT_GBRP10LE = 75,
    AV_PIX_FMT_GBRP16BE = 76,
    AV_PIX_FMT_GBRP16LE = 77,
    AV_PIX_FMT_YUVA422P = 78,
    AV_PIX_FMT_YUVA444P = 79,
    AV_PIX_FMT_YUVA420P9BE = 80,
    AV_PIX_FMT_YUVA420P9LE = 81,
    AV_PIX_FMT_YUVA422P9BE = 82,
    AV_PIX_FMT_YUVA422P9LE = 83,
    AV_PIX_FMT_YUVA444P9BE = 84,
    AV_PIX_FMT_YUVA444P9LE = 85,
    AV_PIX_FMT_YUVA420P10BE = 86,
    AV_PIX_FMT_YUVA420P10LE = 87,
    AV_PIX_FMT_YUVA422P10BE = 88,
    AV_PIX_FMT_YUVA422P10LE = 89,
    AV_PIX_FMT_YUVA444P10BE = 90,
    AV_PIX_FMT_YUVA444P10LE = 91,
    AV_PIX_FMT_YUVA420P16BE = 92,
    AV_PIX_FMT_YUVA420P16LE = 93,
    AV_PIX_FMT_YUVA422P16BE = 94,
    AV_PIX_FMT_YUVA422P16LE = 95,
    AV_PIX_FMT_YUVA444P16BE = 96,
    AV_PIX_FMT_YUVA444P16LE = 97,
    AV_PIX_FMT_VDPAU = 98,
    AV_PIX_FMT_XYZ12LE = 99,
    AV_PIX_FMT_XYZ12BE = 100,
    AV_PIX_FMT_NV16 = 101,
    AV_PIX_FMT_NV20LE = 102,
    AV_PIX_FMT_NV20BE = 103,
    AV_PIX_FMT_RGBA64BE = 104,
    AV_PIX_FMT_RGBA64LE = 105,
    AV_PIX_FMT_BGRA64BE = 106,
    AV_PIX_FMT_BGRA64LE = 107,
    AV_PIX_FMT_YVYU422 = 108,
    AV_PIX_FMT_YA16BE = 109,
    AV_PIX_FMT_YA16LE = 110,
    AV_PIX_FMT_GBRAP = 111,
    AV_PIX_FMT_GBRAP16BE = 112,
    AV_PIX_FMT_GBRAP16LE = 113,
    AV_PIX_FMT_QSV = 114,
    AV_PIX_FMT_MMAL = 115,
    AV_PIX_FMT_D3D11VA_VLD = 116,
    AV_PIX_FMT_CUDA = 117,
    AV_PIX_FMT_0RGB = 118,
    AV_PIX_FMT_RGB0 = 119,
    AV_PIX_FMT_0BGR = 120,
    AV_PIX_FMT_BGR0 = 121,
    AV_PIX_FMT_YUV420P12BE = 122,
    AV_PIX_FMT_YUV420P12LE = 123,
    AV_PIX_FMT_YUV420P14BE = 124,
    AV_PIX_FMT_YUV420P14LE = 125,
    AV_PIX_FMT_YUV422P12BE = 126,
    AV_PIX_FMT_YUV422P12LE = 127,
    AV_PIX_FMT_YUV422P14BE = 128,
    AV_PIX_FMT_YUV422P14LE = 129,
    AV_PIX_FMT_YUV444P12BE = 130,
    AV_PIX_FMT_YUV444P12LE = 131,
    AV_PIX_FMT_YUV444P14BE = 132,
    AV_PIX_FMT_YUV444P14LE = 133,
    AV_PIX_FMT_GBRP12BE = 134,
    AV_PIX_FMT_GBRP12LE = 135,
    AV_PIX_FMT_GBRP14BE = 136,
    AV_PIX_FMT_GBRP14LE = 137,
    AV_PIX_FMT_YUVJ411P = 138,
    AV_PIX_FMT_BAYER_BGGR8 = 139,
    AV_PIX_FMT_BAYER_RGGB8 = 140,
    AV_PIX_FMT_BAYER_GBRG8 = 141,
    AV_PIX_FMT_BAYER_GRBG8 = 142,
    AV_PIX_FMT_BAYER_BGGR16LE = 143,
    AV_PIX_FMT_BAYER_BGGR16BE = 144,
    AV_PIX_FMT_BAYER_RGGB16LE = 145,
    AV_PIX_FMT_BAYER_RGGB16BE = 146,
    AV_PIX_FMT_BAYER_GBRG16LE = 147,
    AV_PIX_FMT_BAYER_GBRG16BE = 148,
    AV_PIX_FMT_BAYER_GRBG16LE = 149,
    AV_PIX_FMT_BAYER_GRBG16BE = 150,
    AV_PIX_FMT_XVMC = 151,
    AV_PIX_FMT_YUV440P10LE = 152,
    AV_PIX_FMT_YUV440P10BE = 153,
    AV_PIX_FMT_YUV440P12LE = 154,
    AV_PIX_FMT_YUV440P12BE = 155,
    AV_PIX_FMT_AYUV64LE = 156,
    AV_PIX_FMT_AYUV64BE = 157,
    AV_PIX_FMT_VIDEOTOOLBOX = 158,
    AV_PIX_FMT_P010LE = 159,
    AV_PIX_FMT_P010BE = 160,
    AV_PIX_FMT_GBRAP12BE = 161,
    AV_PIX_FMT_GBRAP12LE = 162,
    AV_PIX_FMT_GBRAP10BE = 163,
    AV_PIX_FMT_GBRAP10LE = 164,
    AV_PIX_FMT_MEDIACODEC = 165,
    AV_PIX_FMT_GRAY12BE = 166,
    AV_PIX_FMT_GRAY12LE = 167,
    AV_PIX_FMT_GRAY10BE = 168,
    AV_PIX_FMT_GRAY10LE = 169,
    AV_PIX_FMT_P016LE = 170,
    AV_PIX_FMT_P016BE = 171,
    AV_PIX_FMT_D3D11 = 172,
    AV_PIX_FMT_GRAY9BE = 173,
    AV_PIX_FMT_GRAY9LE = 174,
    AV_PIX_FMT_GBRPF32BE = 175,
    AV_PIX_FMT_GBRPF32LE = 176,
    AV_PIX_FMT_GBRAPF32BE = 177,
    AV_PIX_FMT_GBRAPF32LE = 178,
    AV_PIX_FMT_DRM_PRIME = 179,
    AV_PIX_FMT_OPENCL = 180,
    AV_PIX_FMT_GRAY14BE = 181,
    AV_PIX_FMT_GRAY14LE = 182,
    AV_PIX_FMT_GRAYF32BE = 183,
    AV_PIX_FMT_GRAYF32LE = 184,
    AV_PIX_FMT_YUVA422P12BE = 185,
    AV_PIX_FMT_YUVA422P12LE = 186,
    AV_PIX_FMT_YUVA444P12BE = 187,
    AV_PIX_FMT_YUVA444P12LE = 188,
    AV_PIX_FMT_NV24 = 189,
    AV_PIX_FMT_NV42 = 190,
    AV_PIX_FMT_VULKAN = 191,
    AV_PIX_FMT_Y210BE = 192,
    AV_PIX_FMT_Y210LE = 193,
    AV_PIX_FMT_X2RGB10LE = 194,
    AV_PIX_FMT_X2RGB10BE = 195,
    AV_PIX_FMT_X2BGR10LE = 196,
    AV_PIX_FMT_X2BGR10BE = 197,
    AV_PIX_FMT_P210BE = 198,
    AV_PIX_FMT_P210LE = 199,
    AV_PIX_FMT_P410BE = 200,
    AV_PIX_FMT_P410LE = 201,
    AV_PIX_FMT_P216BE = 202,
    AV_PIX_FMT_P216LE = 203,
    AV_PIX_FMT_P416BE = 204,
    AV_PIX_FMT_P416LE = 205,
    AV_PIX_FMT_NB = 206,
}
impl AVColorPrimaries {
    pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = AVColorPrimaries::AVCOL_PRI_SMPTE428;
}
impl AVColorPrimaries {
    pub const AVCOL_PRI_JEDEC_P22: AVColorPrimaries = AVColorPrimaries::AVCOL_PRI_EBU3213;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorPrimaries {
    AVCOL_PRI_RESERVED0 = 0,
    AVCOL_PRI_BT709 = 1,
    AVCOL_PRI_UNSPECIFIED = 2,
    AVCOL_PRI_RESERVED = 3,
    AVCOL_PRI_BT470M = 4,
    AVCOL_PRI_BT470BG = 5,
    AVCOL_PRI_SMPTE170M = 6,
    AVCOL_PRI_SMPTE240M = 7,
    AVCOL_PRI_FILM = 8,
    AVCOL_PRI_BT2020 = 9,
    AVCOL_PRI_SMPTE428 = 10,
    AVCOL_PRI_SMPTE431 = 11,
    AVCOL_PRI_SMPTE432 = 12,
    AVCOL_PRI_EBU3213 = 22,
    AVCOL_PRI_NB = 23,
}
impl AVColorTransferCharacteristic {
    pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic =
        AVColorTransferCharacteristic::AVCOL_TRC_SMPTE2084;
}
impl AVColorTransferCharacteristic {
    pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic =
        AVColorTransferCharacteristic::AVCOL_TRC_SMPTE428;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorTransferCharacteristic {
    AVCOL_TRC_RESERVED0 = 0,
    AVCOL_TRC_BT709 = 1,
    AVCOL_TRC_UNSPECIFIED = 2,
    AVCOL_TRC_RESERVED = 3,
    AVCOL_TRC_GAMMA22 = 4,
    AVCOL_TRC_GAMMA28 = 5,
    AVCOL_TRC_SMPTE170M = 6,
    AVCOL_TRC_SMPTE240M = 7,
    AVCOL_TRC_LINEAR = 8,
    AVCOL_TRC_LOG = 9,
    AVCOL_TRC_LOG_SQRT = 10,
    AVCOL_TRC_IEC61966_2_4 = 11,
    AVCOL_TRC_BT1361_ECG = 12,
    AVCOL_TRC_IEC61966_2_1 = 13,
    AVCOL_TRC_BT2020_10 = 14,
    AVCOL_TRC_BT2020_12 = 15,
    AVCOL_TRC_SMPTE2084 = 16,
    AVCOL_TRC_SMPTE428 = 17,
    AVCOL_TRC_ARIB_STD_B67 = 18,
    AVCOL_TRC_NB = 19,
}
impl AVColorSpace {
    pub const AVCOL_SPC_YCOCG: AVColorSpace = AVColorSpace::AVCOL_SPC_YCGCO;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorSpace {
    AVCOL_SPC_RGB = 0,
    AVCOL_SPC_BT709 = 1,
    AVCOL_SPC_UNSPECIFIED = 2,
    AVCOL_SPC_RESERVED = 3,
    AVCOL_SPC_FCC = 4,
    AVCOL_SPC_BT470BG = 5,
    AVCOL_SPC_SMPTE170M = 6,
    AVCOL_SPC_SMPTE240M = 7,
    AVCOL_SPC_YCGCO = 8,
    AVCOL_SPC_BT2020_NCL = 9,
    AVCOL_SPC_BT2020_CL = 10,
    AVCOL_SPC_SMPTE2085 = 11,
    AVCOL_SPC_CHROMA_DERIVED_NCL = 12,
    AVCOL_SPC_CHROMA_DERIVED_CL = 13,
    AVCOL_SPC_ICTCP = 14,
    AVCOL_SPC_NB = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorRange {
    AVCOL_RANGE_UNSPECIFIED = 0,
    AVCOL_RANGE_MPEG = 1,
    AVCOL_RANGE_JPEG = 2,
    AVCOL_RANGE_NB = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVChromaLocation {
    AVCHROMA_LOC_UNSPECIFIED = 0,
    AVCHROMA_LOC_LEFT = 1,
    AVCHROMA_LOC_CENTER = 2,
    AVCHROMA_LOC_TOPLEFT = 3,
    AVCHROMA_LOC_TOP = 4,
    AVCHROMA_LOC_BOTTOMLEFT = 5,
    AVCHROMA_LOC_BOTTOM = 6,
    AVCHROMA_LOC_NB = 7,
}
extern "C" {
    pub fn av_int_list_length_for_size(
        elsize: libc::c_uint,
        list: *const libc::c_void,
        term: u64,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn av_fopen_utf8(path: *const libc::c_char, mode: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    pub fn av_fourcc_make_string(buf: *mut libc::c_char, fourcc: u32) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    pub data: *mut u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_AVBufferRef() {
    assert_eq!(
        ::std::mem::size_of::<AVBufferRef>(),
        24usize,
        concat!("Size of: ", stringify!(AVBufferRef))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferRef>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn av_buffer_alloc(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_allocz(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_create(
        data: *mut u8,
        size: usize,
        free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void, data: *mut u8)>,
        opaque: *mut libc::c_void,
        flags: libc::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_default_free(opaque: *mut libc::c_void, data: *mut u8);
}
extern "C" {
    pub fn av_buffer_ref(buf: *const AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: usize) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_replace(dst: *mut *mut AVBufferRef, src: *const AVBufferRef) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_buffer_pool_init(
        size: usize,
        alloc: ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut AVBufferRef>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_init2(
        size: usize,
        opaque: *mut libc::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut libc::c_void, size: usize) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_pool_buffer_get_opaque(ref_: *const AVBufferRef) -> *mut libc::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDictionaryEntry {
    pub key: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_AVDictionaryEntry() {
    assert_eq!(
        ::std::mem::size_of::<AVDictionaryEntry>(),
        16usize,
        concat!("Size of: ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDictionaryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const libc::c_char,
        prev: *const AVDictionaryEntry,
        flags: libc::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    pub fn av_dict_count(m: *const AVDictionary) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const libc::c_char,
        value: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const libc::c_char,
        value: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str_: *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut libc::c_char,
        key_val_sep: libc::c_char,
        pairs_sep: libc::c_char,
    ) -> libc::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVChannel {
    AV_CHAN_NONE = -1,
    AV_CHAN_FRONT_LEFT = 0,
    AV_CHAN_FRONT_RIGHT = 1,
    AV_CHAN_FRONT_CENTER = 2,
    AV_CHAN_LOW_FREQUENCY = 3,
    AV_CHAN_BACK_LEFT = 4,
    AV_CHAN_BACK_RIGHT = 5,
    AV_CHAN_FRONT_LEFT_OF_CENTER = 6,
    AV_CHAN_FRONT_RIGHT_OF_CENTER = 7,
    AV_CHAN_BACK_CENTER = 8,
    AV_CHAN_SIDE_LEFT = 9,
    AV_CHAN_SIDE_RIGHT = 10,
    AV_CHAN_TOP_CENTER = 11,
    AV_CHAN_TOP_FRONT_LEFT = 12,
    AV_CHAN_TOP_FRONT_CENTER = 13,
    AV_CHAN_TOP_FRONT_RIGHT = 14,
    AV_CHAN_TOP_BACK_LEFT = 15,
    AV_CHAN_TOP_BACK_CENTER = 16,
    AV_CHAN_TOP_BACK_RIGHT = 17,
    AV_CHAN_STEREO_LEFT = 29,
    AV_CHAN_STEREO_RIGHT = 30,
    AV_CHAN_WIDE_LEFT = 31,
    AV_CHAN_WIDE_RIGHT = 32,
    AV_CHAN_SURROUND_DIRECT_LEFT = 33,
    AV_CHAN_SURROUND_DIRECT_RIGHT = 34,
    AV_CHAN_LOW_FREQUENCY_2 = 35,
    AV_CHAN_TOP_SIDE_LEFT = 36,
    AV_CHAN_TOP_SIDE_RIGHT = 37,
    AV_CHAN_BOTTOM_FRONT_CENTER = 38,
    AV_CHAN_BOTTOM_FRONT_LEFT = 39,
    AV_CHAN_BOTTOM_FRONT_RIGHT = 40,
    AV_CHAN_UNUSED = 512,
    AV_CHAN_UNKNOWN = 768,
    AV_CHAN_AMBISONIC_BASE = 1024,
    AV_CHAN_AMBISONIC_END = 2047,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVChannelOrder {
    AV_CHANNEL_ORDER_UNSPEC = 0,
    AV_CHANNEL_ORDER_NATIVE = 1,
    AV_CHANNEL_ORDER_CUSTOM = 2,
    AV_CHANNEL_ORDER_AMBISONIC = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVMatrixEncoding {
    AV_MATRIX_ENCODING_NONE = 0,
    AV_MATRIX_ENCODING_DOLBY = 1,
    AV_MATRIX_ENCODING_DPLII = 2,
    AV_MATRIX_ENCODING_DPLIIX = 3,
    AV_MATRIX_ENCODING_DPLIIZ = 4,
    AV_MATRIX_ENCODING_DOLBYEX = 5,
    AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6,
    AV_MATRIX_ENCODING_NB = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVChannelCustom {
    pub id: AVChannel,
    pub name: [libc::c_char; 16usize],
    pub opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_AVChannelCustom() {
    assert_eq!(
        ::std::mem::size_of::<AVChannelCustom>(),
        32usize,
        concat!("Size of: ", stringify!(AVChannelCustom))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChannelCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChannelCustom))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChannelCustom>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelCustom),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChannelCustom>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelCustom),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChannelCustom>())).opaque as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelCustom),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVChannelLayout {
    pub order: AVChannelOrder,
    pub nb_channels: libc::c_int,
    pub u: AVChannelLayout__bindgen_ty_1,
    pub opaque: *mut libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVChannelLayout__bindgen_ty_1 {
    pub mask: u64,
    pub map: *mut AVChannelCustom,
}
#[test]
fn bindgen_test_layout_AVChannelLayout__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AVChannelLayout__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVChannelLayout__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChannelLayout__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChannelLayout__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVChannelLayout__bindgen_ty_1>())).mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout__bindgen_ty_1),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVChannelLayout__bindgen_ty_1>())).map as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
}
#[test]
fn bindgen_test_layout_AVChannelLayout() {
    assert_eq!(
        ::std::mem::size_of::<AVChannelLayout>(),
        24usize,
        concat!("Size of: ", stringify!(AVChannelLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChannelLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChannelLayout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChannelLayout>())).order as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChannelLayout>())).nb_channels as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(nb_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChannelLayout>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChannelLayout>())).opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(opaque)
        )
    );
}
extern "C" {
    pub fn av_get_channel_layout(name: *const libc::c_char) -> u64;
}
extern "C" {
    pub fn av_get_extended_channel_layout(
        name: *const libc::c_char,
        channel_layout: *mut u64,
        nb_channels: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_get_channel_layout_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        nb_channels: libc::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: libc::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> libc::c_int;
}
extern "C" {
    pub fn av_get_default_channel_layout(nb_channels: libc::c_int) -> i64;
}
extern "C" {
    pub fn av_get_channel_layout_channel_index(channel_layout: u64, channel: u64) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_extract_channel(channel_layout: u64, index: libc::c_int) -> u64;
}
extern "C" {
    pub fn av_get_channel_name(channel: u64) -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_channel_description(channel: u64) -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_standard_channel_layout(
        index: libc::c_uint,
        layout: *mut u64,
        name: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_name(
        buf: *mut libc::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_name_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    pub fn av_channel_description(
        buf: *mut libc::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_description_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    pub fn av_channel_from_string(name: *const libc::c_char) -> AVChannel;
}
extern "C" {
    pub fn av_channel_layout_from_mask(
        channel_layout: *mut AVChannelLayout,
        mask: u64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_from_string(
        channel_layout: *mut AVChannelLayout,
        str_: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_default(ch_layout: *mut AVChannelLayout, nb_channels: libc::c_int);
}
extern "C" {
    pub fn av_channel_layout_standard(opaque: *mut *mut libc::c_void) -> *const AVChannelLayout;
}
extern "C" {
    pub fn av_channel_layout_uninit(channel_layout: *mut AVChannelLayout);
}
extern "C" {
    pub fn av_channel_layout_copy(
        dst: *mut AVChannelLayout,
        src: *const AVChannelLayout,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_describe(
        channel_layout: *const AVChannelLayout,
        buf: *mut libc::c_char,
        buf_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_describe_bprint(
        channel_layout: *const AVChannelLayout,
        bp: *mut AVBPrint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_channel_from_index(
        channel_layout: *const AVChannelLayout,
        idx: libc::c_uint,
    ) -> AVChannel;
}
extern "C" {
    pub fn av_channel_layout_index_from_channel(
        channel_layout: *const AVChannelLayout,
        channel: AVChannel,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_index_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_channel_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const libc::c_char,
    ) -> AVChannel;
}
extern "C" {
    pub fn av_channel_layout_subset(channel_layout: *const AVChannelLayout, mask: u64) -> u64;
}
extern "C" {
    pub fn av_channel_layout_check(channel_layout: *const AVChannelLayout) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_compare(
        chl: *const AVChannelLayout,
        chl1: *const AVChannelLayout,
    ) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVFrameSideDataType {
    AV_FRAME_DATA_PANSCAN = 0,
    AV_FRAME_DATA_A53_CC = 1,
    AV_FRAME_DATA_STEREO3D = 2,
    AV_FRAME_DATA_MATRIXENCODING = 3,
    AV_FRAME_DATA_DOWNMIX_INFO = 4,
    AV_FRAME_DATA_REPLAYGAIN = 5,
    AV_FRAME_DATA_DISPLAYMATRIX = 6,
    AV_FRAME_DATA_AFD = 7,
    AV_FRAME_DATA_MOTION_VECTORS = 8,
    AV_FRAME_DATA_SKIP_SAMPLES = 9,
    AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10,
    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11,
    AV_FRAME_DATA_GOP_TIMECODE = 12,
    AV_FRAME_DATA_SPHERICAL = 13,
    AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14,
    AV_FRAME_DATA_ICC_PROFILE = 15,
    AV_FRAME_DATA_S12M_TIMECODE = 16,
    AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 17,
    AV_FRAME_DATA_REGIONS_OF_INTEREST = 18,
    AV_FRAME_DATA_VIDEO_ENC_PARAMS = 19,
    AV_FRAME_DATA_SEI_UNREGISTERED = 20,
    AV_FRAME_DATA_FILM_GRAIN_PARAMS = 21,
    AV_FRAME_DATA_DETECTION_BBOXES = 22,
    AV_FRAME_DATA_DOVI_RPU_BUFFER = 23,
    AV_FRAME_DATA_DOVI_METADATA = 24,
    AV_FRAME_DATA_DYNAMIC_HDR_VIVID = 25,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVActiveFormatDescription {
    AV_AFD_SAME = 8,
    AV_AFD_4_3 = 9,
    AV_AFD_16_9 = 10,
    AV_AFD_14_9 = 11,
    AV_AFD_4_3_SP_14_9 = 13,
    AV_AFD_16_9_SP_14_9 = 14,
    AV_AFD_SP_4_3 = 15,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: usize,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrameSideData() {
    assert_eq!(
        ::std::mem::size_of::<AVFrameSideData>(),
        40usize,
        concat!("Size of: ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrameSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).metadata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVRegionOfInterest {
    pub self_size: u32,
    pub top: libc::c_int,
    pub bottom: libc::c_int,
    pub left: libc::c_int,
    pub right: libc::c_int,
    pub qoffset: AVRational,
}
#[test]
fn bindgen_test_layout_AVRegionOfInterest() {
    assert_eq!(
        ::std::mem::size_of::<AVRegionOfInterest>(),
        28usize,
        concat!("Size of: ", stringify!(AVRegionOfInterest))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRegionOfInterest>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRegionOfInterest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).self_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(self_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).bottom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).left as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).right as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).qoffset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(qoffset)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFrame {
    pub data: [*mut u8; 8usize],
    pub linesize: [libc::c_int; 8usize],
    pub extended_data: *mut *mut u8,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub nb_samples: libc::c_int,
    pub format: libc::c_int,
    pub key_frame: libc::c_int,
    pub pict_type: AVPictureType,
    pub sample_aspect_ratio: AVRational,
    pub pts: i64,
    pub pkt_dts: i64,
    pub time_base: AVRational,
    pub coded_picture_number: libc::c_int,
    pub display_picture_number: libc::c_int,
    pub quality: libc::c_int,
    pub opaque: *mut libc::c_void,
    pub repeat_pict: libc::c_int,
    pub interlaced_frame: libc::c_int,
    pub top_field_first: libc::c_int,
    pub palette_has_changed: libc::c_int,
    pub reordered_opaque: i64,
    pub sample_rate: libc::c_int,
    pub channel_layout: u64,
    pub buf: [*mut AVBufferRef; 8usize],
    pub extended_buf: *mut *mut AVBufferRef,
    pub nb_extended_buf: libc::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: libc::c_int,
    pub flags: libc::c_int,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub best_effort_timestamp: i64,
    pub pkt_pos: i64,
    pub pkt_duration: i64,
    pub metadata: *mut AVDictionary,
    pub decode_error_flags: libc::c_int,
    pub channels: libc::c_int,
    pub pkt_size: libc::c_int,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub opaque_ref: *mut AVBufferRef,
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    pub private_ref: *mut AVBufferRef,
    pub ch_layout: AVChannelLayout,
}
#[test]
fn bindgen_test_layout_AVFrame() {
    assert_eq!(
        ::std::mem::size_of::<AVFrame>(),
        472usize,
        concat!("Size of: ", stringify!(AVFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).width as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).height as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_samples as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).format as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).key_frame as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pict_type as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_aspect_ratio as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pts as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_dts as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).time_base as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).coded_picture_number as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(coded_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).display_picture_number as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(display_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).quality as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).repeat_pict as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).interlaced_frame as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(interlaced_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).top_field_first as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).palette_has_changed as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(palette_has_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).reordered_opaque as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_rate as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).channel_layout as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).buf as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_buf as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_extended_buf as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).side_data as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_side_data as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).flags as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_range as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_primaries as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_trc as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).colorspace as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).chroma_location as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).best_effort_timestamp as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(best_effort_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_pos as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_duration as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).metadata as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).decode_error_flags as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(decode_error_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).channels as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_size as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).hw_frames_ctx as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque_ref as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_top as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_bottom as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_left as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_right as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).private_ref as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(private_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).ch_layout as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(ch_layout)
        )
    );
}
extern "C" {
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_get_buffer(frame: *mut AVFrame, align: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_get_plane_buffer(frame: *mut AVFrame, plane: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: usize,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_2 = _bindgen_ty_2::AV_FRAME_CROP_UNALIGNED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    AV_FRAME_CROP_UNALIGNED = 1,
}
extern "C" {
    pub fn av_frame_apply_cropping(frame: *mut AVFrame, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHWDeviceType {
    AV_HWDEVICE_TYPE_NONE = 0,
    AV_HWDEVICE_TYPE_VDPAU = 1,
    AV_HWDEVICE_TYPE_CUDA = 2,
    AV_HWDEVICE_TYPE_VAAPI = 3,
    AV_HWDEVICE_TYPE_DXVA2 = 4,
    AV_HWDEVICE_TYPE_QSV = 5,
    AV_HWDEVICE_TYPE_VIDEOTOOLBOX = 6,
    AV_HWDEVICE_TYPE_D3D11VA = 7,
    AV_HWDEVICE_TYPE_DRM = 8,
    AV_HWDEVICE_TYPE_OPENCL = 9,
    AV_HWDEVICE_TYPE_MEDIACODEC = 10,
    AV_HWDEVICE_TYPE_VULKAN = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceInternal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWDeviceContext {
    pub av_class: *const AVClass,
    pub internal: *mut AVHWDeviceInternal,
    pub type_: AVHWDeviceType,
    pub hwctx: *mut libc::c_void,
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWDeviceContext)>,
    pub user_opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_AVHWDeviceContext() {
    assert_eq!(
        ::std::mem::size_of::<AVHWDeviceContext>(),
        48usize,
        concat!("Size of: ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWDeviceContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).internal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).hwctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWDeviceContext>())).user_opaque as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(user_opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesInternal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWFramesContext {
    pub av_class: *const AVClass,
    pub internal: *mut AVHWFramesInternal,
    pub device_ref: *mut AVBufferRef,
    pub device_ctx: *mut AVHWDeviceContext,
    pub hwctx: *mut libc::c_void,
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWFramesContext)>,
    pub user_opaque: *mut libc::c_void,
    pub pool: *mut AVBufferPool,
    pub initial_pool_size: libc::c_int,
    pub format: AVPixelFormat,
    pub sw_format: AVPixelFormat,
    pub width: libc::c_int,
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesContext() {
    assert_eq!(
        ::std::mem::size_of::<AVHWFramesContext>(),
        88usize,
        concat!("Size of: ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWFramesContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).internal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).device_ref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).device_ctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).hwctx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).user_opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(user_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).pool as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesContext>())).initial_pool_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(initial_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).format as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).sw_format as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(sw_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).width as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesContext>())).height as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    pub fn av_hwdevice_find_type_by_name(name: *const libc::c_char) -> AVHWDeviceType;
}
extern "C" {
    pub fn av_hwdevice_get_type_name(type_: AVHWDeviceType) -> *const libc::c_char;
}
extern "C" {
    pub fn av_hwdevice_iterate_types(prev: AVHWDeviceType) -> AVHWDeviceType;
}
extern "C" {
    pub fn av_hwdevice_ctx_alloc(type_: AVHWDeviceType) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_hwdevice_ctx_init(ref_: *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create(
        device_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        device: *const libc::c_char,
        opts: *mut AVDictionary,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create_derived(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create_derived_opts(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        options: *mut AVDictionary,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_hwframe_ctx_alloc(device_ctx: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_hwframe_ctx_init(ref_: *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_hwframe_get_buffer(
        hwframe_ctx: *mut AVBufferRef,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_hwframe_transfer_data(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHWFrameTransferDirection {
    AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0,
    AV_HWFRAME_TRANSFER_DIRECTION_TO = 1,
}
extern "C" {
    pub fn av_hwframe_transfer_get_formats(
        hwframe_ctx: *mut AVBufferRef,
        dir: AVHWFrameTransferDirection,
        formats: *mut *mut AVPixelFormat,
        flags: libc::c_int,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWFramesConstraints {
    pub valid_hw_formats: *mut AVPixelFormat,
    pub valid_sw_formats: *mut AVPixelFormat,
    pub min_width: libc::c_int,
    pub min_height: libc::c_int,
    pub max_width: libc::c_int,
    pub max_height: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesConstraints() {
    assert_eq!(
        ::std::mem::size_of::<AVHWFramesConstraints>(),
        32usize,
        concat!("Size of: ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWFramesConstraints>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).valid_hw_formats as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_hw_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).valid_sw_formats as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_sw_formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesConstraints>())).min_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).min_height as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWFramesConstraints>())).max_width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVHWFramesConstraints>())).max_height as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_height)
        )
    );
}
extern "C" {
    pub fn av_hwdevice_hwconfig_alloc(device_ctx: *mut AVBufferRef) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_hwdevice_get_hwframe_constraints(
        ref_: *mut AVBufferRef,
        hwconfig: *const libc::c_void,
    ) -> *mut AVHWFramesConstraints;
}
extern "C" {
    pub fn av_hwframe_constraints_free(constraints: *mut *mut AVHWFramesConstraints);
}
pub const AV_HWFRAME_MAP_READ: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_READ;
pub const AV_HWFRAME_MAP_WRITE: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_WRITE;
pub const AV_HWFRAME_MAP_OVERWRITE: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_OVERWRITE;
pub const AV_HWFRAME_MAP_DIRECT: _bindgen_ty_3 = _bindgen_ty_3::AV_HWFRAME_MAP_DIRECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    AV_HWFRAME_MAP_READ = 1,
    AV_HWFRAME_MAP_WRITE = 2,
    AV_HWFRAME_MAP_OVERWRITE = 4,
    AV_HWFRAME_MAP_DIRECT = 8,
}
extern "C" {
    pub fn av_hwframe_map(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_hwframe_ctx_create_derived(
        derived_frame_ctx: *mut *mut AVBufferRef,
        format: AVPixelFormat,
        derived_device_ctx: *mut AVBufferRef,
        source_frame_ctx: *mut AVBufferRef,
        flags: libc::c_int,
    ) -> libc::c_int;
}
impl AVCodecID {
    pub const AV_CODEC_ID_FIRST_AUDIO: AVCodecID = AVCodecID::AV_CODEC_ID_PCM_S16LE;
}
impl AVCodecID {
    pub const AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = AVCodecID::AV_CODEC_ID_DVD_SUBTITLE;
}
impl AVCodecID {
    pub const AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = AVCodecID::AV_CODEC_ID_TTF;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVCodecID {
    AV_CODEC_ID_NONE = 0,
    AV_CODEC_ID_MPEG1VIDEO = 1,
    AV_CODEC_ID_MPEG2VIDEO = 2,
    AV_CODEC_ID_H261 = 3,
    AV_CODEC_ID_H263 = 4,
    AV_CODEC_ID_RV10 = 5,
    AV_CODEC_ID_RV20 = 6,
    AV_CODEC_ID_MJPEG = 7,
    AV_CODEC_ID_MJPEGB = 8,
    AV_CODEC_ID_LJPEG = 9,
    AV_CODEC_ID_SP5X = 10,
    AV_CODEC_ID_JPEGLS = 11,
    AV_CODEC_ID_MPEG4 = 12,
    AV_CODEC_ID_RAWVIDEO = 13,
    AV_CODEC_ID_MSMPEG4V1 = 14,
    AV_CODEC_ID_MSMPEG4V2 = 15,
    AV_CODEC_ID_MSMPEG4V3 = 16,
    AV_CODEC_ID_WMV1 = 17,
    AV_CODEC_ID_WMV2 = 18,
    AV_CODEC_ID_H263P = 19,
    AV_CODEC_ID_H263I = 20,
    AV_CODEC_ID_FLV1 = 21,
    AV_CODEC_ID_SVQ1 = 22,
    AV_CODEC_ID_SVQ3 = 23,
    AV_CODEC_ID_DVVIDEO = 24,
    AV_CODEC_ID_HUFFYUV = 25,
    AV_CODEC_ID_CYUV = 26,
    AV_CODEC_ID_H264 = 27,
    AV_CODEC_ID_INDEO3 = 28,
    AV_CODEC_ID_VP3 = 29,
    AV_CODEC_ID_THEORA = 30,
    AV_CODEC_ID_ASV1 = 31,
    AV_CODEC_ID_ASV2 = 32,
    AV_CODEC_ID_FFV1 = 33,
    AV_CODEC_ID_4XM = 34,
    AV_CODEC_ID_VCR1 = 35,
    AV_CODEC_ID_CLJR = 36,
    AV_CODEC_ID_MDEC = 37,
    AV_CODEC_ID_ROQ = 38,
    AV_CODEC_ID_INTERPLAY_VIDEO = 39,
    AV_CODEC_ID_XAN_WC3 = 40,
    AV_CODEC_ID_XAN_WC4 = 41,
    AV_CODEC_ID_RPZA = 42,
    AV_CODEC_ID_CINEPAK = 43,
    AV_CODEC_ID_WS_VQA = 44,
    AV_CODEC_ID_MSRLE = 45,
    AV_CODEC_ID_MSVIDEO1 = 46,
    AV_CODEC_ID_IDCIN = 47,
    AV_CODEC_ID_8BPS = 48,
    AV_CODEC_ID_SMC = 49,
    AV_CODEC_ID_FLIC = 50,
    AV_CODEC_ID_TRUEMOTION1 = 51,
    AV_CODEC_ID_VMDVIDEO = 52,
    AV_CODEC_ID_MSZH = 53,
    AV_CODEC_ID_ZLIB = 54,
    AV_CODEC_ID_QTRLE = 55,
    AV_CODEC_ID_TSCC = 56,
    AV_CODEC_ID_ULTI = 57,
    AV_CODEC_ID_QDRAW = 58,
    AV_CODEC_ID_VIXL = 59,
    AV_CODEC_ID_QPEG = 60,
    AV_CODEC_ID_PNG = 61,
    AV_CODEC_ID_PPM = 62,
    AV_CODEC_ID_PBM = 63,
    AV_CODEC_ID_PGM = 64,
    AV_CODEC_ID_PGMYUV = 65,
    AV_CODEC_ID_PAM = 66,
    AV_CODEC_ID_FFVHUFF = 67,
    AV_CODEC_ID_RV30 = 68,
    AV_CODEC_ID_RV40 = 69,
    AV_CODEC_ID_VC1 = 70,
    AV_CODEC_ID_WMV3 = 71,
    AV_CODEC_ID_LOCO = 72,
    AV_CODEC_ID_WNV1 = 73,
    AV_CODEC_ID_AASC = 74,
    AV_CODEC_ID_INDEO2 = 75,
    AV_CODEC_ID_FRAPS = 76,
    AV_CODEC_ID_TRUEMOTION2 = 77,
    AV_CODEC_ID_BMP = 78,
    AV_CODEC_ID_CSCD = 79,
    AV_CODEC_ID_MMVIDEO = 80,
    AV_CODEC_ID_ZMBV = 81,
    AV_CODEC_ID_AVS = 82,
    AV_CODEC_ID_SMACKVIDEO = 83,
    AV_CODEC_ID_NUV = 84,
    AV_CODEC_ID_KMVC = 85,
    AV_CODEC_ID_FLASHSV = 86,
    AV_CODEC_ID_CAVS = 87,
    AV_CODEC_ID_JPEG2000 = 88,
    AV_CODEC_ID_VMNC = 89,
    AV_CODEC_ID_VP5 = 90,
    AV_CODEC_ID_VP6 = 91,
    AV_CODEC_ID_VP6F = 92,
    AV_CODEC_ID_TARGA = 93,
    AV_CODEC_ID_DSICINVIDEO = 94,
    AV_CODEC_ID_TIERTEXSEQVIDEO = 95,
    AV_CODEC_ID_TIFF = 96,
    AV_CODEC_ID_GIF = 97,
    AV_CODEC_ID_DXA = 98,
    AV_CODEC_ID_DNXHD = 99,
    AV_CODEC_ID_THP = 100,
    AV_CODEC_ID_SGI = 101,
    AV_CODEC_ID_C93 = 102,
    AV_CODEC_ID_BETHSOFTVID = 103,
    AV_CODEC_ID_PTX = 104,
    AV_CODEC_ID_TXD = 105,
    AV_CODEC_ID_VP6A = 106,
    AV_CODEC_ID_AMV = 107,
    AV_CODEC_ID_VB = 108,
    AV_CODEC_ID_PCX = 109,
    AV_CODEC_ID_SUNRAST = 110,
    AV_CODEC_ID_INDEO4 = 111,
    AV_CODEC_ID_INDEO5 = 112,
    AV_CODEC_ID_MIMIC = 113,
    AV_CODEC_ID_RL2 = 114,
    AV_CODEC_ID_ESCAPE124 = 115,
    AV_CODEC_ID_DIRAC = 116,
    AV_CODEC_ID_BFI = 117,
    AV_CODEC_ID_CMV = 118,
    AV_CODEC_ID_MOTIONPIXELS = 119,
    AV_CODEC_ID_TGV = 120,
    AV_CODEC_ID_TGQ = 121,
    AV_CODEC_ID_TQI = 122,
    AV_CODEC_ID_AURA = 123,
    AV_CODEC_ID_AURA2 = 124,
    AV_CODEC_ID_V210X = 125,
    AV_CODEC_ID_TMV = 126,
    AV_CODEC_ID_V210 = 127,
    AV_CODEC_ID_DPX = 128,
    AV_CODEC_ID_MAD = 129,
    AV_CODEC_ID_FRWU = 130,
    AV_CODEC_ID_FLASHSV2 = 131,
    AV_CODEC_ID_CDGRAPHICS = 132,
    AV_CODEC_ID_R210 = 133,
    AV_CODEC_ID_ANM = 134,
    AV_CODEC_ID_BINKVIDEO = 135,
    AV_CODEC_ID_IFF_ILBM = 136,
    AV_CODEC_ID_KGV1 = 137,
    AV_CODEC_ID_YOP = 138,
    AV_CODEC_ID_VP8 = 139,
    AV_CODEC_ID_PICTOR = 140,
    AV_CODEC_ID_ANSI = 141,
    AV_CODEC_ID_A64_MULTI = 142,
    AV_CODEC_ID_A64_MULTI5 = 143,
    AV_CODEC_ID_R10K = 144,
    AV_CODEC_ID_MXPEG = 145,
    AV_CODEC_ID_LAGARITH = 146,
    AV_CODEC_ID_PRORES = 147,
    AV_CODEC_ID_JV = 148,
    AV_CODEC_ID_DFA = 149,
    AV_CODEC_ID_WMV3IMAGE = 150,
    AV_CODEC_ID_VC1IMAGE = 151,
    AV_CODEC_ID_UTVIDEO = 152,
    AV_CODEC_ID_BMV_VIDEO = 153,
    AV_CODEC_ID_VBLE = 154,
    AV_CODEC_ID_DXTORY = 155,
    AV_CODEC_ID_V410 = 156,
    AV_CODEC_ID_XWD = 157,
    AV_CODEC_ID_CDXL = 158,
    AV_CODEC_ID_XBM = 159,
    AV_CODEC_ID_ZEROCODEC = 160,
    AV_CODEC_ID_MSS1 = 161,
    AV_CODEC_ID_MSA1 = 162,
    AV_CODEC_ID_TSCC2 = 163,
    AV_CODEC_ID_MTS2 = 164,
    AV_CODEC_ID_CLLC = 165,
    AV_CODEC_ID_MSS2 = 166,
    AV_CODEC_ID_VP9 = 167,
    AV_CODEC_ID_AIC = 168,
    AV_CODEC_ID_ESCAPE130 = 169,
    AV_CODEC_ID_G2M = 170,
    AV_CODEC_ID_WEBP = 171,
    AV_CODEC_ID_HNM4_VIDEO = 172,
    AV_CODEC_ID_HEVC = 173,
    AV_CODEC_ID_FIC = 174,
    AV_CODEC_ID_ALIAS_PIX = 175,
    AV_CODEC_ID_BRENDER_PIX = 176,
    AV_CODEC_ID_PAF_VIDEO = 177,
    AV_CODEC_ID_EXR = 178,
    AV_CODEC_ID_VP7 = 179,
    AV_CODEC_ID_SANM = 180,
    AV_CODEC_ID_SGIRLE = 181,
    AV_CODEC_ID_MVC1 = 182,
    AV_CODEC_ID_MVC2 = 183,
    AV_CODEC_ID_HQX = 184,
    AV_CODEC_ID_TDSC = 185,
    AV_CODEC_ID_HQ_HQA = 186,
    AV_CODEC_ID_HAP = 187,
    AV_CODEC_ID_DDS = 188,
    AV_CODEC_ID_DXV = 189,
    AV_CODEC_ID_SCREENPRESSO = 190,
    AV_CODEC_ID_RSCC = 191,
    AV_CODEC_ID_AVS2 = 192,
    AV_CODEC_ID_PGX = 193,
    AV_CODEC_ID_AVS3 = 194,
    AV_CODEC_ID_MSP2 = 195,
    AV_CODEC_ID_VVC = 196,
    AV_CODEC_ID_Y41P = 197,
    AV_CODEC_ID_AVRP = 198,
    AV_CODEC_ID_012V = 199,
    AV_CODEC_ID_AVUI = 200,
    AV_CODEC_ID_AYUV = 201,
    AV_CODEC_ID_TARGA_Y216 = 202,
    AV_CODEC_ID_V308 = 203,
    AV_CODEC_ID_V408 = 204,
    AV_CODEC_ID_YUV4 = 205,
    AV_CODEC_ID_AVRN = 206,
    AV_CODEC_ID_CPIA = 207,
    AV_CODEC_ID_XFACE = 208,
    AV_CODEC_ID_SNOW = 209,
    AV_CODEC_ID_SMVJPEG = 210,
    AV_CODEC_ID_APNG = 211,
    AV_CODEC_ID_DAALA = 212,
    AV_CODEC_ID_CFHD = 213,
    AV_CODEC_ID_TRUEMOTION2RT = 214,
    AV_CODEC_ID_M101 = 215,
    AV_CODEC_ID_MAGICYUV = 216,
    AV_CODEC_ID_SHEERVIDEO = 217,
    AV_CODEC_ID_YLC = 218,
    AV_CODEC_ID_PSD = 219,
    AV_CODEC_ID_PIXLET = 220,
    AV_CODEC_ID_SPEEDHQ = 221,
    AV_CODEC_ID_FMVC = 222,
    AV_CODEC_ID_SCPR = 223,
    AV_CODEC_ID_CLEARVIDEO = 224,
    AV_CODEC_ID_XPM = 225,
    AV_CODEC_ID_AV1 = 226,
    AV_CODEC_ID_BITPACKED = 227,
    AV_CODEC_ID_MSCC = 228,
    AV_CODEC_ID_SRGC = 229,
    AV_CODEC_ID_SVG = 230,
    AV_CODEC_ID_GDV = 231,
    AV_CODEC_ID_FITS = 232,
    AV_CODEC_ID_IMM4 = 233,
    AV_CODEC_ID_PROSUMER = 234,
    AV_CODEC_ID_MWSC = 235,
    AV_CODEC_ID_WCMV = 236,
    AV_CODEC_ID_RASC = 237,
    AV_CODEC_ID_HYMT = 238,
    AV_CODEC_ID_ARBC = 239,
    AV_CODEC_ID_AGM = 240,
    AV_CODEC_ID_LSCR = 241,
    AV_CODEC_ID_VP4 = 242,
    AV_CODEC_ID_IMM5 = 243,
    AV_CODEC_ID_MVDV = 244,
    AV_CODEC_ID_MVHA = 245,
    AV_CODEC_ID_CDTOONS = 246,
    AV_CODEC_ID_MV30 = 247,
    AV_CODEC_ID_NOTCHLC = 248,
    AV_CODEC_ID_PFM = 249,
    AV_CODEC_ID_MOBICLIP = 250,
    AV_CODEC_ID_PHOTOCD = 251,
    AV_CODEC_ID_IPU = 252,
    AV_CODEC_ID_ARGO = 253,
    AV_CODEC_ID_CRI = 254,
    AV_CODEC_ID_SIMBIOSIS_IMX = 255,
    AV_CODEC_ID_SGA_VIDEO = 256,
    AV_CODEC_ID_GEM = 257,
    AV_CODEC_ID_VBN = 258,
    AV_CODEC_ID_JPEGXL = 259,
    AV_CODEC_ID_QOI = 260,
    AV_CODEC_ID_PHM = 261,
    AV_CODEC_ID_PCM_S16LE = 65536,
    AV_CODEC_ID_PCM_S16BE = 65537,
    AV_CODEC_ID_PCM_U16LE = 65538,
    AV_CODEC_ID_PCM_U16BE = 65539,
    AV_CODEC_ID_PCM_S8 = 65540,
    AV_CODEC_ID_PCM_U8 = 65541,
    AV_CODEC_ID_PCM_MULAW = 65542,
    AV_CODEC_ID_PCM_ALAW = 65543,
    AV_CODEC_ID_PCM_S32LE = 65544,
    AV_CODEC_ID_PCM_S32BE = 65545,
    AV_CODEC_ID_PCM_U32LE = 65546,
    AV_CODEC_ID_PCM_U32BE = 65547,
    AV_CODEC_ID_PCM_S24LE = 65548,
    AV_CODEC_ID_PCM_S24BE = 65549,
    AV_CODEC_ID_PCM_U24LE = 65550,
    AV_CODEC_ID_PCM_U24BE = 65551,
    AV_CODEC_ID_PCM_S24DAUD = 65552,
    AV_CODEC_ID_PCM_ZORK = 65553,
    AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
    AV_CODEC_ID_PCM_DVD = 65555,
    AV_CODEC_ID_PCM_F32BE = 65556,
    AV_CODEC_ID_PCM_F32LE = 65557,
    AV_CODEC_ID_PCM_F64BE = 65558,
    AV_CODEC_ID_PCM_F64LE = 65559,
    AV_CODEC_ID_PCM_BLURAY = 65560,
    AV_CODEC_ID_PCM_LXF = 65561,
    AV_CODEC_ID_S302M = 65562,
    AV_CODEC_ID_PCM_S8_PLANAR = 65563,
    AV_CODEC_ID_PCM_S24LE_PLANAR = 65564,
    AV_CODEC_ID_PCM_S32LE_PLANAR = 65565,
    AV_CODEC_ID_PCM_S16BE_PLANAR = 65566,
    AV_CODEC_ID_PCM_S64LE = 65567,
    AV_CODEC_ID_PCM_S64BE = 65568,
    AV_CODEC_ID_PCM_F16LE = 65569,
    AV_CODEC_ID_PCM_F24LE = 65570,
    AV_CODEC_ID_PCM_VIDC = 65571,
    AV_CODEC_ID_PCM_SGA = 65572,
    AV_CODEC_ID_ADPCM_IMA_QT = 69632,
    AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
    AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
    AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
    AV_CODEC_ID_ADPCM_IMA_WS = 69636,
    AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
    AV_CODEC_ID_ADPCM_MS = 69638,
    AV_CODEC_ID_ADPCM_4XM = 69639,
    AV_CODEC_ID_ADPCM_XA = 69640,
    AV_CODEC_ID_ADPCM_ADX = 69641,
    AV_CODEC_ID_ADPCM_EA = 69642,
    AV_CODEC_ID_ADPCM_G726 = 69643,
    AV_CODEC_ID_ADPCM_CT = 69644,
    AV_CODEC_ID_ADPCM_SWF = 69645,
    AV_CODEC_ID_ADPCM_YAMAHA = 69646,
    AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
    AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
    AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
    AV_CODEC_ID_ADPCM_THP = 69650,
    AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
    AV_CODEC_ID_ADPCM_EA_R1 = 69652,
    AV_CODEC_ID_ADPCM_EA_R3 = 69653,
    AV_CODEC_ID_ADPCM_EA_R2 = 69654,
    AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
    AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
    AV_CODEC_ID_ADPCM_EA_XAS = 69657,
    AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
    AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
    AV_CODEC_ID_ADPCM_G722 = 69660,
    AV_CODEC_ID_ADPCM_IMA_APC = 69661,
    AV_CODEC_ID_ADPCM_VIMA = 69662,
    AV_CODEC_ID_ADPCM_AFC = 69663,
    AV_CODEC_ID_ADPCM_IMA_OKI = 69664,
    AV_CODEC_ID_ADPCM_DTK = 69665,
    AV_CODEC_ID_ADPCM_IMA_RAD = 69666,
    AV_CODEC_ID_ADPCM_G726LE = 69667,
    AV_CODEC_ID_ADPCM_THP_LE = 69668,
    AV_CODEC_ID_ADPCM_PSX = 69669,
    AV_CODEC_ID_ADPCM_AICA = 69670,
    AV_CODEC_ID_ADPCM_IMA_DAT4 = 69671,
    AV_CODEC_ID_ADPCM_MTAF = 69672,
    AV_CODEC_ID_ADPCM_AGM = 69673,
    AV_CODEC_ID_ADPCM_ARGO = 69674,
    AV_CODEC_ID_ADPCM_IMA_SSI = 69675,
    AV_CODEC_ID_ADPCM_ZORK = 69676,
    AV_CODEC_ID_ADPCM_IMA_APM = 69677,
    AV_CODEC_ID_ADPCM_IMA_ALP = 69678,
    AV_CODEC_ID_ADPCM_IMA_MTF = 69679,
    AV_CODEC_ID_ADPCM_IMA_CUNNING = 69680,
    AV_CODEC_ID_ADPCM_IMA_MOFLEX = 69681,
    AV_CODEC_ID_ADPCM_IMA_ACORN = 69682,
    AV_CODEC_ID_AMR_NB = 73728,
    AV_CODEC_ID_AMR_WB = 73729,
    AV_CODEC_ID_RA_144 = 77824,
    AV_CODEC_ID_RA_288 = 77825,
    AV_CODEC_ID_ROQ_DPCM = 81920,
    AV_CODEC_ID_INTERPLAY_DPCM = 81921,
    AV_CODEC_ID_XAN_DPCM = 81922,
    AV_CODEC_ID_SOL_DPCM = 81923,
    AV_CODEC_ID_SDX2_DPCM = 81924,
    AV_CODEC_ID_GREMLIN_DPCM = 81925,
    AV_CODEC_ID_DERF_DPCM = 81926,
    AV_CODEC_ID_MP2 = 86016,
    AV_CODEC_ID_MP3 = 86017,
    AV_CODEC_ID_AAC = 86018,
    AV_CODEC_ID_AC3 = 86019,
    AV_CODEC_ID_DTS = 86020,
    AV_CODEC_ID_VORBIS = 86021,
    AV_CODEC_ID_DVAUDIO = 86022,
    AV_CODEC_ID_WMAV1 = 86023,
    AV_CODEC_ID_WMAV2 = 86024,
    AV_CODEC_ID_MACE3 = 86025,
    AV_CODEC_ID_MACE6 = 86026,
    AV_CODEC_ID_VMDAUDIO = 86027,
    AV_CODEC_ID_FLAC = 86028,
    AV_CODEC_ID_MP3ADU = 86029,
    AV_CODEC_ID_MP3ON4 = 86030,
    AV_CODEC_ID_SHORTEN = 86031,
    AV_CODEC_ID_ALAC = 86032,
    AV_CODEC_ID_WESTWOOD_SND1 = 86033,
    AV_CODEC_ID_GSM = 86034,
    AV_CODEC_ID_QDM2 = 86035,
    AV_CODEC_ID_COOK = 86036,
    AV_CODEC_ID_TRUESPEECH = 86037,
    AV_CODEC_ID_TTA = 86038,
    AV_CODEC_ID_SMACKAUDIO = 86039,
    AV_CODEC_ID_QCELP = 86040,
    AV_CODEC_ID_WAVPACK = 86041,
    AV_CODEC_ID_DSICINAUDIO = 86042,
    AV_CODEC_ID_IMC = 86043,
    AV_CODEC_ID_MUSEPACK7 = 86044,
    AV_CODEC_ID_MLP = 86045,
    AV_CODEC_ID_GSM_MS = 86046,
    AV_CODEC_ID_ATRAC3 = 86047,
    AV_CODEC_ID_APE = 86048,
    AV_CODEC_ID_NELLYMOSER = 86049,
    AV_CODEC_ID_MUSEPACK8 = 86050,
    AV_CODEC_ID_SPEEX = 86051,
    AV_CODEC_ID_WMAVOICE = 86052,
    AV_CODEC_ID_WMAPRO = 86053,
    AV_CODEC_ID_WMALOSSLESS = 86054,
    AV_CODEC_ID_ATRAC3P = 86055,
    AV_CODEC_ID_EAC3 = 86056,
    AV_CODEC_ID_SIPR = 86057,
    AV_CODEC_ID_MP1 = 86058,
    AV_CODEC_ID_TWINVQ = 86059,
    AV_CODEC_ID_TRUEHD = 86060,
    AV_CODEC_ID_MP4ALS = 86061,
    AV_CODEC_ID_ATRAC1 = 86062,
    AV_CODEC_ID_BINKAUDIO_RDFT = 86063,
    AV_CODEC_ID_BINKAUDIO_DCT = 86064,
    AV_CODEC_ID_AAC_LATM = 86065,
    AV_CODEC_ID_QDMC = 86066,
    AV_CODEC_ID_CELT = 86067,
    AV_CODEC_ID_G723_1 = 86068,
    AV_CODEC_ID_G729 = 86069,
    AV_CODEC_ID_8SVX_EXP = 86070,
    AV_CODEC_ID_8SVX_FIB = 86071,
    AV_CODEC_ID_BMV_AUDIO = 86072,
    AV_CODEC_ID_RALF = 86073,
    AV_CODEC_ID_IAC = 86074,
    AV_CODEC_ID_ILBC = 86075,
    AV_CODEC_ID_OPUS = 86076,
    AV_CODEC_ID_COMFORT_NOISE = 86077,
    AV_CODEC_ID_TAK = 86078,
    AV_CODEC_ID_METASOUND = 86079,
    AV_CODEC_ID_PAF_AUDIO = 86080,
    AV_CODEC_ID_ON2AVC = 86081,
    AV_CODEC_ID_DSS_SP = 86082,
    AV_CODEC_ID_CODEC2 = 86083,
    AV_CODEC_ID_FFWAVESYNTH = 86084,
    AV_CODEC_ID_SONIC = 86085,
    AV_CODEC_ID_SONIC_LS = 86086,
    AV_CODEC_ID_EVRC = 86087,
    AV_CODEC_ID_SMV = 86088,
    AV_CODEC_ID_DSD_LSBF = 86089,
    AV_CODEC_ID_DSD_MSBF = 86090,
    AV_CODEC_ID_DSD_LSBF_PLANAR = 86091,
    AV_CODEC_ID_DSD_MSBF_PLANAR = 86092,
    AV_CODEC_ID_4GV = 86093,
    AV_CODEC_ID_INTERPLAY_ACM = 86094,
    AV_CODEC_ID_XMA1 = 86095,
    AV_CODEC_ID_XMA2 = 86096,
    AV_CODEC_ID_DST = 86097,
    AV_CODEC_ID_ATRAC3AL = 86098,
    AV_CODEC_ID_ATRAC3PAL = 86099,
    AV_CODEC_ID_DOLBY_E = 86100,
    AV_CODEC_ID_APTX = 86101,
    AV_CODEC_ID_APTX_HD = 86102,
    AV_CODEC_ID_SBC = 86103,
    AV_CODEC_ID_ATRAC9 = 86104,
    AV_CODEC_ID_HCOM = 86105,
    AV_CODEC_ID_ACELP_KELVIN = 86106,
    AV_CODEC_ID_MPEGH_3D_AUDIO = 86107,
    AV_CODEC_ID_SIREN = 86108,
    AV_CODEC_ID_HCA = 86109,
    AV_CODEC_ID_FASTAUDIO = 86110,
    AV_CODEC_ID_MSNSIREN = 86111,
    AV_CODEC_ID_DFPWM = 86112,
    AV_CODEC_ID_DVD_SUBTITLE = 94208,
    AV_CODEC_ID_DVB_SUBTITLE = 94209,
    AV_CODEC_ID_TEXT = 94210,
    AV_CODEC_ID_XSUB = 94211,
    AV_CODEC_ID_SSA = 94212,
    AV_CODEC_ID_MOV_TEXT = 94213,
    AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
    AV_CODEC_ID_DVB_TELETEXT = 94215,
    AV_CODEC_ID_SRT = 94216,
    AV_CODEC_ID_MICRODVD = 94217,
    AV_CODEC_ID_EIA_608 = 94218,
    AV_CODEC_ID_JACOSUB = 94219,
    AV_CODEC_ID_SAMI = 94220,
    AV_CODEC_ID_REALTEXT = 94221,
    AV_CODEC_ID_STL = 94222,
    AV_CODEC_ID_SUBVIEWER1 = 94223,
    AV_CODEC_ID_SUBVIEWER = 94224,
    AV_CODEC_ID_SUBRIP = 94225,
    AV_CODEC_ID_WEBVTT = 94226,
    AV_CODEC_ID_MPL2 = 94227,
    AV_CODEC_ID_VPLAYER = 94228,
    AV_CODEC_ID_PJS = 94229,
    AV_CODEC_ID_ASS = 94230,
    AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 94231,
    AV_CODEC_ID_TTML = 94232,
    AV_CODEC_ID_ARIB_CAPTION = 94233,
    AV_CODEC_ID_TTF = 98304,
    AV_CODEC_ID_SCTE_35 = 98305,
    AV_CODEC_ID_EPG = 98306,
    AV_CODEC_ID_BINTEXT = 98307,
    AV_CODEC_ID_XBIN = 98308,
    AV_CODEC_ID_IDF = 98309,
    AV_CODEC_ID_OTF = 98310,
    AV_CODEC_ID_SMPTE_KLV = 98311,
    AV_CODEC_ID_DVD_NAV = 98312,
    AV_CODEC_ID_TIMED_ID3 = 98313,
    AV_CODEC_ID_BIN_DATA = 98314,
    AV_CODEC_ID_PROBE = 102400,
    AV_CODEC_ID_MPEG2TS = 131072,
    AV_CODEC_ID_MPEG4SYSTEMS = 131073,
    AV_CODEC_ID_FFMETADATA = 135168,
    AV_CODEC_ID_WRAPPED_AVFRAME = 135169,
}
extern "C" {
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    pub fn avcodec_get_name(id: AVCodecID) -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    pub fn avcodec_profile_name(codec_id: AVCodecID, profile: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: libc::c_int) -> AVCodecID;
}
#[doc = " AVProfile."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProfile {
    pub profile: libc::c_int,
    #[doc = "< short name for the profile"]
    pub name: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVProfile() {
    assert_eq!(
        ::std::mem::size_of::<AVProfile>(),
        16usize,
        concat!("Size of: ", stringify!(AVProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProfile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProfile>())).profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProfile>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " AVCodec."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodec {
    #[doc = " Name of the codec implementation."]
    #[doc = " The name is globally unique among encoders and among decoders (but an"]
    #[doc = " encoder and a decoder can share the same name)."]
    #[doc = " This is the primary way to find a codec from the user perspective."]
    pub name: *const libc::c_char,
    #[doc = " Descriptive name for the codec, meant to be more human readable than name."]
    #[doc = " You should use the NULL_IF_CONFIG_SMALL() macro to define it."]
    pub long_name: *const libc::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    #[doc = " Codec capabilities."]
    #[doc = " see AV_CODEC_CAP_*"]
    pub capabilities: libc::c_int,
    #[doc = "< maximum value for lowres supported by the decoder"]
    pub max_lowres: u8,
    #[doc = "< array of supported framerates, or NULL if any, array is terminated by {0,0}"]
    pub supported_framerates: *const AVRational,
    #[doc = "< array of supported pixel formats, or NULL if unknown, array is terminated by -1"]
    pub pix_fmts: *const AVPixelFormat,
    #[doc = "< array of supported audio samplerates, or NULL if unknown, array is terminated by 0"]
    pub supported_samplerates: *const libc::c_int,
    #[doc = "< array of supported sample formats, or NULL if unknown, array is terminated by -1"]
    pub sample_fmts: *const AVSampleFormat,
    #[doc = "< array of support channel layouts, or NULL if unknown. array is terminated by 0"]
    pub channel_layouts: *const u64,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = "< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}"]
    pub profiles: *const AVProfile,
    #[doc = " Group name of the codec implementation."]
    #[doc = " This is a short symbolic name of the wrapper backing this codec. A"]
    #[doc = " wrapper uses some kind of external implementation for the codec, such"]
    #[doc = " as an external library, or a codec implementation provided by the OS or"]
    #[doc = " the hardware."]
    #[doc = " If this field is NULL, this is a builtin, libavcodec native codec."]
    #[doc = " If non-NULL, this will be the suffix in AVCodec.name in most cases"]
    #[doc = " (usually AVCodec.name will be of the form \"<codec_name>_<wrapper_name>\")."]
    pub wrapper_name: *const libc::c_char,
    #[doc = " Array of supported channel layouts, terminated with a zeroed layout."]
    pub ch_layouts: *const AVChannelLayout,
}
#[test]
fn bindgen_test_layout_AVCodec() {
    assert_eq!(
        ::std::mem::size_of::<AVCodec>(),
        104usize,
        concat!("Size of: ", stringify!(AVCodec))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).capabilities as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).max_lowres as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(max_lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).supported_framerates as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_framerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).pix_fmts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(pix_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).supported_samplerates as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_samplerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).sample_fmts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(sample_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).channel_layouts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(channel_layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).priv_class as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).profiles as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(profiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).wrapper_name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(wrapper_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).ch_layouts as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(ch_layouts)
        )
    );
}
extern "C" {
    #[doc = " Iterate over all registered codecs."]
    #[doc = ""]
    #[doc = " @param opaque a pointer where libavcodec will store the iteration state. Must"]
    #[doc = "               point to NULL to start the iteration."]
    #[doc = ""]
    #[doc = " @return the next registered codec or NULL when the iteration is"]
    #[doc = "         finished"]
    pub fn av_codec_iterate(opaque: *mut *mut libc::c_void) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with a matching codec ID."]
    #[doc = ""]
    #[doc = " @param id AVCodecID of the requested decoder"]
    #[doc = " @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder(id: AVCodecID) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with the specified name."]
    #[doc = ""]
    #[doc = " @param name name of the requested decoder"]
    #[doc = " @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder_by_name(name: *const libc::c_char) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with a matching codec ID."]
    #[doc = ""]
    #[doc = " @param id AVCodecID of the requested encoder"]
    #[doc = " @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder(id: AVCodecID) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with the specified name."]
    #[doc = ""]
    #[doc = " @param name name of the requested encoder"]
    #[doc = " @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder_by_name(name: *const libc::c_char) -> *const AVCodec;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is an encoder, zero otherwise"]
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> libc::c_int;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is a decoder, zero otherwise"]
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a name for the specified profile, if available."]
    #[doc = ""]
    #[doc = " @param codec the codec that is searched for the given profile"]
    #[doc = " @param profile the profile value for which a name is requested"]
    #[doc = " @return A name for the profile if found, NULL otherwise."]
    pub fn av_get_profile_name(codec: *const AVCodec, profile: libc::c_int) -> *const libc::c_char;
}
pub const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX;
pub const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX;
pub const AV_CODEC_HW_CONFIG_METHOD_INTERNAL: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_INTERNAL;
pub const AV_CODEC_HW_CONFIG_METHOD_AD_HOC: _bindgen_ty_4 =
    _bindgen_ty_4::AV_CODEC_HW_CONFIG_METHOD_AD_HOC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    #[doc = " The codec supports this format via the hw_device_ctx interface."]
    #[doc = ""]
    #[doc = " When selecting this format, AVCodecContext.hw_device_ctx should"]
    #[doc = " have been set to a device of the specified type before calling"]
    #[doc = " avcodec_open2()."]
    AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1,
    #[doc = " The codec supports this format via the hw_frames_ctx interface."]
    #[doc = ""]
    #[doc = " When selecting this format for a decoder,"]
    #[doc = " AVCodecContext.hw_frames_ctx should be set to a suitable frames"]
    #[doc = " context inside the get_format() callback.  The frames context"]
    #[doc = " must have been created on a device of the specified type."]
    #[doc = ""]
    #[doc = " When selecting this format for an encoder,"]
    #[doc = " AVCodecContext.hw_frames_ctx should be set to the context which"]
    #[doc = " will be used for the input frames before calling avcodec_open2()."]
    AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2,
    #[doc = " The codec supports this format by some internal method."]
    #[doc = ""]
    #[doc = " This format can be selected without any additional configuration -"]
    #[doc = " no device or frames context is required."]
    AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4,
    #[doc = " The codec supports this format by some ad-hoc method."]
    #[doc = ""]
    #[doc = " Additional settings and/or function calls are required.  See the"]
    #[doc = " codec-specific documentation for details.  (Methods requiring"]
    #[doc = " this sort of configuration are deprecated and others should be"]
    #[doc = " used in preference.)"]
    AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecHWConfig {
    #[doc = " For decoders, a hardware pixel format which that decoder may be"]
    #[doc = " able to decode to if suitable hardware is available."]
    #[doc = ""]
    #[doc = " For encoders, a pixel format which the encoder may be able to"]
    #[doc = " accept.  If set to AV_PIX_FMT_NONE, this applies to all pixel"]
    #[doc = " formats supported by the codec."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible"]
    #[doc = " setup methods which can be used with this configuration."]
    pub methods: libc::c_int,
    #[doc = " The device type associated with the configuration."]
    #[doc = ""]
    #[doc = " Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and"]
    #[doc = " AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused."]
    pub device_type: AVHWDeviceType,
}
#[test]
fn bindgen_test_layout_AVCodecHWConfig() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecHWConfig>(),
        12usize,
        concat!("Size of: ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecHWConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecHWConfig>())).pix_fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecHWConfig>())).methods as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecHWConfig>())).device_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(device_type)
        )
    );
}
extern "C" {
    #[doc = " Retrieve supported hardware configurations for a codec."]
    #[doc = ""]
    #[doc = " Values of index from zero to some maximum return the indexed configuration"]
    #[doc = " descriptor; all other values return NULL.  If the codec does not support"]
    #[doc = " any hardware configurations then it will always return NULL."]
    pub fn avcodec_get_hw_config(
        codec: *const AVCodec,
        index: libc::c_int,
    ) -> *const AVCodecHWConfig;
}
#[doc = " This struct describes the properties of a single codec described by an"]
#[doc = " AVCodecID."]
#[doc = " @see avcodec_descriptor_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    #[doc = " Name of the codec described by this descriptor. It is non-empty and"]
    #[doc = " unique for each codec descriptor. It should contain alphanumeric"]
    #[doc = " characters and '_' only."]
    pub name: *const libc::c_char,
    #[doc = " A more descriptive name for this codec. May be NULL."]
    pub long_name: *const libc::c_char,
    #[doc = " Codec properties, a combination of AV_CODEC_PROP_* flags."]
    pub props: libc::c_int,
    #[doc = " MIME type(s) associated with the codec."]
    #[doc = " May be NULL; if not, a NULL-terminated array of MIME types."]
    #[doc = " The first item is always non-NULL and is the preferred MIME type."]
    pub mime_types: *const *const libc::c_char,
    #[doc = " If non-NULL, an array of profiles recognized for this codec."]
    #[doc = " Terminated with FF_PROFILE_UNKNOWN."]
    pub profiles: *const AVProfile,
}
#[test]
fn bindgen_test_layout_AVCodecDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecDescriptor>(),
        48usize,
        concat!("Size of: ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).long_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).props as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).mime_types as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(mime_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).profiles as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(profiles)
        )
    );
}
extern "C" {
    #[doc = " @return descriptor for given codec ID or NULL if no descriptor exists."]
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " Iterate over all codec descriptors known to libavcodec."]
    #[doc = ""]
    #[doc = " @param prev previous descriptor. NULL to get the first descriptor."]
    #[doc = ""]
    #[doc = " @return next descriptor or NULL after the last descriptor"]
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " @return codec descriptor with the given name or NULL if no such descriptor"]
    #[doc = "         exists."]
    pub fn avcodec_descriptor_get_by_name(name: *const libc::c_char) -> *const AVCodecDescriptor;
}
#[repr(u32)]
#[doc = " @addtogroup lavc_core"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVFieldOrder {
    AV_FIELD_UNKNOWN = 0,
    AV_FIELD_PROGRESSIVE = 1,
    AV_FIELD_TT = 2,
    AV_FIELD_BB = 3,
    AV_FIELD_TB = 4,
    AV_FIELD_BT = 5,
}
#[doc = " This struct describes the properties of an encoded stream."]
#[doc = ""]
#[doc = " sizeof(AVCodecParameters) is not a part of the public ABI, this struct must"]
#[doc = " be allocated with avcodec_parameters_alloc() and freed with"]
#[doc = " avcodec_parameters_free()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVCodecParameters {
    #[doc = " General type of the encoded data."]
    pub codec_type: AVMediaType,
    #[doc = " Specific type of the encoded data (the codec used)."]
    pub codec_id: AVCodecID,
    #[doc = " Additional information about the codec (corresponds to the AVI FOURCC)."]
    pub codec_tag: u32,
    #[doc = " Extra binary data needed for initializing the decoder, codec-dependent."]
    #[doc = ""]
    #[doc = " Must be allocated with av_malloc() and will be freed by"]
    #[doc = " avcodec_parameters_free(). The allocated size of extradata must be at"]
    #[doc = " least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding"]
    #[doc = " bytes zeroed."]
    pub extradata: *mut u8,
    #[doc = " Size of the extradata content in bytes."]
    pub extradata_size: libc::c_int,
    #[doc = " - video: the pixel format, the value corresponds to enum AVPixelFormat."]
    #[doc = " - audio: the sample format, the value corresponds to enum AVSampleFormat."]
    pub format: libc::c_int,
    #[doc = " The average bitrate of the encoded data (in bits per second)."]
    pub bit_rate: i64,
    #[doc = " The number of bits per sample in the codedwords."]
    #[doc = ""]
    #[doc = " This is basically the bitrate per sample. It is mandatory for a bunch of"]
    #[doc = " formats to actually decode them. It's the number of bits for one sample in"]
    #[doc = " the actual coded bitstream."]
    #[doc = ""]
    #[doc = " This could be for example 4 for ADPCM"]
    #[doc = " For PCM formats this matches bits_per_raw_sample"]
    #[doc = " Can be 0"]
    pub bits_per_coded_sample: libc::c_int,
    #[doc = " This is the number of valid bits in each output sample. If the"]
    #[doc = " sample format has more bits, the least significant bits are additional"]
    #[doc = " padding bits, which are always 0. Use right shifts to reduce the sample"]
    #[doc = " to its actual size. For example, audio formats with 24 bit samples will"]
    #[doc = " have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32."]
    #[doc = " To get the original sample use \"(int32_t)sample >> 8\".\""]
    #[doc = ""]
    #[doc = " For ADPCM this might be 12 or 16 or similar"]
    #[doc = " Can be 0"]
    pub bits_per_raw_sample: libc::c_int,
    #[doc = " Codec-specific bitstream restrictions that the stream conforms to."]
    pub profile: libc::c_int,
    pub level: libc::c_int,
    #[doc = " Video only. The dimensions of the video frame in pixels."]
    pub width: libc::c_int,
    pub height: libc::c_int,
    #[doc = " Video only. The aspect ratio (width / height) which a single pixel"]
    #[doc = " should have when displayed."]
    #[doc = ""]
    #[doc = " When the aspect ratio is unknown / undefined, the numerator should be"]
    #[doc = " set to 0 (the denominator may have any value)."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Video only. The order of the fields in interlaced video."]
    pub field_order: AVFieldOrder,
    #[doc = " Video only. Additional colorspace characteristics."]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " Video only. Number of delayed frames."]
    pub video_delay: libc::c_int,
    #[doc = " Audio only. The channel layout bitmask. May be 0 if the channel layout is"]
    #[doc = " unknown or unspecified, otherwise the number of bits set must be equal to"]
    #[doc = " the channels field."]
    #[doc = " @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Audio only. The number of audio channels."]
    #[doc = " @deprecated use ch_layout.nb_channels"]
    pub channels: libc::c_int,
    #[doc = " Audio only. The number of audio samples per second."]
    pub sample_rate: libc::c_int,
    #[doc = " Audio only. The number of bytes per coded audio frame, required by some"]
    #[doc = " formats."]
    #[doc = ""]
    #[doc = " Corresponds to nBlockAlign in WAVEFORMATEX."]
    pub block_align: libc::c_int,
    #[doc = " Audio only. Audio frame size, if known. Required by some formats to be static."]
    pub frame_size: libc::c_int,
    #[doc = " Audio only. The amount of padding (in samples) inserted by the encoder at"]
    #[doc = " the beginning of the audio. I.e. this number of leading decoded samples"]
    #[doc = " must be discarded by the caller to get the original audio without leading"]
    #[doc = " padding."]
    pub initial_padding: libc::c_int,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to"]
    #[doc = " the end of the audio. I.e. this number of decoded samples must be"]
    #[doc = " discarded by the caller from the end of the stream to get the original"]
    #[doc = " audio without any trailing padding."]
    pub trailing_padding: libc::c_int,
    #[doc = " Audio only. Number of samples to skip after a discontinuity."]
    pub seek_preroll: libc::c_int,
    #[doc = " Audio only. The channel layout and number of channels."]
    pub ch_layout: AVChannelLayout,
}
#[test]
fn bindgen_test_layout_AVCodecParameters() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParameters>(),
        168usize,
        concat!("Size of: ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).extradata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).extradata_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).format as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).bit_rate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).bits_per_coded_sample as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).bits_per_raw_sample as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).profile as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).level as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).sample_aspect_ratio as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).field_order as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_range as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).color_primaries as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_trc as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_space as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).chroma_location as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).video_delay as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(video_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).channel_layout as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).channels as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).sample_rate as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).block_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).frame_size as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).initial_padding as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).trailing_padding as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).seek_preroll as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(seek_preroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).ch_layout as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(ch_layout)
        )
    );
}
extern "C" {
    #[doc = " Allocate a new AVCodecParameters and set its fields to default values"]
    #[doc = " (unknown/invalid/0). The returned struct must be freed with"]
    #[doc = " avcodec_parameters_free()."]
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    #[doc = " Free an AVCodecParameters instance and everything associated with it and"]
    #[doc = " write NULL to the supplied pointer."]
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    #[doc = " Copy the contents of src to dst. Any allocated fields in dst are freed and"]
    #[doc = " replaced with newly allocated duplicates of the corresponding fields in src."]
    #[doc = ""]
    #[doc = " @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " This function is the same as av_get_audio_frame_duration(), except it works"]
    #[doc = " with AVCodecParameters instead of an AVCodecContext."]
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: libc::c_int,
    ) -> libc::c_int;
}
#[repr(i32)]
#[doc = " @ingroup lavc_decoding"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDiscard {
    #[doc = "< discard nothing"]
    AVDISCARD_NONE = -16,
    #[doc = "< discard useless packets like 0 size packets in avi"]
    AVDISCARD_DEFAULT = 0,
    #[doc = "< discard all non reference"]
    AVDISCARD_NONREF = 8,
    #[doc = "< discard all bidirectional frames"]
    AVDISCARD_BIDIR = 16,
    #[doc = "< discard all non intra frames"]
    AVDISCARD_NONINTRA = 24,
    #[doc = "< discard all frames except keyframes"]
    AVDISCARD_NONKEY = 32,
    #[doc = "< discard all"]
    AVDISCARD_ALL = 48,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVAudioServiceType {
    AV_AUDIO_SERVICE_TYPE_MAIN = 0,
    AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
    AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
    AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
    AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
    AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
    AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
    #[doc = "< Not part of ABI"]
    AV_AUDIO_SERVICE_TYPE_NB = 9,
}
#[doc = " Pan Scan area."]
#[doc = " This specifies the area which should be displayed."]
#[doc = " Note there may be multiple such areas for one frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPanScan {
    #[doc = " id"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub id: libc::c_int,
    #[doc = " width and height in 1/16 pel"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub width: libc::c_int,
    pub height: libc::c_int,
    #[doc = " position of the top left corner in 1/16 pel for up to 3 fields/frames"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub position: [[i16; 2usize]; 3usize],
}
#[test]
fn bindgen_test_layout_AVPanScan() {
    assert_eq!(
        ::std::mem::size_of::<AVPanScan>(),
        24usize,
        concat!("Size of: ", stringify!(AVPanScan))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPanScan>(),
        4usize,
        concat!("Alignment of ", stringify!(AVPanScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).position as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(position)
        )
    );
}
#[doc = " This structure describes the bitrate properties of an encoded bitstream. It"]
#[doc = " roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD"]
#[doc = " parameters for H.264/HEVC."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCPBProperties {
    #[doc = " Maximum bitrate of the stream, in bits per second."]
    #[doc = " Zero if unknown or unspecified."]
    pub max_bitrate: i64,
    #[doc = " Minimum bitrate of the stream, in bits per second."]
    #[doc = " Zero if unknown or unspecified."]
    pub min_bitrate: i64,
    #[doc = " Average bitrate of the stream, in bits per second."]
    #[doc = " Zero if unknown or unspecified."]
    pub avg_bitrate: i64,
    #[doc = " The size of the buffer to which the ratecontrol is applied, in bits."]
    #[doc = " Zero if unknown or unspecified."]
    pub buffer_size: i64,
    #[doc = " The delay between the time the packet this structure is associated with"]
    #[doc = " is received and the time when it should be decoded, in periods of a 27MHz"]
    #[doc = " clock."]
    #[doc = ""]
    #[doc = " UINT64_MAX when unknown or unspecified."]
    pub vbv_delay: u64,
}
#[test]
fn bindgen_test_layout_AVCPBProperties() {
    assert_eq!(
        ::std::mem::size_of::<AVCPBProperties>(),
        40usize,
        concat!("Size of: ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCPBProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).max_bitrate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(max_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).min_bitrate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(min_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).avg_bitrate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(avg_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).buffer_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).vbv_delay as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(vbv_delay)
        )
    );
}
extern "C" {
    #[doc = " Allocate a CPB properties structure and initialize its fields to default"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = " @param size if non-NULL, the size of the allocated struct will be written"]
    #[doc = "             here. This is useful for embedding it in side data."]
    #[doc = ""]
    #[doc = " @return the newly allocated struct or NULL on failure"]
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[doc = " This structure supplies correlation between a packet timestamp and a wall clock"]
#[doc = " production time. The definition follows the Producer Reference Time ('prft')"]
#[doc = " as defined in ISO/IEC 14496-12"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProducerReferenceTime {
    #[doc = " A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime())."]
    pub wallclock: i64,
    pub flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVProducerReferenceTime() {
    assert_eq!(
        ::std::mem::size_of::<AVProducerReferenceTime>(),
        16usize,
        concat!("Size of: ", stringify!(AVProducerReferenceTime))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProducerReferenceTime>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProducerReferenceTime))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVProducerReferenceTime>())).wallclock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProducerReferenceTime),
            "::",
            stringify!(wallclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProducerReferenceTime>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProducerReferenceTime),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Encode extradata length to a buffer. Used by xiph codecs."]
    #[doc = ""]
    #[doc = " @param s buffer to write to; must be at least (v/255+1) bytes long"]
    #[doc = " @param v size of extradata in bytes"]
    #[doc = " @return number of bytes written to the buffer."]
    pub fn av_xiphlacing(s: *mut libc::c_uchar, v: libc::c_uint) -> libc::c_uint;
}
#[repr(u32)]
#[doc = " @defgroup lavc_packet AVPacket"]
#[doc = ""]
#[doc = " Types and functions for working with AVPacket."]
#[doc = " @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPacketSideDataType {
    #[doc = " An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE"]
    #[doc = " bytes worth of palette. This side data signals that a new palette is"]
    #[doc = " present."]
    AV_PKT_DATA_PALETTE = 0,
    #[doc = " The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format"]
    #[doc = " that the extradata buffer was changed and the receiving side should"]
    #[doc = " act upon it appropriately. The new extradata is embedded in the side"]
    #[doc = " data buffer and should be immediately used for processing the current"]
    #[doc = " frame or packet."]
    AV_PKT_DATA_NEW_EXTRADATA = 1,
    #[doc = " An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:"]
    #[doc = " @code"]
    #[doc = " u32le param_flags"]
    #[doc = " if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)"]
    #[doc = "     s32le channel_count"]
    #[doc = " if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)"]
    #[doc = "     u64le channel_layout"]
    #[doc = " if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)"]
    #[doc = "     s32le sample_rate"]
    #[doc = " if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)"]
    #[doc = "     s32le width"]
    #[doc = "     s32le height"]
    #[doc = " @endcode"]
    AV_PKT_DATA_PARAM_CHANGE = 2,
    #[doc = " An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of"]
    #[doc = " structures with info about macroblocks relevant to splitting the"]
    #[doc = " packet into smaller packets on macroblock edges (e.g. as for RFC 2190)."]
    #[doc = " That is, it does not necessarily contain info about all macroblocks,"]
    #[doc = " as long as the distance between macroblocks in the info is smaller"]
    #[doc = " than the target payload size."]
    #[doc = " Each MB info structure is 12 bytes, and is laid out as follows:"]
    #[doc = " @code"]
    #[doc = " u32le bit offset from the start of the packet"]
    #[doc = " u8    current quantizer at the start of the macroblock"]
    #[doc = " u8    GOB number"]
    #[doc = " u16le macroblock address within the GOB"]
    #[doc = " u8    horizontal MV predictor"]
    #[doc = " u8    vertical MV predictor"]
    #[doc = " u8    horizontal MV predictor for block number 3"]
    #[doc = " u8    vertical MV predictor for block number 3"]
    #[doc = " @endcode"]
    AV_PKT_DATA_H263_MB_INFO = 3,
    #[doc = " This side data should be associated with an audio stream and contains"]
    #[doc = " ReplayGain information in form of the AVReplayGain struct."]
    AV_PKT_DATA_REPLAYGAIN = 4,
    #[doc = " This side data contains a 3x3 transformation matrix describing an affine"]
    #[doc = " transformation that needs to be applied to the decoded video frames for"]
    #[doc = " correct presentation."]
    #[doc = ""]
    #[doc = " See libavutil/display.h for a detailed description of the data."]
    AV_PKT_DATA_DISPLAYMATRIX = 5,
    #[doc = " This side data should be associated with a video stream and contains"]
    #[doc = " Stereoscopic 3D information in form of the AVStereo3D struct."]
    AV_PKT_DATA_STEREO3D = 6,
    #[doc = " This side data should be associated with an audio stream and corresponds"]
    #[doc = " to enum AVAudioServiceType."]
    AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7,
    #[doc = " This side data contains quality related information from the encoder."]
    #[doc = " @code"]
    #[doc = " u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad)."]
    #[doc = " u8    picture type"]
    #[doc = " u8    error count"]
    #[doc = " u16   reserved"]
    #[doc = " u64le[error count] sum of squared differences between encoder in and output"]
    #[doc = " @endcode"]
    AV_PKT_DATA_QUALITY_STATS = 8,
    #[doc = " This side data contains an integer value representing the stream index"]
    #[doc = " of a \"fallback\" track.  A fallback track indicates an alternate"]
    #[doc = " track to use when the current track can not be decoded for some reason."]
    #[doc = " e.g. no decoder available for codec."]
    AV_PKT_DATA_FALLBACK_TRACK = 9,
    #[doc = " This side data corresponds to the AVCPBProperties struct."]
    AV_PKT_DATA_CPB_PROPERTIES = 10,
    #[doc = " Recommmends skipping the specified number of samples"]
    #[doc = " @code"]
    #[doc = " u32le number of samples to skip from start of this packet"]
    #[doc = " u32le number of samples to skip from end of this packet"]
    #[doc = " u8    reason for start skip"]
    #[doc = " u8    reason for end   skip (0=padding silence, 1=convergence)"]
    #[doc = " @endcode"]
    AV_PKT_DATA_SKIP_SAMPLES = 11,
    #[doc = " An AV_PKT_DATA_JP_DUALMONO side data packet indicates that"]
    #[doc = " the packet may contain \"dual mono\" audio specific to Japanese DTV"]
    #[doc = " and if it is true, recommends only the selected channel to be used."]
    #[doc = " @code"]
    #[doc = " u8    selected channels (0=mail/left, 1=sub/right, 2=both)"]
    #[doc = " @endcode"]
    AV_PKT_DATA_JP_DUALMONO = 12,
    #[doc = " A list of zero terminated key/value strings. There is no end marker for"]
    #[doc = " the list, so it is required to rely on the side data size to stop."]
    AV_PKT_DATA_STRINGS_METADATA = 13,
    #[doc = " Subtitle event position"]
    #[doc = " @code"]
    #[doc = " u32le x1"]
    #[doc = " u32le y1"]
    #[doc = " u32le x2"]
    #[doc = " u32le y2"]
    #[doc = " @endcode"]
    AV_PKT_DATA_SUBTITLE_POSITION = 14,
    #[doc = " Data found in BlockAdditional element of matroska container. There is"]
    #[doc = " no end marker for the data, so it is required to rely on the side data"]
    #[doc = " size to recognize the end. 8 byte id (as found in BlockAddId) followed"]
    #[doc = " by data."]
    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15,
    #[doc = " The optional first identifier line of a WebVTT cue."]
    AV_PKT_DATA_WEBVTT_IDENTIFIER = 16,
    #[doc = " The optional settings (rendering instructions) that immediately"]
    #[doc = " follow the timestamp specifier of a WebVTT cue."]
    AV_PKT_DATA_WEBVTT_SETTINGS = 17,
    #[doc = " A list of zero terminated key/value strings. There is no end marker for"]
    #[doc = " the list, so it is required to rely on the side data size to stop. This"]
    #[doc = " side data includes updated metadata which appeared in the stream."]
    AV_PKT_DATA_METADATA_UPDATE = 18,
    #[doc = " MPEGTS stream ID as uint8_t, this is required to pass the stream ID"]
    #[doc = " information from the demuxer to the corresponding muxer."]
    AV_PKT_DATA_MPEGTS_STREAM_ID = 19,
    #[doc = " Mastering display metadata (based on SMPTE-2086:2014). This metadata"]
    #[doc = " should be associated with a video stream and contains data in the form"]
    #[doc = " of the AVMasteringDisplayMetadata struct."]
    AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20,
    #[doc = " This side data should be associated with a video stream and corresponds"]
    #[doc = " to the AVSphericalMapping structure."]
    AV_PKT_DATA_SPHERICAL = 21,
    #[doc = " Content light level (based on CTA-861.3). This metadata should be"]
    #[doc = " associated with a video stream and contains data in the form of the"]
    #[doc = " AVContentLightMetadata struct."]
    AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22,
    #[doc = " ATSC A53 Part 4 Closed Captions. This metadata should be associated with"]
    #[doc = " a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data."]
    #[doc = " The number of bytes of CC data is AVPacketSideData.size."]
    AV_PKT_DATA_A53_CC = 23,
    #[doc = " This side data is encryption initialization data."]
    #[doc = " The format is not part of ABI, use av_encryption_init_info_* methods to"]
    #[doc = " access."]
    AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24,
    #[doc = " This side data contains encryption info for how to decrypt the packet."]
    #[doc = " The format is not part of ABI, use av_encryption_info_* methods to access."]
    AV_PKT_DATA_ENCRYPTION_INFO = 25,
    #[doc = " Active Format Description data consisting of a single byte as specified"]
    #[doc = " in ETSI TS 101 154 using AVActiveFormatDescription enum."]
    AV_PKT_DATA_AFD = 26,
    #[doc = " Producer Reference Time data corresponding to the AVProducerReferenceTime struct,"]
    #[doc = " usually exported by some encoders (on demand through the prft flag set in the"]
    #[doc = " AVCodecContext export_side_data field)."]
    AV_PKT_DATA_PRFT = 27,
    #[doc = " ICC profile data consisting of an opaque octet buffer following the"]
    #[doc = " format described by ISO 15076-1."]
    AV_PKT_DATA_ICC_PROFILE = 28,
    #[doc = " DOVI configuration"]
    #[doc = " ref:"]
    #[doc = " dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2"]
    #[doc = " dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3"]
    #[doc = " Tags are stored in struct AVDOVIDecoderConfigurationRecord."]
    AV_PKT_DATA_DOVI_CONF = 29,
    #[doc = " Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t"]
    #[doc = " where the first uint32_t describes how many (1-3) of the other timecodes are used."]
    #[doc = " The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()"]
    #[doc = " function in libavutil/timecode.h."]
    AV_PKT_DATA_S12M_TIMECODE = 30,
    #[doc = " HDR10+ dynamic metadata associated with a video frame. The metadata is in"]
    #[doc = " the form of the AVDynamicHDRPlus struct and contains"]
    #[doc = " information for color volume transform - application 4 of"]
    #[doc = " SMPTE 2094-40:2016 standard."]
    AV_PKT_DATA_DYNAMIC_HDR10_PLUS = 31,
    #[doc = " The number of side data types."]
    #[doc = " This is not part of the public API/ABI in the sense that it may"]
    #[doc = " change when new side data types are added."]
    #[doc = " This must stay the last enum value."]
    #[doc = " If its value becomes huge, some code using it"]
    #[doc = " needs to be updated as it assumes it to be smaller than other limits."]
    AV_PKT_DATA_NB = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: usize,
    pub type_: AVPacketSideDataType,
}
#[test]
fn bindgen_test_layout_AVPacketSideData() {
    assert_eq!(
        ::std::mem::size_of::<AVPacketSideData>(),
        24usize,
        concat!("Size of: ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacketSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " This structure stores compressed data. It is typically exported by demuxers"]
#[doc = " and then passed as input to decoders, or received as output from encoders and"]
#[doc = " then passed to muxers."]
#[doc = ""]
#[doc = " For video, it should typically contain one compressed frame. For audio it may"]
#[doc = " contain several compressed frames. Encoders are allowed to output empty"]
#[doc = " packets, with no compressed data, containing only side data"]
#[doc = " (e.g. to update some stream parameters at the end of encoding)."]
#[doc = ""]
#[doc = " The semantics of data ownership depends on the buf field."]
#[doc = " If it is set, the packet data is dynamically allocated and is"]
#[doc = " valid indefinitely until a call to av_packet_unref() reduces the"]
#[doc = " reference count to 0."]
#[doc = ""]
#[doc = " If the buf field is not set av_packet_ref() would make a copy instead"]
#[doc = " of increasing the reference count."]
#[doc = ""]
#[doc = " The side data is always allocated with av_malloc(), copied by"]
#[doc = " av_packet_ref() and freed by av_packet_unref()."]
#[doc = ""]
#[doc = " sizeof(AVPacket) being a part of the public ABI is deprecated. once"]
#[doc = " av_init_packet() is removed, new packets will only be able to be allocated"]
#[doc = " with av_packet_alloc(), and new fields may be added to the end of the struct"]
#[doc = " with a minor bump."]
#[doc = ""]
#[doc = " @see av_packet_alloc"]
#[doc = " @see av_packet_ref"]
#[doc = " @see av_packet_unref"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacket {
    #[doc = " A reference to the reference-counted buffer where the packet data is"]
    #[doc = " stored."]
    #[doc = " May be NULL, then the packet data is not reference-counted."]
    pub buf: *mut AVBufferRef,
    #[doc = " Presentation timestamp in AVStream->time_base units; the time at which"]
    #[doc = " the decompressed packet will be presented to the user."]
    #[doc = " Can be AV_NOPTS_VALUE if it is not stored in the file."]
    #[doc = " pts MUST be larger or equal to dts as presentation cannot happen before"]
    #[doc = " decompression, unless one wants to view hex dumps. Some formats misuse"]
    #[doc = " the terms dts and pts/cts to mean something different. Such timestamps"]
    #[doc = " must be converted to true pts/dts before they are stored in AVPacket."]
    pub pts: i64,
    #[doc = " Decompression timestamp in AVStream->time_base units; the time at which"]
    #[doc = " the packet is decompressed."]
    #[doc = " Can be AV_NOPTS_VALUE if it is not stored in the file."]
    pub dts: i64,
    pub data: *mut u8,
    pub size: libc::c_int,
    pub stream_index: libc::c_int,
    #[doc = " A combination of AV_PKT_FLAG values"]
    pub flags: libc::c_int,
    #[doc = " Additional packet data that can be provided by the container."]
    #[doc = " Packet can contain several types of side information."]
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: libc::c_int,
    #[doc = " Duration of this packet in AVStream->time_base units, 0 if unknown."]
    #[doc = " Equals next_pts - this_pts in presentation order."]
    pub duration: i64,
    #[doc = "< byte position in stream, -1 if unknown"]
    pub pos: i64,
    #[doc = " for some private data of the user"]
    pub opaque: *mut libc::c_void,
    #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the"]
    #[doc = " contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when"]
    #[doc = " the packet is unreferenced. av_packet_copy_props() calls create a new"]
    #[doc = " reference with av_buffer_ref() for the target packet's opaque_ref field."]
    #[doc = ""]
    #[doc = " This is unrelated to the opaque field, although it serves a similar"]
    #[doc = " purpose."]
    pub opaque_ref: *mut AVBufferRef,
    #[doc = " Time base of the packet's timestamps."]
    #[doc = " In the future, this field may be set on packets output by encoders or"]
    #[doc = " demuxers, but its value will be by default ignored on input to decoders"]
    #[doc = " or muxers."]
    pub time_base: AVRational,
}
#[test]
fn bindgen_test_layout_AVPacket() {
    assert_eq!(
        ::std::mem::size_of::<AVPacket>(),
        104usize,
        concat!("Size of: ", stringify!(AVPacket))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacket>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).pts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).dts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).stream_index as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).side_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).side_data_elems as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).duration as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).opaque as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).opaque_ref as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(opaque_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).time_base as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(time_base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
#[test]
fn bindgen_test_layout_AVPacketList() {
    assert_eq!(
        ::std::mem::size_of::<AVPacketList>(),
        112usize,
        concat!("Size of: ", stringify!(AVPacketList))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacketList>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketList>())).pkt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(pkt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketList>())).next as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(next)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSideDataParamChangeFlags {
    #[doc = " @deprecated those are not used by any decoder"]
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1,
    #[doc = " @deprecated those are not used by any decoder"]
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2,
    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4,
    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8,
}
extern "C" {
    #[doc = " Allocate an AVPacket and set its fields to default values.  The resulting"]
    #[doc = " struct must be freed using av_packet_free()."]
    #[doc = ""]
    #[doc = " @return An AVPacket filled with default values or NULL on failure."]
    #[doc = ""]
    #[doc = " @note this only allocates the AVPacket itself, not the data buffers. Those"]
    #[doc = " must be allocated through other means such as av_new_packet."]
    #[doc = ""]
    #[doc = " @see av_new_packet"]
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    #[doc = " Create a new packet that references the same data as src."]
    #[doc = ""]
    #[doc = " This is a shortcut for av_packet_alloc()+av_packet_ref()."]
    #[doc = ""]
    #[doc = " @return newly created AVPacket on success, NULL on error."]
    #[doc = ""]
    #[doc = " @see av_packet_alloc"]
    #[doc = " @see av_packet_ref"]
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    #[doc = " Free the packet, if the packet is reference counted, it will be"]
    #[doc = " unreferenced first."]
    #[doc = ""]
    #[doc = " @param pkt packet to be freed. The pointer will be set to NULL."]
    #[doc = " @note passing NULL is a no-op."]
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    #[doc = " Initialize optional fields of a packet with default values."]
    #[doc = ""]
    #[doc = " Note, this does not touch the data and size members, which have to be"]
    #[doc = " initialized separately."]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = ""]
    #[doc = " @see av_packet_alloc"]
    #[doc = " @see av_packet_unref"]
    #[doc = ""]
    #[doc = " @deprecated This function is deprecated. Once it's removed,"]
    #[doc = "sizeof(AVPacket) will not be a part of the ABI anymore."]
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Allocate the payload of a packet and initialize its fields with"]
    #[doc = " default values."]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = " @param size wanted payload size"]
    #[doc = " @return 0 if OK, AVERROR_xxx otherwise"]
    pub fn av_new_packet(pkt: *mut AVPacket, size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Reduce packet size, correctly zeroing padding"]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = " @param size new size"]
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: libc::c_int);
}
extern "C" {
    #[doc = " Increase packet size, correctly zeroing padding"]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = " @param grow_by number of bytes by which to increase the size of the packet"]
    pub fn av_grow_packet(pkt: *mut AVPacket, grow_by: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize a reference-counted packet from av_malloc()ed data."]
    #[doc = ""]
    #[doc = " @param pkt packet to be initialized. This function will set the data, size,"]
    #[doc = "        and buf fields, all others are left untouched."]
    #[doc = " @param data Data allocated by av_malloc() to be used as packet data. If this"]
    #[doc = "        function returns successfully, the data is owned by the underlying AVBuffer."]
    #[doc = "        The caller may not access the data through other means."]
    #[doc = " @param size size of data in bytes, without the padding. I.e. the full buffer"]
    #[doc = "        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error"]
    pub fn av_packet_from_data(pkt: *mut AVPacket, data: *mut u8, size: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate new information of a packet."]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = " @param type side information type"]
    #[doc = " @param size side information size"]
    #[doc = " @return pointer to fresh allocated data or NULL otherwise"]
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Wrap an existing array as a packet side data."]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = " @param type side information type"]
    #[doc = " @param data the side data array. It must be allocated with the av_malloc()"]
    #[doc = "             family of functions. The ownership of the data is transferred to"]
    #[doc = "             pkt."]
    #[doc = " @param size side information size"]
    #[doc = " @return a non-negative number on success, a negative AVERROR code on"]
    #[doc = "         failure. On failure, the packet is unchanged and the data remains"]
    #[doc = "         owned by the caller."]
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Shrink the already allocated side data buffer"]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = " @param type side information type"]
    #[doc = " @param size new side information size"]
    #[doc = " @return 0 on success, < 0 on failure"]
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get side information from packet."]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    #[doc = " @param type desired side information type"]
    #[doc = " @param size If supplied, *size will be set to the size of the side data"]
    #[doc = "             or to zero if the desired side data is not present."]
    #[doc = " @return pointer to data if present or NULL otherwise"]
    pub fn av_packet_get_side_data(
        pkt: *const AVPacket,
        type_: AVPacketSideDataType,
        size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Pack a dictionary for use in side_data."]
    #[doc = ""]
    #[doc = " @param dict The dictionary to pack."]
    #[doc = " @param size pointer to store the size of the returned data"]
    #[doc = " @return pointer to data if successful, NULL otherwise"]
    pub fn av_packet_pack_dictionary(dict: *mut AVDictionary, size: *mut usize) -> *mut u8;
}
extern "C" {
    #[doc = " Unpack a dictionary from side_data."]
    #[doc = ""]
    #[doc = " @param data data from side_data"]
    #[doc = " @param size size of the data"]
    #[doc = " @param dict the metadata storage dictionary"]
    #[doc = " @return 0 on success, < 0 on failure"]
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: usize,
        dict: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convenience function to free all the side data stored."]
    #[doc = " All the other fields stay untouched."]
    #[doc = ""]
    #[doc = " @param pkt packet"]
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Setup a new reference to the data described by a given packet"]
    #[doc = ""]
    #[doc = " If src is reference-counted, setup dst as a new reference to the"]
    #[doc = " buffer in src. Otherwise allocate a new buffer in dst and copy the"]
    #[doc = " data from src into it."]
    #[doc = ""]
    #[doc = " All the other fields are copied from src."]
    #[doc = ""]
    #[doc = " @see av_packet_unref"]
    #[doc = ""]
    #[doc = " @param dst Destination packet. Will be completely overwritten."]
    #[doc = " @param src Source packet"]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error. On error, dst"]
    #[doc = "         will be blank (as if returned by av_packet_alloc())."]
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Wipe the packet."]
    #[doc = ""]
    #[doc = " Unreference the buffer referenced by the packet and reset the"]
    #[doc = " remaining packet fields to their default values."]
    #[doc = ""]
    #[doc = " @param pkt The packet to be unreferenced."]
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Move every field in src to dst and reset src."]
    #[doc = ""]
    #[doc = " @see av_packet_unref"]
    #[doc = ""]
    #[doc = " @param src Source packet, will be reset"]
    #[doc = " @param dst Destination packet"]
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    #[doc = " Copy only \"properties\" fields from src to dst."]
    #[doc = ""]
    #[doc = " Properties for the purpose of this function are all the fields"]
    #[doc = " beside those related to the packet data (buf, data, size)"]
    #[doc = ""]
    #[doc = " @param dst Destination packet"]
    #[doc = " @param src Source packet"]
    #[doc = ""]
    #[doc = " @return 0 on success AVERROR on failure."]
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Ensure the data described by a given packet is reference counted."]
    #[doc = ""]
    #[doc = " @note This function does not ensure that the reference will be writable."]
    #[doc = "       Use av_packet_make_writable instead for that purpose."]
    #[doc = ""]
    #[doc = " @see av_packet_ref"]
    #[doc = " @see av_packet_make_writable"]
    #[doc = ""]
    #[doc = " @param pkt packet whose data should be made reference counted."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error. On failure, the"]
    #[doc = "         packet is unchanged."]
    pub fn av_packet_make_refcounted(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a writable reference for the data described by a given packet,"]
    #[doc = " avoiding data copy if possible."]
    #[doc = ""]
    #[doc = " @param pkt Packet whose data should be made writable."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on failure. On failure, the"]
    #[doc = "         packet is unchanged."]
    pub fn av_packet_make_writable(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert valid timing fields (timestamps / durations) in a packet from one"]
    #[doc = " timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " @param pkt packet on which the conversion will be performed"]
    #[doc = " @param tb_src source timebase, in which the timing fields in pkt are"]
    #[doc = "               expressed"]
    #[doc = " @param tb_dst destination timebase, to which the timing fields will be"]
    #[doc = "               converted"]
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
#[doc = " @ingroup lavc_encoding"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct RcOverride {
    pub start_frame: libc::c_int,
    pub end_frame: libc::c_int,
    pub qscale: libc::c_int,
    pub quality_factor: f32,
}
#[test]
fn bindgen_test_layout_RcOverride() {
    assert_eq!(
        ::std::mem::size_of::<RcOverride>(),
        16usize,
        concat!("Size of: ", stringify!(RcOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<RcOverride>(),
        4usize,
        concat!("Alignment of ", stringify!(RcOverride))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).start_frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).end_frame as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).qscale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(qscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).quality_factor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(quality_factor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
#[doc = " main external API structure."]
#[doc = " New fields can be added to the end with minor version bumps."]
#[doc = " Removal, reordering and changes to existing fields require a major"]
#[doc = " version bump."]
#[doc = " You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user"]
#[doc = " applications."]
#[doc = " The name string for AVOptions options matches the associated command line"]
#[doc = " parameter name and can be found in libavcodec/options_table.h"]
#[doc = " The AVOption/command line parameter names differ in some cases from the C"]
#[doc = " structure field names for historic reasons or brevity."]
#[doc = " sizeof(AVCodecContext) must not be used outside libav*."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVCodecContext {
    #[doc = " information on struct for av_log"]
    #[doc = " - set by avcodec_alloc_context3"]
    pub av_class: *const AVClass,
    pub log_level_offset: libc::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_id: AVCodecID,
    #[doc = " fourcc (LSB first, so \"ABCD\" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A')."]
    #[doc = " This is used to work around some encoder bugs."]
    #[doc = " A demuxer should set this to what is stored in the field used to identify the codec."]
    #[doc = " If there are multiple such fields in a container then the demuxer should choose the one"]
    #[doc = " which maximizes the information about the used codec."]
    #[doc = " If the codec tag field in a container is larger than 32 bits then the demuxer should"]
    #[doc = " remap the longer ID to 32 bits with a table or other structure. Alternatively a new"]
    #[doc = " extra_codec_tag + size could be added but for this a clear advantage must be demonstrated"]
    #[doc = " first."]
    #[doc = " - encoding: Set by user, if not then the default based on codec_id will be used."]
    #[doc = " - decoding: Set by user, will be converted to uppercase by libavcodec during init."]
    pub codec_tag: libc::c_uint,
    pub priv_data: *mut libc::c_void,
    #[doc = " Private context used for internal data."]
    #[doc = ""]
    #[doc = " Unlike priv_data, this is not codec-specific. It is used in general"]
    #[doc = " libavcodec functions."]
    pub internal: *mut AVCodecInternal,
    #[doc = " Private data of the user, can be used to carry app specific stuff."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub opaque: *mut libc::c_void,
    #[doc = " the average bitrate"]
    #[doc = " - encoding: Set by user; unused for constant quantizer encoding."]
    #[doc = " - decoding: Set by user, may be overwritten by libavcodec"]
    #[doc = "             if this info is available in the stream"]
    pub bit_rate: i64,
    #[doc = " number of bits the bitstream is allowed to diverge from the reference."]
    #[doc = "           the reference can be CBR (for CBR pass1) or VBR (for pass2)"]
    #[doc = " - encoding: Set by user; unused for constant quantizer encoding."]
    #[doc = " - decoding: unused"]
    pub bit_rate_tolerance: libc::c_int,
    #[doc = " Global quality for codecs which cannot change it per frame."]
    #[doc = " This should be proportional to MPEG-1/2/4 qscale."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub global_quality: libc::c_int,
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub compression_level: libc::c_int,
    #[doc = " AV_CODEC_FLAG_*."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub flags: libc::c_int,
    #[doc = " AV_CODEC_FLAG2_*"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub flags2: libc::c_int,
    #[doc = " some codecs need / can use extradata like Huffman tables."]
    #[doc = " MJPEG: Huffman tables"]
    #[doc = " rv10: additional flags"]
    #[doc = " MPEG-4: global headers (they can be in the bitstream or here)"]
    #[doc = " The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger"]
    #[doc = " than extradata_size to avoid problems if it is read with the bitstream reader."]
    #[doc = " The bytewise contents of extradata must not depend on the architecture or CPU endianness."]
    #[doc = " Must be allocated with the av_malloc() family of functions."]
    #[doc = " - encoding: Set/allocated/freed by libavcodec."]
    #[doc = " - decoding: Set/allocated/freed by user."]
    pub extradata: *mut u8,
    pub extradata_size: libc::c_int,
    #[doc = " This is the fundamental unit of time (in seconds) in terms"]
    #[doc = " of which frame timestamps are represented. For fixed-fps content,"]
    #[doc = " timebase should be 1/framerate and timestamp increments should be"]
    #[doc = " identically 1."]
    #[doc = " This often, but not always is the inverse of the frame rate or field rate"]
    #[doc = " for video. 1/time_base is not the average frame rate if the frame rate is not"]
    #[doc = " constant."]
    #[doc = ""]
    #[doc = " Like containers, elementary streams also can store timestamps, 1/time_base"]
    #[doc = " is the unit in which these timestamps are specified."]
    #[doc = " As example of such codec time base see ISO/IEC 14496-2:2001(E)"]
    #[doc = " vop_time_increment_resolution and fixed_vop_rate"]
    #[doc = " (fixed_vop_rate == 0 implies that it is different from the framerate)"]
    #[doc = ""]
    #[doc = " - encoding: MUST be set by user."]
    #[doc = " - decoding: the use of this field for decoding is deprecated."]
    #[doc = "             Use framerate instead."]
    pub time_base: AVRational,
    #[doc = " For some codecs, the time base is closer to the field rate than the frame rate."]
    #[doc = " Most notably, H.264 and MPEG-2 specify time_base as half of frame duration"]
    #[doc = " if no telecine is used ..."]
    #[doc = ""]
    #[doc = " Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2."]
    pub ticks_per_frame: libc::c_int,
    #[doc = " Codec delay."]
    #[doc = ""]
    #[doc = " Encoding: Number of frames delay there will be from the encoder input to"]
    #[doc = "           the decoder output. (we assume the decoder matches the spec)"]
    #[doc = " Decoding: Number of frames delay in addition to what a standard decoder"]
    #[doc = "           as specified in the spec would produce."]
    #[doc = ""]
    #[doc = " Video:"]
    #[doc = "   Number of frames the decoded output will be delayed relative to the"]
    #[doc = "   encoded input."]
    #[doc = ""]
    #[doc = " Audio:"]
    #[doc = "   For encoding, this field is unused (see initial_padding)."]
    #[doc = ""]
    #[doc = "   For decoding, this is the number of samples the decoder needs to"]
    #[doc = "   output before the decoder's output is valid. When seeking, you should"]
    #[doc = "   start decoding this many samples prior to your desired seek point."]
    #[doc = ""]
    #[doc = " - encoding: Set by libavcodec."]
    #[doc = " - decoding: Set by libavcodec."]
    pub delay: libc::c_int,
    #[doc = " picture width / height."]
    #[doc = ""]
    #[doc = " @note Those fields may not match the values of the last"]
    #[doc = " AVFrame output by avcodec_receive_frame() due frame"]
    #[doc = " reordering."]
    #[doc = ""]
    #[doc = " - encoding: MUST be set by user."]
    #[doc = " - decoding: May be set by the user before opening the decoder if known e.g."]
    #[doc = "             from the container. Some decoders will require the dimensions"]
    #[doc = "             to be set by the caller. During decoding, the decoder may"]
    #[doc = "             overwrite those values as required while parsing the data."]
    pub width: libc::c_int,
    #[doc = " picture width / height."]
    #[doc = ""]
    #[doc = " @note Those fields may not match the values of the last"]
    #[doc = " AVFrame output by avcodec_receive_frame() due frame"]
    #[doc = " reordering."]
    #[doc = ""]
    #[doc = " - encoding: MUST be set by user."]
    #[doc = " - decoding: May be set by the user before opening the decoder if known e.g."]
    #[doc = "             from the container. Some decoders will require the dimensions"]
    #[doc = "             to be set by the caller. During decoding, the decoder may"]
    #[doc = "             overwrite those values as required while parsing the data."]
    pub height: libc::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when"]
    #[doc = " the decoded frame is cropped before being output or lowres is enabled."]
    #[doc = ""]
    #[doc = " @note Those field may not match the value of the last"]
    #[doc = " AVFrame output by avcodec_receive_frame() due frame"]
    #[doc = " reordering."]
    #[doc = ""]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: May be set by the user before opening the decoder if known"]
    #[doc = "             e.g. from the container. During decoding, the decoder may"]
    #[doc = "             overwrite those values as required while parsing the data."]
    pub coded_width: libc::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when"]
    #[doc = " the decoded frame is cropped before being output or lowres is enabled."]
    #[doc = ""]
    #[doc = " @note Those field may not match the value of the last"]
    #[doc = " AVFrame output by avcodec_receive_frame() due frame"]
    #[doc = " reordering."]
    #[doc = ""]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: May be set by the user before opening the decoder if known"]
    #[doc = "             e.g. from the container. During decoding, the decoder may"]
    #[doc = "             overwrite those values as required while parsing the data."]
    pub coded_height: libc::c_int,
    #[doc = " the number of pictures in a group of pictures, or 0 for intra_only"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub gop_size: libc::c_int,
    #[doc = " Pixel format, see AV_PIX_FMT_xxx."]
    #[doc = " May be set by the demuxer if known from headers."]
    #[doc = " May be overridden by the decoder if it knows better."]
    #[doc = ""]
    #[doc = " @note This field may not match the value of the last"]
    #[doc = " AVFrame output by avcodec_receive_frame() due frame"]
    #[doc = " reordering."]
    #[doc = ""]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user if known, overridden by libavcodec while"]
    #[doc = "             parsing the data."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " If non NULL, 'draw_horiz_band' is called by the libavcodec"]
    #[doc = " decoder to draw a horizontal band. It improves cache usage. Not"]
    #[doc = " all codecs can do that. You must check the codec capabilities"]
    #[doc = " beforehand."]
    #[doc = " When multithreading is used, it may be called from multiple threads"]
    #[doc = " at the same time; threads might draw different parts of the same AVFrame,"]
    #[doc = " or multiple AVFrames, and there is no guarantee that slices will be drawn"]
    #[doc = " in order."]
    #[doc = " The function is also used by hardware acceleration APIs."]
    #[doc = " It is called at least once during frame decoding to pass"]
    #[doc = " the data needed for hardware render."]
    #[doc = " In that mode instead of pixel data, AVFrame points to"]
    #[doc = " a structure specific to the acceleration API. The application"]
    #[doc = " reads the structure and can change some fields to indicate progress"]
    #[doc = " or mark state."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    #[doc = " @param height the height of the slice"]
    #[doc = " @param y the y position of the slice"]
    #[doc = " @param type 1->top field, 2->bottom field, 3->frame"]
    #[doc = " @param offset offset into the AVFrame.data from which the slice should be read"]
    pub draw_horiz_band: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut libc::c_int,
            y: libc::c_int,
            type_: libc::c_int,
            height: libc::c_int,
        ),
    >,
    #[doc = " Callback to negotiate the pixel format. Decoding only, may be set by the"]
    #[doc = " caller before avcodec_open2()."]
    #[doc = ""]
    #[doc = " Called by some decoders to select the pixel format that will be used for"]
    #[doc = " the output frames. This is mainly used to set up hardware acceleration,"]
    #[doc = " then the provided format list contains the corresponding hwaccel pixel"]
    #[doc = " formats alongside the \"software\" one. The software pixel format may also"]
    #[doc = " be retrieved from \\ref sw_pix_fmt."]
    #[doc = ""]
    #[doc = " This callback will be called when the coded frame properties (such as"]
    #[doc = " resolution, pixel format, etc.) change and more than one output format is"]
    #[doc = " supported for those new properties. If a hardware pixel format is chosen"]
    #[doc = " and initialization for it fails, the callback may be called again"]
    #[doc = " immediately."]
    #[doc = ""]
    #[doc = " This callback may be called from different threads if the decoder is"]
    #[doc = " multi-threaded, but not from more than one thread simultaneously."]
    #[doc = ""]
    #[doc = " @param fmt list of formats which may be used in the current"]
    #[doc = "            configuration, terminated by AV_PIX_FMT_NONE."]
    #[doc = " @warning Behavior is undefined if the callback returns a value other"]
    #[doc = "          than one of the formats in fmt or AV_PIX_FMT_NONE."]
    #[doc = " @return the chosen format or AV_PIX_FMT_NONE"]
    pub get_format: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    #[doc = " maximum number of B-frames between non-B-frames"]
    #[doc = " Note: The output will be delayed by max_b_frames+1 relative to the input."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub max_b_frames: libc::c_int,
    #[doc = " qscale factor between IP and B-frames"]
    #[doc = " If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset)."]
    #[doc = " If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset)."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub b_quant_factor: f32,
    #[doc = " qscale offset between IP and B-frames"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub b_quant_offset: f32,
    #[doc = " Size of the frame reordering buffer in the decoder."]
    #[doc = " For MPEG-2 it is 1 IPB or 0 low delay IP."]
    #[doc = " - encoding: Set by libavcodec."]
    #[doc = " - decoding: Set by libavcodec."]
    pub has_b_frames: libc::c_int,
    #[doc = " qscale factor between P- and I-frames"]
    #[doc = " If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset)."]
    #[doc = " If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset)."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub i_quant_factor: f32,
    #[doc = " qscale offset between P and I-frames"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub i_quant_offset: f32,
    #[doc = " luminance masking (0-> disabled)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub lumi_masking: f32,
    #[doc = " temporary complexity masking (0-> disabled)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub temporal_cplx_masking: f32,
    #[doc = " spatial complexity masking (0-> disabled)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub spatial_cplx_masking: f32,
    #[doc = " p block masking (0-> disabled)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub p_masking: f32,
    #[doc = " darkness masking (0-> disabled)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub dark_masking: f32,
    #[doc = " slice count"]
    #[doc = " - encoding: Set by libavcodec."]
    #[doc = " - decoding: Set by user (or 0)."]
    pub slice_count: libc::c_int,
    #[doc = " slice offsets in the frame in bytes"]
    #[doc = " - encoding: Set/allocated by libavcodec."]
    #[doc = " - decoding: Set/allocated by user (or NULL)."]
    pub slice_offset: *mut libc::c_int,
    #[doc = " sample aspect ratio (0 if unknown)"]
    #[doc = " That is the width of a pixel divided by the height of the pixel."]
    #[doc = " Numerator and denominator must be relatively prime and smaller than 256 for some video standards."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " motion estimation comparison function"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub me_cmp: libc::c_int,
    #[doc = " subpixel motion estimation comparison function"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub me_sub_cmp: libc::c_int,
    #[doc = " macroblock comparison function (not supported yet)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub mb_cmp: libc::c_int,
    #[doc = " interlaced DCT comparison function"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub ildct_cmp: libc::c_int,
    #[doc = " ME diamond size & shape"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub dia_size: libc::c_int,
    #[doc = " amount of previous MV predictors (2a+1 x 2a+1 square)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub last_predictor_count: libc::c_int,
    #[doc = " motion estimation prepass comparison function"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub me_pre_cmp: libc::c_int,
    #[doc = " ME prepass diamond size & shape"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub pre_dia_size: libc::c_int,
    #[doc = " subpel ME quality"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub me_subpel_quality: libc::c_int,
    #[doc = " maximum motion estimation search range in subpel units"]
    #[doc = " If 0 then no limit."]
    #[doc = ""]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub me_range: libc::c_int,
    #[doc = " slice flags"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub slice_flags: libc::c_int,
    #[doc = " macroblock decision mode"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub mb_decision: libc::c_int,
    #[doc = " custom intra quantization matrix"]
    #[doc = " Must be allocated with the av_malloc() family of functions, and will be freed in"]
    #[doc = " avcodec_free_context()."]
    #[doc = " - encoding: Set/allocated by user, freed by libavcodec. Can be NULL."]
    #[doc = " - decoding: Set/allocated/freed by libavcodec."]
    pub intra_matrix: *mut u16,
    #[doc = " custom inter quantization matrix"]
    #[doc = " Must be allocated with the av_malloc() family of functions, and will be freed in"]
    #[doc = " avcodec_free_context()."]
    #[doc = " - encoding: Set/allocated by user, freed by libavcodec. Can be NULL."]
    #[doc = " - decoding: Set/allocated/freed by libavcodec."]
    pub inter_matrix: *mut u16,
    #[doc = " precision of the intra DC coefficient - 8"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec"]
    pub intra_dc_precision: libc::c_int,
    #[doc = " Number of macroblock rows at the top which are skipped."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub skip_top: libc::c_int,
    #[doc = " Number of macroblock rows at the bottom which are skipped."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub skip_bottom: libc::c_int,
    #[doc = " minimum MB Lagrange multiplier"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub mb_lmin: libc::c_int,
    #[doc = " maximum MB Lagrange multiplier"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub mb_lmax: libc::c_int,
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub bidir_refine: libc::c_int,
    #[doc = " minimum GOP size"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub keyint_min: libc::c_int,
    #[doc = " number of reference frames"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by lavc."]
    pub refs: libc::c_int,
    #[doc = " Note: Value depends upon the compare function used for fullpel ME."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub mv0_threshold: libc::c_int,
    #[doc = " Chromaticity coordinates of the source primaries."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by libavcodec"]
    pub color_primaries: AVColorPrimaries,
    #[doc = " Color Transfer Characteristic."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by libavcodec"]
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    #[doc = " MPEG vs JPEG YUV range."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by libavcodec"]
    pub color_range: AVColorRange,
    #[doc = " This defines the location of chroma samples."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by libavcodec"]
    pub chroma_sample_location: AVChromaLocation,
    #[doc = " Number of slices."]
    #[doc = " Indicates number of picture subdivisions. Used for parallelized"]
    #[doc = " decoding."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: unused"]
    pub slices: libc::c_int,
    #[doc = " Field order"]
    #[doc = " - encoding: set by libavcodec"]
    #[doc = " - decoding: Set by user."]
    pub field_order: AVFieldOrder,
    #[doc = "< samples per second"]
    pub sample_rate: libc::c_int,
    #[doc = " number of audio channels"]
    #[doc = " @deprecated use ch_layout.nb_channels"]
    pub channels: libc::c_int,
    #[doc = "< sample format"]
    pub sample_fmt: AVSampleFormat,
    #[doc = " Number of samples per channel in an audio frame."]
    #[doc = ""]
    #[doc = " - encoding: set by libavcodec in avcodec_open2(). Each submitted frame"]
    #[doc = "   except the last must contain exactly frame_size samples per channel."]
    #[doc = "   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the"]
    #[doc = "   frame size is not restricted."]
    #[doc = " - decoding: may be set by some decoders to indicate constant frame size"]
    pub frame_size: libc::c_int,
    #[doc = " Frame counter, set by libavcodec."]
    #[doc = ""]
    #[doc = " - decoding: total number of frames returned from the decoder so far."]
    #[doc = " - encoding: total number of frames passed to the encoder so far."]
    #[doc = ""]
    #[doc = "   @note the counter is not incremented if encoding/decoding resulted in"]
    #[doc = "   an error."]
    pub frame_number: libc::c_int,
    #[doc = " number of bytes per packet if constant and known or 0"]
    #[doc = " Used by some WAV based audio codecs."]
    pub block_align: libc::c_int,
    #[doc = " Audio cutoff bandwidth (0 means \"automatic\")"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub cutoff: libc::c_int,
    #[doc = " Audio channel layout."]
    #[doc = " - encoding: set by user."]
    #[doc = " - decoding: set by user, may be overwritten by libavcodec."]
    #[doc = " @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Request decoder to use this channel layout if it can (0 for default)"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    #[doc = " @deprecated use \"downmix\" codec private option"]
    pub request_channel_layout: u64,
    #[doc = " Type of service that the audio stream conveys."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub audio_service_type: AVAudioServiceType,
    #[doc = " desired sample format"]
    #[doc = " - encoding: Not used."]
    #[doc = " - decoding: Set by user."]
    #[doc = " Decoder will decode to this format if it can."]
    pub request_sample_fmt: AVSampleFormat,
    #[doc = " This callback is called at the beginning of each frame to get data"]
    #[doc = " buffer(s) for it. There may be one contiguous buffer for all the data or"]
    #[doc = " there may be a buffer per each data plane or anything in between. What"]
    #[doc = " this means is, you may set however many entries in buf[] you feel necessary."]
    #[doc = " Each buffer must be reference-counted using the AVBuffer API (see description"]
    #[doc = " of buf[] below)."]
    #[doc = ""]
    #[doc = " The following fields will be set in the frame before this callback is"]
    #[doc = " called:"]
    #[doc = " - format"]
    #[doc = " - width, height (video only)"]
    #[doc = " - sample_rate, channel_layout, nb_samples (audio only)"]
    #[doc = " Their values may differ from the corresponding values in"]
    #[doc = " AVCodecContext. This callback must use the frame values, not the codec"]
    #[doc = " context values, to calculate the required buffer size."]
    #[doc = ""]
    #[doc = " This callback must fill the following fields in the frame:"]
    #[doc = " - data[]"]
    #[doc = " - linesize[]"]
    #[doc = " - extended_data:"]
    #[doc = "   * if the data is planar audio with more than 8 channels, then this"]
    #[doc = "     callback must allocate and fill extended_data to contain all pointers"]
    #[doc = "     to all data planes. data[] must hold as many pointers as it can."]
    #[doc = "     extended_data must be allocated with av_malloc() and will be freed in"]
    #[doc = "     av_frame_unref()."]
    #[doc = "   * otherwise extended_data must point to data"]
    #[doc = " - buf[] must contain one or more pointers to AVBufferRef structures. Each of"]
    #[doc = "   the frame's data and extended_data pointers must be contained in these. That"]
    #[doc = "   is, one AVBufferRef for each allocated chunk of memory, not necessarily one"]
    #[doc = "   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),"]
    #[doc = "   and av_buffer_ref()."]
    #[doc = " - extended_buf and nb_extended_buf must be allocated with av_malloc() by"]
    #[doc = "   this callback and filled with the extra buffers if there are more"]
    #[doc = "   buffers than buf[] can hold. extended_buf will be freed in"]
    #[doc = "   av_frame_unref()."]
    #[doc = ""]
    #[doc = " If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call"]
    #[doc = " avcodec_default_get_buffer2() instead of providing buffers allocated by"]
    #[doc = " some other means."]
    #[doc = ""]
    #[doc = " Each data plane must be aligned to the maximum required by the target"]
    #[doc = " CPU."]
    #[doc = ""]
    #[doc = " @see avcodec_default_get_buffer2()"]
    #[doc = ""]
    #[doc = " Video:"]
    #[doc = ""]
    #[doc = " If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused"]
    #[doc = " (read and/or written to if it is writable) later by libavcodec."]
    #[doc = ""]
    #[doc = " avcodec_align_dimensions2() should be used to find the required width and"]
    #[doc = " height, as they normally need to be rounded up to the next multiple of 16."]
    #[doc = ""]
    #[doc = " Some decoders do not support linesizes changing between frames."]
    #[doc = ""]
    #[doc = " If frame multithreading is used, this callback may be called from a"]
    #[doc = " different thread, but not from more than one at once. Does not need to be"]
    #[doc = " reentrant."]
    #[doc = ""]
    #[doc = " @see avcodec_align_dimensions2()"]
    #[doc = ""]
    #[doc = " Audio:"]
    #[doc = ""]
    #[doc = " Decoders request a buffer of a particular size by setting"]
    #[doc = " AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,"]
    #[doc = " however, utilize only part of the buffer by setting AVFrame.nb_samples"]
    #[doc = " to a smaller value in the output frame."]
    #[doc = ""]
    #[doc = " As a convenience, av_samples_get_buffer_size() and"]
    #[doc = " av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()"]
    #[doc = " functions to find the required data size and to fill data pointers and"]
    #[doc = " linesize. In AVFrame.linesize, only linesize[0] may be set for audio"]
    #[doc = " since all planes must be the same size."]
    #[doc = ""]
    #[doc = " @see av_samples_get_buffer_size(), av_samples_fill_arrays()"]
    #[doc = ""]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by libavcodec, user can override."]
    pub get_buffer2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            frame: *mut AVFrame,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = "< amount of qscale change between easy & hard scenes (0.0-1.0)"]
    pub qcompress: f32,
    #[doc = "< amount of qscale smoothing over time (0.0-1.0)"]
    pub qblur: f32,
    #[doc = " minimum quantizer"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub qmin: libc::c_int,
    #[doc = " maximum quantizer"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub qmax: libc::c_int,
    #[doc = " maximum quantizer difference between frames"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub max_qdiff: libc::c_int,
    #[doc = " decoder bitstream buffer size"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub rc_buffer_size: libc::c_int,
    #[doc = " ratecontrol override, see RcOverride"]
    #[doc = " - encoding: Allocated/set/freed by user."]
    #[doc = " - decoding: unused"]
    pub rc_override_count: libc::c_int,
    pub rc_override: *mut RcOverride,
    #[doc = " maximum bitrate"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user, may be overwritten by libavcodec."]
    pub rc_max_rate: i64,
    #[doc = " minimum bitrate"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub rc_min_rate: i64,
    #[doc = " Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused."]
    pub rc_max_available_vbv_use: f32,
    #[doc = " Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused."]
    pub rc_min_vbv_overflow_use: f32,
    #[doc = " Number of bits which should be loaded into the rc buffer before decoding starts."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub rc_initial_buffer_occupancy: libc::c_int,
    #[doc = " trellis RD quantization"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub trellis: libc::c_int,
    #[doc = " pass1 encoding statistics output buffer"]
    #[doc = " - encoding: Set by libavcodec."]
    #[doc = " - decoding: unused"]
    pub stats_out: *mut libc::c_char,
    #[doc = " pass2 encoding statistics input buffer"]
    #[doc = " Concatenated stuff from stats_out of pass1 should be placed here."]
    #[doc = " - encoding: Allocated/set/freed by user."]
    #[doc = " - decoding: unused"]
    pub stats_in: *mut libc::c_char,
    #[doc = " Work around bugs in encoders which sometimes cannot be detected automatically."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by user"]
    pub workaround_bugs: libc::c_int,
    #[doc = " strictly follow the standard (MPEG-4, ...)."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    #[doc = " Setting this to STRICT or higher means the encoder and decoder will"]
    #[doc = " generally do stupid things, whereas setting it to unofficial or lower"]
    #[doc = " will mean the encoder might produce output that is not supported by all"]
    #[doc = " spec-compliant decoders. Decoders don't differentiate between normal,"]
    #[doc = " unofficial and experimental (that is, they always try to decode things"]
    #[doc = " when they can) unless they are explicitly asked to behave stupidly"]
    #[doc = " (=strictly conform to the specs)"]
    pub strict_std_compliance: libc::c_int,
    #[doc = " error concealment flags"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub error_concealment: libc::c_int,
    #[doc = " debug"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub debug: libc::c_int,
    #[doc = " Error recognition; may misdetect some more or less valid parts as errors."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub err_recognition: libc::c_int,
    #[doc = " opaque 64-bit number (generally a PTS) that will be reordered and"]
    #[doc = " output in AVFrame.reordered_opaque"]
    #[doc = " - encoding: Set by libavcodec to the reordered_opaque of the input"]
    #[doc = "             frame corresponding to the last returned packet. Only"]
    #[doc = "             supported by encoders with the"]
    #[doc = "             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability."]
    #[doc = " - decoding: Set by user."]
    pub reordered_opaque: i64,
    #[doc = " Hardware accelerator in use"]
    #[doc = " - encoding: unused."]
    #[doc = " - decoding: Set by libavcodec"]
    pub hwaccel: *const AVHWAccel,
    #[doc = " Hardware accelerator context."]
    #[doc = " For some hardware accelerators, a global context needs to be"]
    #[doc = " provided by the user. In that case, this holds display-dependent"]
    #[doc = " data FFmpeg cannot instantiate itself. Please refer to the"]
    #[doc = " FFmpeg HW accelerator documentation to know how to fill this."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user"]
    pub hwaccel_context: *mut libc::c_void,
    #[doc = " error"]
    #[doc = " - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR."]
    #[doc = " - decoding: unused"]
    pub error: [u64; 8usize],
    #[doc = " DCT algorithm, see FF_DCT_* below"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub dct_algo: libc::c_int,
    #[doc = " IDCT algorithm, see FF_IDCT_* below."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub idct_algo: libc::c_int,
    #[doc = " bits per sample/pixel from the demuxer (needed for huffyuv)."]
    #[doc = " - encoding: Set by libavcodec."]
    #[doc = " - decoding: Set by user."]
    pub bits_per_coded_sample: libc::c_int,
    #[doc = " Bits per sample/pixel of internal libavcodec pixel/sample format."]
    #[doc = " - encoding: set by user."]
    #[doc = " - decoding: set by libavcodec."]
    pub bits_per_raw_sample: libc::c_int,
    #[doc = " low resolution decoding, 1-> 1/2 size, 2->1/4 size"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub lowres: libc::c_int,
    #[doc = " thread count"]
    #[doc = " is used to decide how many independent tasks should be passed to execute()"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub thread_count: libc::c_int,
    #[doc = " Which multithreading methods to use."]
    #[doc = " Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,"]
    #[doc = " so clients which cannot provide future frames should not use it."]
    #[doc = ""]
    #[doc = " - encoding: Set by user, otherwise the default is used."]
    #[doc = " - decoding: Set by user, otherwise the default is used."]
    pub thread_type: libc::c_int,
    #[doc = " Which multithreading methods are in use by the codec."]
    #[doc = " - encoding: Set by libavcodec."]
    #[doc = " - decoding: Set by libavcodec."]
    pub active_thread_type: libc::c_int,
    #[doc = " Set by the client if its custom get_buffer() callback can be called"]
    #[doc = " synchronously from another thread, which allows faster multithreaded decoding."]
    #[doc = " draw_horiz_band() will be called from other threads regardless of this setting."]
    #[doc = " Ignored if the default get_buffer() is used."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    #[doc = ""]
    #[doc = " @deprecated the custom get_buffer2() callback should always be"]
    #[doc = "   thread-safe. Thread-unsafe get_buffer2() implementations will be"]
    #[doc = "   invalid starting with LIBAVCODEC_VERSION_MAJOR=60; in other words,"]
    #[doc = "   libavcodec will behave as if this field was always set to 1."]
    #[doc = "   Callers that want to be forward compatible with future libavcodec"]
    #[doc = "   versions should wrap access to this field in"]
    #[doc = "     #if LIBAVCODEC_VERSION_MAJOR < 60"]
    pub thread_safe_callbacks: libc::c_int,
    #[doc = " The codec may call this to execute several independent things."]
    #[doc = " It will return only after finishing all tasks."]
    #[doc = " The user may replace this with some multithreaded implementation,"]
    #[doc = " the default implementation will execute the parts serially."]
    #[doc = " @param count the number of things to execute"]
    #[doc = " - encoding: Set by libavcodec, user can override."]
    #[doc = " - decoding: Set by libavcodec, user can override."]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut libc::c_void,
                ) -> libc::c_int,
            >,
            arg2: *mut libc::c_void,
            ret: *mut libc::c_int,
            count: libc::c_int,
            size: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " The codec may call this to execute several independent things."]
    #[doc = " It will return only after finishing all tasks."]
    #[doc = " The user may replace this with some multithreaded implementation,"]
    #[doc = " the default implementation will execute the parts serially."]
    #[doc = " @param c context passed also to func"]
    #[doc = " @param count the number of things to execute"]
    #[doc = " @param arg2 argument passed unchanged to func"]
    #[doc = " @param ret return values of executed functions, must have space for \"count\" values. May be NULL."]
    #[doc = " @param func function that will be called count times, with jobnr from 0 to count-1."]
    #[doc = "             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no"]
    #[doc = "             two instances of func executing at the same time will have the same threadnr."]
    #[doc = " @return always 0 currently, but code should handle a future improvement where when any call to func"]
    #[doc = "         returns < 0 no further calls to func may be done and < 0 is returned."]
    #[doc = " - encoding: Set by libavcodec, user can override."]
    #[doc = " - decoding: Set by libavcodec, user can override."]
    pub execute2: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut libc::c_void,
                    jobnr: libc::c_int,
                    threadnr: libc::c_int,
                ) -> libc::c_int,
            >,
            arg2: *mut libc::c_void,
            ret: *mut libc::c_int,
            count: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " noise vs. sse weight for the nsse comparison function"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: unused"]
    pub nsse_weight: libc::c_int,
    #[doc = " profile"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub profile: libc::c_int,
    #[doc = " level"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub level: libc::c_int,
    #[doc = " Skip loop filtering for selected frames."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub skip_loop_filter: AVDiscard,
    #[doc = " Skip IDCT/dequantization for selected frames."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub skip_idct: AVDiscard,
    #[doc = " Skip decoding for selected frames."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user."]
    pub skip_frame: AVDiscard,
    #[doc = " Header containing style information for text subtitles."]
    #[doc = " For SUBTITLE_ASS subtitle type, it should contain the whole ASS"]
    #[doc = " [Script Info] and [V4+ Styles] section, plus the [Events] line and"]
    #[doc = " the Format line following. It shouldn't include any Dialogue line."]
    #[doc = " - encoding: Set/allocated/freed by user (before avcodec_open2())"]
    #[doc = " - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())"]
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: libc::c_int,
    #[doc = " Audio only. The number of \"priming\" samples (padding) inserted by the"]
    #[doc = " encoder at the beginning of the audio. I.e. this number of leading"]
    #[doc = " decoded samples must be discarded by the caller to get the original audio"]
    #[doc = " without leading padding."]
    #[doc = ""]
    #[doc = " - decoding: unused"]
    #[doc = " - encoding: Set by libavcodec. The timestamps on the output packets are"]
    #[doc = "             adjusted by the encoder so that they always refer to the"]
    #[doc = "             first sample of the data actually contained in the packet,"]
    #[doc = "             including any added padding.  E.g. if the timebase is"]
    #[doc = "             1/samplerate and the timestamp of the first input sample is"]
    #[doc = "             0, the timestamp of the first output packet will be"]
    #[doc = "             -initial_padding."]
    pub initial_padding: libc::c_int,
    #[doc = " - decoding: For codecs that store a framerate value in the compressed"]
    #[doc = "             bitstream, the decoder may export it here. { 0, 1} when"]
    #[doc = "             unknown."]
    #[doc = " - encoding: May be used to signal the framerate of CFR content to an"]
    #[doc = "             encoder."]
    pub framerate: AVRational,
    #[doc = " Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx."]
    #[doc = " - encoding: unused."]
    #[doc = " - decoding: Set by libavcodec before calling get_format()"]
    pub sw_pix_fmt: AVPixelFormat,
    #[doc = " Timebase in which pkt_dts/pts and AVPacket.dts/pts are."]
    #[doc = " - encoding unused."]
    #[doc = " - decoding set by user."]
    pub pkt_timebase: AVRational,
    #[doc = " AVCodecDescriptor"]
    #[doc = " - encoding: unused."]
    #[doc = " - decoding: set by libavcodec."]
    pub codec_descriptor: *const AVCodecDescriptor,
    #[doc = " Current statistics for PTS correction."]
    #[doc = " - decoding: maintained and used by libavcodec, not intended to be used by user apps"]
    #[doc = " - encoding: unused"]
    pub pts_correction_num_faulty_pts: i64,
    #[doc = " Number of incorrect PTS values so far"]
    pub pts_correction_num_faulty_dts: i64,
    #[doc = " Number of incorrect DTS values so far"]
    pub pts_correction_last_pts: i64,
    #[doc = " PTS of the last frame"]
    pub pts_correction_last_dts: i64,
    #[doc = " Character encoding of the input subtitles file."]
    #[doc = " - decoding: set by user"]
    #[doc = " - encoding: unused"]
    pub sub_charenc: *mut libc::c_char,
    #[doc = " Subtitles character encoding mode. Formats or codecs might be adjusting"]
    #[doc = " this setting (if they are doing the conversion themselves for instance)."]
    #[doc = " - decoding: set by libavcodec"]
    #[doc = " - encoding: unused"]
    pub sub_charenc_mode: libc::c_int,
    #[doc = " Skip processing alpha if supported by codec."]
    #[doc = " Note that if the format uses pre-multiplied alpha (common with VP6,"]
    #[doc = " and recommended due to better video quality/compression)"]
    #[doc = " the image will look as if alpha-blended onto a black background."]
    #[doc = " However for formats that do not use pre-multiplied alpha"]
    #[doc = " there might be serious artefacts (though e.g. libswscale currently"]
    #[doc = " assumes pre-multiplied alpha anyway)."]
    #[doc = ""]
    #[doc = " - decoding: set by user"]
    #[doc = " - encoding: unused"]
    pub skip_alpha: libc::c_int,
    #[doc = " Number of samples to skip after a discontinuity"]
    #[doc = " - decoding: unused"]
    #[doc = " - encoding: set by libavcodec"]
    pub seek_preroll: libc::c_int,
    #[doc = " @deprecated unused"]
    pub debug_mv: libc::c_int,
    #[doc = " custom intra quantization matrix"]
    #[doc = " - encoding: Set by user, can be NULL."]
    #[doc = " - decoding: unused."]
    pub chroma_intra_matrix: *mut u16,
    #[doc = " dump format separator."]
    #[doc = " can be \", \" or \"\\n      \" or anything else"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by user."]
    pub dump_separator: *mut u8,
    #[doc = " ',' separated list of allowed decoders."]
    #[doc = " If NULL then all are allowed"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by user"]
    pub codec_whitelist: *mut libc::c_char,
    #[doc = " Properties of the stream that gets decoded"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by libavcodec"]
    pub properties: libc::c_uint,
    #[doc = " Additional data associated with the entire coded stream."]
    #[doc = ""]
    #[doc = " - decoding: unused"]
    #[doc = " - encoding: may be set by libavcodec after avcodec_open2()."]
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: libc::c_int,
    #[doc = " A reference to the AVHWFramesContext describing the input (for encoding)"]
    #[doc = " or output (decoding) frames. The reference is set by the caller and"]
    #[doc = " afterwards owned (and freed) by libavcodec - it should never be read by"]
    #[doc = " the caller after being set."]
    #[doc = ""]
    #[doc = " - decoding: This field should be set by the caller from the get_format()"]
    #[doc = "             callback. The previous reference (if any) will always be"]
    #[doc = "             unreffed by libavcodec before the get_format() call."]
    #[doc = ""]
    #[doc = "             If the default get_buffer2() is used with a hwaccel pixel"]
    #[doc = "             format, then this AVHWFramesContext will be used for"]
    #[doc = "             allocating the frame buffers."]
    #[doc = ""]
    #[doc = " - encoding: For hardware encoders configured to use a hwaccel pixel"]
    #[doc = "             format, this field should be set by the caller to a reference"]
    #[doc = "             to the AVHWFramesContext describing input frames."]
    #[doc = "             AVHWFramesContext.format must be equal to"]
    #[doc = "             AVCodecContext.pix_fmt."]
    #[doc = ""]
    #[doc = "             This field should be set before avcodec_open2() is called."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " @deprecated unused"]
    pub sub_text_format: libc::c_int,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to"]
    #[doc = " the end of the audio. I.e. this number of decoded samples must be"]
    #[doc = " discarded by the caller from the end of the stream to get the original"]
    #[doc = " audio without any trailing padding."]
    #[doc = ""]
    #[doc = " - decoding: unused"]
    #[doc = " - encoding: unused"]
    pub trailing_padding: libc::c_int,
    #[doc = " The number of pixels per image to maximally accept."]
    #[doc = ""]
    #[doc = " - decoding: set by user"]
    #[doc = " - encoding: set by user"]
    pub max_pixels: i64,
    #[doc = " A reference to the AVHWDeviceContext describing the device which will"]
    #[doc = " be used by a hardware encoder/decoder.  The reference is set by the"]
    #[doc = " caller and afterwards owned (and freed) by libavcodec."]
    #[doc = ""]
    #[doc = " This should be used if either the codec device does not require"]
    #[doc = " hardware frames or any that are used are to be allocated internally by"]
    #[doc = " libavcodec.  If the user wishes to supply any of the frames used as"]
    #[doc = " encoder input or decoder output then hw_frames_ctx should be used"]
    #[doc = " instead.  When hw_frames_ctx is set in get_format() for a decoder, this"]
    #[doc = " field will be ignored while decoding the associated stream segment, but"]
    #[doc = " may again be used on a following one after another get_format() call."]
    #[doc = ""]
    #[doc = " For both encoders and decoders this field should be set before"]
    #[doc = " avcodec_open2() is called and must not be written to thereafter."]
    #[doc = ""]
    #[doc = " Note that some decoders may require this field to be set initially in"]
    #[doc = " order to support hw_frames_ctx at all - in that case, all frames"]
    #[doc = " contexts used must be created on the same device."]
    pub hw_device_ctx: *mut AVBufferRef,
    #[doc = " Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated"]
    #[doc = " decoding (if active)."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user (either before avcodec_open2(), or in the"]
    #[doc = "             AVCodecContext.get_format callback)"]
    pub hwaccel_flags: libc::c_int,
    #[doc = " Video decoding only. Certain video codecs support cropping, meaning that"]
    #[doc = " only a sub-rectangle of the decoded frame is intended for display.  This"]
    #[doc = " option controls how cropping is handled by libavcodec."]
    #[doc = ""]
    #[doc = " When set to 1 (the default), libavcodec will apply cropping internally."]
    #[doc = " I.e. it will modify the output frame width/height fields and offset the"]
    #[doc = " data pointers (only by as much as possible while preserving alignment, or"]
    #[doc = " by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that"]
    #[doc = " the frames output by the decoder refer only to the cropped area. The"]
    #[doc = " crop_* fields of the output frames will be zero."]
    #[doc = ""]
    #[doc = " When set to 0, the width/height fields of the output frames will be set"]
    #[doc = " to the coded dimensions and the crop_* fields will describe the cropping"]
    #[doc = " rectangle. Applying the cropping is left to the caller."]
    #[doc = ""]
    #[doc = " @warning When hardware acceleration with opaque output frames is used,"]
    #[doc = " libavcodec is unable to apply cropping from the top/left border."]
    #[doc = ""]
    #[doc = " @note when this option is set to zero, the width/height fields of the"]
    #[doc = " AVCodecContext and output AVFrames have different meanings. The codec"]
    #[doc = " context fields store display dimensions (with the coded dimensions in"]
    #[doc = " coded_width/height), while the frame fields store the coded dimensions"]
    #[doc = " (with the display dimensions being determined by the crop_* fields)."]
    pub apply_cropping: libc::c_int,
    pub extra_hw_frames: libc::c_int,
    #[doc = " The percentage of damaged samples to discard a frame."]
    #[doc = ""]
    #[doc = " - decoding: set by user"]
    #[doc = " - encoding: unused"]
    pub discard_damaged_percentage: libc::c_int,
    #[doc = " The number of samples per frame to maximally accept."]
    #[doc = ""]
    #[doc = " - decoding: set by user"]
    #[doc = " - encoding: set by user"]
    pub max_samples: i64,
    #[doc = " Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of"]
    #[doc = " metadata exported in frame, packet, or coded stream side data by"]
    #[doc = " decoders and encoders."]
    #[doc = ""]
    #[doc = " - decoding: set by user"]
    #[doc = " - encoding: set by user"]
    pub export_side_data: libc::c_int,
    #[doc = " This callback is called at the beginning of each packet to get a data"]
    #[doc = " buffer for it."]
    #[doc = ""]
    #[doc = " The following field will be set in the packet before this callback is"]
    #[doc = " called:"]
    #[doc = " - size"]
    #[doc = " This callback must use the above value to calculate the required buffer size,"]
    #[doc = " which must padded by at least AV_INPUT_BUFFER_PADDING_SIZE bytes."]
    #[doc = ""]
    #[doc = " In some specific cases, the encoder may not use the entire buffer allocated by this"]
    #[doc = " callback. This will be reflected in the size value in the packet once returned by"]
    #[doc = " avcodec_receive_packet()."]
    #[doc = ""]
    #[doc = " This callback must fill the following fields in the packet:"]
    #[doc = " - data: alignment requirements for AVPacket apply, if any. Some architectures and"]
    #[doc = "   encoders may benefit from having aligned data."]
    #[doc = " - buf: must contain a pointer to an AVBufferRef structure. The packet's"]
    #[doc = "   data pointer must be contained in it. See: av_buffer_create(), av_buffer_alloc(),"]
    #[doc = "   and av_buffer_ref()."]
    #[doc = ""]
    #[doc = " If AV_CODEC_CAP_DR1 is not set then get_encode_buffer() must call"]
    #[doc = " avcodec_default_get_encode_buffer() instead of providing a buffer allocated by"]
    #[doc = " some other means."]
    #[doc = ""]
    #[doc = " The flags field may contain a combination of AV_GET_ENCODE_BUFFER_FLAG_ flags."]
    #[doc = " They may be used for example to hint what use the buffer may get after being"]
    #[doc = " created."]
    #[doc = " Implementations of this callback may ignore flags they don't understand."]
    #[doc = " If AV_GET_ENCODE_BUFFER_FLAG_REF is set in flags then the packet may be reused"]
    #[doc = " (read and/or written to if it is writable) later by libavcodec."]
    #[doc = ""]
    #[doc = " This callback must be thread-safe, as when frame threading is used, it may"]
    #[doc = " be called from multiple threads simultaneously."]
    #[doc = ""]
    #[doc = " @see avcodec_default_get_encode_buffer()"]
    #[doc = ""]
    #[doc = " - encoding: Set by libavcodec, user can override."]
    #[doc = " - decoding: unused"]
    pub get_encode_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            pkt: *mut AVPacket,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " Audio channel layout."]
    #[doc = " - encoding: must be set by the caller, to one of AVCodec.ch_layouts."]
    #[doc = " - decoding: may be set by the caller if known e.g. from the container."]
    #[doc = "             The decoder can then override during decoding as needed."]
    pub ch_layout: AVChannelLayout,
}
#[test]
fn bindgen_test_layout_AVCodecContext() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecContext>(),
        944usize,
        concat!("Size of: ", stringify!(AVCodecContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).log_level_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(log_level_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_tag as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).priv_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).internal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).bit_rate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bit_rate_tolerance as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate_tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).global_quality as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(global_quality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).compression_level as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(compression_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).flags as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).flags2 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extradata as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extradata_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).time_base as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).ticks_per_frame as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ticks_per_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).delay as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).width as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_width as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_height as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).gop_size as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(gop_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pix_fmt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).draw_horiz_band as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(draw_horiz_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).get_format as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_b_frames as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_quant_factor as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_quant_offset as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).has_b_frames as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(has_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_quant_factor as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_quant_offset as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lumi_masking as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lumi_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).temporal_cplx_masking as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(temporal_cplx_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).spatial_cplx_masking as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(spatial_cplx_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).p_masking as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dark_masking as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dark_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_count as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_offset as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).sample_aspect_ratio as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_cmp as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_sub_cmp as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_sub_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_cmp as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).ildct_cmp as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ildct_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dia_size as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).last_predictor_count as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(last_predictor_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_pre_cmp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_pre_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pre_dia_size as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).me_subpel_quality as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_subpel_quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_range as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_flags as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_decision as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_decision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).intra_matrix as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).inter_matrix as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(inter_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).intra_dc_precision as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_top as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_bottom as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_lmin as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_lmax as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).bidir_refine as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bidir_refine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).keyint_min as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(keyint_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).refs as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mv0_threshold as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv0_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_primaries as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_trc as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).colorspace as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_range as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).chroma_sample_location as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_sample_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slices as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).field_order as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sample_rate as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).channels as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sample_fmt as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_size as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_number as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).block_align as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).cutoff as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(cutoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).channel_layout as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).request_channel_layout as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).audio_service_type as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(audio_service_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).request_sample_fmt as *const _ as usize
        },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).get_buffer2 as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_buffer2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qcompress as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qcompress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qblur as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qblur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qmin as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qmax as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_qdiff as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_qdiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_buffer_size as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_override_count as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_override as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_max_rate as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_min_rate as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_max_available_vbv_use as *const _ as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_available_vbv_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_min_vbv_overflow_use as *const _ as usize
        },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_vbv_overflow_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_initial_buffer_occupancy as *const _
                as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_initial_buffer_occupancy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).trellis as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trellis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).stats_out as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).stats_in as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).workaround_bugs as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(workaround_bugs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).strict_std_compliance as *const _ as usize
        },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).error_concealment as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error_concealment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).debug as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).err_recognition as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(err_recognition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).reordered_opaque as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel_context as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).error as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dct_algo as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dct_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).idct_algo as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(idct_algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bits_per_coded_sample as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bits_per_raw_sample as *const _ as usize
        },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lowres as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).thread_count as *const _ as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).thread_type as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).active_thread_type as *const _ as usize
        },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(active_thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).thread_safe_callbacks as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_safe_callbacks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).execute as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).execute2 as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).nsse_weight as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nsse_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).profile as *const _ as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).level as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_loop_filter as *const _ as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_loop_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_idct as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_idct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_frame as *const _ as usize },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).subtitle_header as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).subtitle_header_size as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).initial_padding as *const _ as usize },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).framerate as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sw_pix_fmt as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sw_pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pkt_timebase as *const _ as usize },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pkt_timebase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_descriptor as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_pts as *const _
                as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_dts as *const _
                as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_last_pts as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_last_dts as *const _ as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_charenc as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_charenc_mode as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_alpha as *const _ as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).seek_preroll as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(seek_preroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).debug_mv as *const _ as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug_mv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).chroma_intra_matrix as *const _ as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dump_separator as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_whitelist as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).properties as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_side_data as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_side_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).nb_coded_side_data as *const _ as usize
        },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nb_coded_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hw_frames_ctx as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_text_format as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_text_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).trailing_padding as *const _ as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_pixels as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hw_device_ctx as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel_flags as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).apply_cropping as *const _ as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(apply_cropping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extra_hw_frames as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extra_hw_frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).discard_damaged_percentage as *const _
                as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(discard_damaged_percentage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_samples as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).export_side_data as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(export_side_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).get_encode_buffer as *const _ as usize
        },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_encode_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).ch_layout as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ch_layout)
        )
    );
}
#[doc = " @defgroup lavc_hwaccel AVHWAccel"]
#[doc = ""]
#[doc = " @note  Nothing in this structure should be accessed by the user.  At some"]
#[doc = "        point in future it will not be externally visible at all."]
#[doc = ""]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWAccel {
    #[doc = " Name of the hardware accelerated codec."]
    #[doc = " The name is globally unique among encoders and among decoders (but an"]
    #[doc = " encoder and a decoder can share the same name)."]
    pub name: *const libc::c_char,
    #[doc = " Type of codec implemented by the hardware accelerator."]
    #[doc = ""]
    #[doc = " See AVMEDIA_TYPE_xxx"]
    pub type_: AVMediaType,
    #[doc = " Codec implemented by the hardware accelerator."]
    #[doc = ""]
    #[doc = " See AV_CODEC_ID_xxx"]
    pub id: AVCodecID,
    #[doc = " Supported pixel format."]
    #[doc = ""]
    #[doc = " Only hardware accelerated formats are supported here."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Hardware accelerated codec capabilities."]
    #[doc = " see AV_HWACCEL_CODEC_CAP_*"]
    pub capabilities: libc::c_int,
    #[doc = " Allocate a custom buffer"]
    pub alloc_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int,
    >,
    #[doc = " Called at the beginning of each frame or field picture."]
    #[doc = ""]
    #[doc = " Meaningful frame information (codec specific) is guaranteed to"]
    #[doc = " be parsed at this point. This function is mandatory."]
    #[doc = ""]
    #[doc = " Note that buf can be NULL along with buf_size set to 0."]
    #[doc = " Otherwise, this means the whole frame is available at this point."]
    #[doc = ""]
    #[doc = " @param avctx the codec context"]
    #[doc = " @param buf the frame data buffer base"]
    #[doc = " @param buf_size the size of the frame in bytes"]
    #[doc = " @return zero if successful, a negative value otherwise"]
    pub start_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> libc::c_int,
    >,
    #[doc = " Callback for parameter data (SPS/PPS/VPS etc)."]
    #[doc = ""]
    #[doc = " Useful for hardware decoders which keep persistent state about the"]
    #[doc = " video parameters, and need to receive any changes to update that state."]
    #[doc = ""]
    #[doc = " @param avctx the codec context"]
    #[doc = " @param type the nal unit type"]
    #[doc = " @param buf the nal unit data buffer"]
    #[doc = " @param buf_size the size of the nal unit in bytes"]
    #[doc = " @return zero if successful, a negative value otherwise"]
    pub decode_params: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            type_: libc::c_int,
            buf: *const u8,
            buf_size: u32,
        ) -> libc::c_int,
    >,
    #[doc = " Callback for each slice."]
    #[doc = ""]
    #[doc = " Meaningful slice information (codec specific) is guaranteed to"]
    #[doc = " be parsed at this point. This function is mandatory."]
    #[doc = ""]
    #[doc = " @param avctx the codec context"]
    #[doc = " @param buf the slice data buffer base"]
    #[doc = " @param buf_size the size of the slice in bytes"]
    #[doc = " @return zero if successful, a negative value otherwise"]
    pub decode_slice: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> libc::c_int,
    >,
    #[doc = " Called at the end of each frame or field picture."]
    #[doc = ""]
    #[doc = " The whole picture is parsed at this point and can now be sent"]
    #[doc = " to the hardware accelerator. This function is mandatory."]
    #[doc = ""]
    #[doc = " @param avctx the codec context"]
    #[doc = " @return zero if successful, a negative value otherwise"]
    pub end_frame:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    #[doc = " Size of per-frame hardware accelerator private data."]
    #[doc = ""]
    #[doc = " Private data is allocated with av_mallocz() before"]
    #[doc = " AVCodecContext.get_buffer() and deallocated after"]
    #[doc = " AVCodecContext.release_buffer()."]
    pub frame_priv_data_size: libc::c_int,
    #[doc = " Initialize the hwaccel private data."]
    #[doc = ""]
    #[doc = " This will be called from ff_get_format(), after hwaccel and"]
    #[doc = " hwaccel_context are set and the hwaccel private data in AVCodecInternal"]
    #[doc = " is allocated."]
    pub init:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    #[doc = " Uninitialize the hwaccel private data."]
    #[doc = ""]
    #[doc = " This will be called from get_format() or avcodec_close(), after hwaccel"]
    #[doc = " and hwaccel_context are already uninitialized."]
    pub uninit:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    #[doc = " Size of the private data to allocate in"]
    #[doc = " AVCodecInternal.hwaccel_priv_data."]
    pub priv_data_size: libc::c_int,
    #[doc = " Internal hwaccel capabilities."]
    pub caps_internal: libc::c_int,
    #[doc = " Fill the given hw_frames context with current codec parameters. Called"]
    #[doc = " from get_format. Refer to avcodec_get_hw_frames_parameters() for"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " This CAN be called before AVHWAccel.init is called, and you must assume"]
    #[doc = " that avctx->hwaccel_priv_data is invalid."]
    pub frame_params: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            hw_frames_ctx: *mut AVBufferRef,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVHWAccel() {
    assert_eq!(
        ::std::mem::size_of::<AVHWAccel>(),
        104usize,
        concat!("Size of: ", stringify!(AVHWAccel))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWAccel>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWAccel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).pix_fmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).capabilities as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).alloc_frame as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(alloc_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).start_frame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).decode_params as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).decode_slice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).end_frame as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).frame_priv_data_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(frame_priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).init as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).uninit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(uninit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).priv_data_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).caps_internal as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(caps_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).frame_params as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(frame_params)
        )
    );
}
#[repr(u32)]
#[doc = " @}"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSubtitleType {
    SUBTITLE_NONE = 0,
    #[doc = "< A bitmap, pict will be set"]
    SUBTITLE_BITMAP = 1,
    #[doc = " Plain text, the text field must be set by the decoder and is"]
    #[doc = " authoritative. ass and pict fields may contain approximations."]
    SUBTITLE_TEXT = 2,
    #[doc = " Formatted text, the ass field must be set by the decoder and is"]
    #[doc = " authoritative. pict and text fields may contain approximations."]
    SUBTITLE_ASS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVSubtitleRect {
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub x: libc::c_int,
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub y: libc::c_int,
    #[doc = "< width            of pict, undefined when pict is not set"]
    pub w: libc::c_int,
    #[doc = "< height           of pict, undefined when pict is not set"]
    pub h: libc::c_int,
    #[doc = "< number of colors in pict, undefined when pict is not set"]
    pub nb_colors: libc::c_int,
    #[doc = " data+linesize for the bitmap of this subtitle."]
    #[doc = " Can be set for text/ass as well once they are rendered."]
    pub data: [*mut u8; 4usize],
    pub linesize: [libc::c_int; 4usize],
    pub type_: AVSubtitleType,
    #[doc = "< 0 terminated plain UTF-8 text"]
    pub text: *mut libc::c_char,
    #[doc = " 0 terminated ASS/SSA compatible event line."]
    #[doc = " The presentation of this is unaffected by the other values in this"]
    #[doc = " struct."]
    pub ass: *mut libc::c_char,
    pub flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVSubtitleRect() {
    assert_eq!(
        ::std::mem::size_of::<AVSubtitleRect>(),
        104usize,
        concat!("Size of: ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitleRect>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).nb_colors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(nb_colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).linesize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).type_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).text as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).ass as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(ass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).flags as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: libc::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    #[doc = "< Same as packet pts, in AV_TIME_BASE"]
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_AVSubtitle() {
    assert_eq!(
        ::std::mem::size_of::<AVSubtitle>(),
        32usize,
        concat!("Size of: ", stringify!(AVSubtitle))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitle>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).start_display_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(start_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).end_display_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(end_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).num_rects as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).rects as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).pts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(pts)
        )
    );
}
extern "C" {
    #[doc = " Return the LIBAVCODEC_VERSION_INT constant."]
    pub fn avcodec_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the libavcodec build-time configuration."]
    pub fn avcodec_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libavcodec license."]
    pub fn avcodec_license() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Allocate an AVCodecContext and set its fields to default values. The"]
    #[doc = " resulting struct should be freed with avcodec_free_context()."]
    #[doc = ""]
    #[doc = " @param codec if non-NULL, allocate private data and initialize defaults"]
    #[doc = "              for the given codec. It is illegal to then call avcodec_open2()"]
    #[doc = "              with a different codec."]
    #[doc = "              If NULL, then the codec-specific defaults won't be initialized,"]
    #[doc = "              which may result in suboptimal default settings (this is"]
    #[doc = "              important mainly for encoders, e.g. libx264)."]
    #[doc = ""]
    #[doc = " @return An AVCodecContext filled with default values or NULL on failure."]
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    #[doc = " Free the codec context and everything associated with it and write NULL to"]
    #[doc = " the provided pointer."]
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVCodecContext. It can be used in combination with"]
    #[doc = " AV_OPT_SEARCH_FAKE_OBJ for examining options."]
    #[doc = ""]
    #[doc = " @see av_opt_find()."]
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " @deprecated This function should not be used."]
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Get the AVClass for AVSubtitleRect. It can be used in combination with"]
    #[doc = " AV_OPT_SEARCH_FAKE_OBJ for examining options."]
    #[doc = ""]
    #[doc = " @see av_opt_find()."]
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Fill the parameters struct based on the values from the supplied codec"]
    #[doc = " context. Any allocated fields in par are freed and replaced with duplicates"]
    #[doc = " of the corresponding fields in codec."]
    #[doc = ""]
    #[doc = " @return >= 0 on success, a negative AVERROR code on failure"]
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill the codec context based on the values from the supplied codec"]
    #[doc = " parameters. Any allocated fields in codec that have a corresponding field in"]
    #[doc = " par are freed and replaced with duplicates of the corresponding field in par."]
    #[doc = " Fields in codec that do not have a counterpart in par are not touched."]
    #[doc = ""]
    #[doc = " @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize the AVCodecContext to use the given AVCodec. Prior to using this"]
    #[doc = " function the context has to be allocated with avcodec_alloc_context3()."]
    #[doc = ""]
    #[doc = " The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),"]
    #[doc = " avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for"]
    #[doc = " retrieving a codec."]
    #[doc = ""]
    #[doc = " @note Always call this function before using decoding routines (such as"]
    #[doc = " @ref avcodec_receive_frame())."]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " av_dict_set(&opts, \"b\", \"2.5M\", 0);"]
    #[doc = " codec = avcodec_find_decoder(AV_CODEC_ID_H264);"]
    #[doc = " if (!codec)"]
    #[doc = "     exit(1);"]
    #[doc = ""]
    #[doc = " context = avcodec_alloc_context3(codec);"]
    #[doc = ""]
    #[doc = " if (avcodec_open2(context, codec, opts) < 0)"]
    #[doc = "     exit(1);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param avctx The context to initialize."]
    #[doc = " @param codec The codec to open this context for. If a non-NULL codec has been"]
    #[doc = "              previously passed to avcodec_alloc_context3() or"]
    #[doc = "              for this context, then this parameter MUST be either NULL or"]
    #[doc = "              equal to the previously passed codec."]
    #[doc = " @param options A dictionary filled with AVCodecContext and codec-private options."]
    #[doc = "                On return this object will be filled with options that were not found."]
    #[doc = ""]
    #[doc = " @return zero on success, a negative value on error"]
    #[doc = " @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),"]
    #[doc = "      av_dict_set(), av_opt_find()."]
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a given AVCodecContext and free all the data associated with it"]
    #[doc = " (but not the AVCodecContext itself)."]
    #[doc = ""]
    #[doc = " Calling this function on an AVCodecContext that hasn't been opened will free"]
    #[doc = " the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL"]
    #[doc = " codec. Subsequent calls will do nothing."]
    #[doc = ""]
    #[doc = " @note Do not use this function. Use avcodec_free_context() to destroy a"]
    #[doc = " codec context (either open or closed). Opening and closing a codec context"]
    #[doc = " multiple times is not supported anymore -- use multiple codec contexts"]
    #[doc = " instead."]
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Free all allocated data in the given subtitle struct."]
    #[doc = ""]
    #[doc = " @param sub AVSubtitle to free."]
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_buffer2(). It is made public so"]
    #[doc = " it can be called by custom get_buffer2() implementations for decoders without"]
    #[doc = " AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_encode_buffer(). It is made public so"]
    #[doc = " it can be called by custom get_encode_buffer() implementations for encoders without"]
    #[doc = " AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_encode_buffer(
        s: *mut AVCodecContext,
        pkt: *mut AVPacket,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory"]
    #[doc = " buffer that is acceptable for the codec if you do not use any horizontal"]
    #[doc = " padding."]
    #[doc = ""]
    #[doc = " May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory"]
    #[doc = " buffer that is acceptable for the codec if you also ensure that all"]
    #[doc = " line sizes are a multiple of the respective linesize_align[i]."]
    #[doc = ""]
    #[doc = " May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
        linesize_align: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Converts AVChromaLocation to swscale x/y chroma position."]
    #[doc = ""]
    #[doc = " The positions represent the chroma (0,0) position in a coordinates system"]
    #[doc = " with luma (0,0) representing the origin and luma(1,1) representing 256,256"]
    #[doc = ""]
    #[doc = " @param xpos  horizontal chroma sample position"]
    #[doc = " @param ypos  vertical   chroma sample position"]
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut libc::c_int,
        ypos: *mut libc::c_int,
        pos: AVChromaLocation,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Converts swscale x/y chroma position to AVChromaLocation."]
    #[doc = ""]
    #[doc = " The positions represent the chroma (0,0) position in a coordinates system"]
    #[doc = " with luma (0,0) representing the origin and luma(1,1) representing 256,256"]
    #[doc = ""]
    #[doc = " @param xpos  horizontal chroma sample position"]
    #[doc = " @param ypos  vertical   chroma sample position"]
    pub fn avcodec_chroma_pos_to_enum(xpos: libc::c_int, ypos: libc::c_int) -> AVChromaLocation;
}
extern "C" {
    #[doc = " Decode a subtitle message."]
    #[doc = " Return a negative value on error, otherwise return the number of bytes used."]
    #[doc = " If no subtitle could be decompressed, got_sub_ptr is zero."]
    #[doc = " Otherwise, the subtitle is stored in *sub."]
    #[doc = " Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for"]
    #[doc = " simplicity, because the performance difference is expected to be negligible"]
    #[doc = " and reusing a get_buffer written for video codecs would probably perform badly"]
    #[doc = " due to a potentially very different allocation pattern."]
    #[doc = ""]
    #[doc = " Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input"]
    #[doc = " and output. This means that for some packets they will not immediately"]
    #[doc = " produce decoded output and need to be flushed at the end of decoding to get"]
    #[doc = " all the decoded data. Flushing is done by calling this function with packets"]
    #[doc = " with avpkt->data set to NULL and avpkt->size set to 0 until it stops"]
    #[doc = " returning subtitles. It is safe to flush even those decoders that are not"]
    #[doc = " marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned."]
    #[doc = ""]
    #[doc = " @note The AVCodecContext MUST have been opened with @ref avcodec_open2()"]
    #[doc = " before packets may be fed to the decoder."]
    #[doc = ""]
    #[doc = " @param avctx the codec context"]
    #[doc = " @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,"]
    #[doc = "                 must be freed with avsubtitle_free if *got_sub_ptr is set."]
    #[doc = " @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero."]
    #[doc = " @param[in] avpkt The input AVPacket containing the input buffer."]
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut libc::c_int,
        avpkt: *mut AVPacket,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Supply raw packet data as input to a decoder."]
    #[doc = ""]
    #[doc = " Internally, this call will copy relevant AVCodecContext fields, which can"]
    #[doc = " influence decoding per-packet, and apply them when the packet is actually"]
    #[doc = " decoded. (For example AVCodecContext.skip_frame, which might direct the"]
    #[doc = " decoder to drop the frame contained by the packet sent with this function.)"]
    #[doc = ""]
    #[doc = " @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE"]
    #[doc = "          larger than the actual read bytes because some optimized bitstream"]
    #[doc = "          readers read 32 or 64 bits at once and could read over the end."]
    #[doc = ""]
    #[doc = " @note The AVCodecContext MUST have been opened with @ref avcodec_open2()"]
    #[doc = "       before packets may be fed to the decoder."]
    #[doc = ""]
    #[doc = " @param avctx codec context"]
    #[doc = " @param[in] avpkt The input AVPacket. Usually, this will be a single video"]
    #[doc = "                  frame, or several complete audio frames."]
    #[doc = "                  Ownership of the packet remains with the caller, and the"]
    #[doc = "                  decoder will not write to the packet. The decoder may create"]
    #[doc = "                  a reference to the packet data (or copy it if the packet is"]
    #[doc = "                  not reference-counted)."]
    #[doc = "                  Unlike with older APIs, the packet is always fully consumed,"]
    #[doc = "                  and if it contains multiple frames (e.g. some audio codecs),"]
    #[doc = "                  will require you to call avcodec_receive_frame() multiple"]
    #[doc = "                  times afterwards before you can send a new packet."]
    #[doc = "                  It can be NULL (or an AVPacket with data set to NULL and"]
    #[doc = "                  size set to 0); in this case, it is considered a flush"]
    #[doc = "                  packet, which signals the end of the stream. Sending the"]
    #[doc = "                  first flush packet will return success. Subsequent ones are"]
    #[doc = "                  unnecessary and will return AVERROR_EOF. If the decoder"]
    #[doc = "                  still has frames buffered, it will return them after sending"]
    #[doc = "                  a flush packet."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise negative error code:"]
    #[doc = "      AVERROR(EAGAIN):   input is not accepted in the current state - user"]
    #[doc = "                         must read output with avcodec_receive_frame() (once"]
    #[doc = "                         all output is read, the packet should be resent, and"]
    #[doc = "                         the call will not fail with EAGAIN)."]
    #[doc = "      AVERROR_EOF:       the decoder has been flushed, and no new packets can"]
    #[doc = "                         be sent to it (also returned if more than 1 flush"]
    #[doc = "                         packet is sent)"]
    #[doc = "      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush"]
    #[doc = "      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar"]
    #[doc = "      other errors: legitimate decoding errors"]
    pub fn avcodec_send_packet(avctx: *mut AVCodecContext, avpkt: *const AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Return decoded output data from a decoder."]
    #[doc = ""]
    #[doc = " @param avctx codec context"]
    #[doc = " @param frame This will be set to a reference-counted video or audio"]
    #[doc = "              frame (depending on the decoder type) allocated by the"]
    #[doc = "              decoder. Note that the function will always call"]
    #[doc = "              av_frame_unref(frame) before doing anything else."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      0:                 success, a frame was returned"]
    #[doc = "      AVERROR(EAGAIN):   output is not available in this state - user must try"]
    #[doc = "                         to send new input"]
    #[doc = "      AVERROR_EOF:       the decoder has been fully flushed, and there will be"]
    #[doc = "                         no more output frames"]
    #[doc = "      AVERROR(EINVAL):   codec not opened, or it is an encoder"]
    #[doc = "      AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters"]
    #[doc = "                               with respect to first decoded frame. Applicable"]
    #[doc = "                               when flag AV_CODEC_FLAG_DROPCHANGED is set."]
    #[doc = "      other negative values: legitimate decoding errors"]
    pub fn avcodec_receive_frame(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()"]
    #[doc = " to retrieve buffered output packets."]
    #[doc = ""]
    #[doc = " @param avctx     codec context"]
    #[doc = " @param[in] frame AVFrame containing the raw audio or video frame to be encoded."]
    #[doc = "                  Ownership of the frame remains with the caller, and the"]
    #[doc = "                  encoder will not write to the frame. The encoder may create"]
    #[doc = "                  a reference to the frame data (or copy it if the frame is"]
    #[doc = "                  not reference-counted)."]
    #[doc = "                  It can be NULL, in which case it is considered a flush"]
    #[doc = "                  packet.  This signals the end of the stream. If the encoder"]
    #[doc = "                  still has packets buffered, it will return them after this"]
    #[doc = "                  call. Once flushing mode has been entered, additional flush"]
    #[doc = "                  packets are ignored, and sending frames will return"]
    #[doc = "                  AVERROR_EOF."]
    #[doc = ""]
    #[doc = "                  For audio:"]
    #[doc = "                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame"]
    #[doc = "                  can have any number of samples."]
    #[doc = "                  If it is not set, frame->nb_samples must be equal to"]
    #[doc = "                  avctx->frame_size for all frames except the last."]
    #[doc = "                  The final frame may be smaller than avctx->frame_size."]
    #[doc = " @return 0 on success, otherwise negative error code:"]
    #[doc = "      AVERROR(EAGAIN):   input is not accepted in the current state - user"]
    #[doc = "                         must read output with avcodec_receive_packet() (once"]
    #[doc = "                         all output is read, the packet should be resent, and"]
    #[doc = "                         the call will not fail with EAGAIN)."]
    #[doc = "      AVERROR_EOF:       the encoder has been flushed, and no new frames can"]
    #[doc = "                         be sent to it"]
    #[doc = "      AVERROR(EINVAL):   codec not opened, it is a decoder, or requires flush"]
    #[doc = "      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar"]
    #[doc = "      other errors: legitimate encoding errors"]
    pub fn avcodec_send_frame(avctx: *mut AVCodecContext, frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Read encoded data from the encoder."]
    #[doc = ""]
    #[doc = " @param avctx codec context"]
    #[doc = " @param avpkt This will be set to a reference-counted packet allocated by the"]
    #[doc = "              encoder. Note that the function will always call"]
    #[doc = "              av_packet_unref(avpkt) before doing anything else."]
    #[doc = " @return 0 on success, otherwise negative error code:"]
    #[doc = "      AVERROR(EAGAIN):   output is not available in the current state - user"]
    #[doc = "                         must try to send input"]
    #[doc = "      AVERROR_EOF:       the encoder has been fully flushed, and there will be"]
    #[doc = "                         no more output packets"]
    #[doc = "      AVERROR(EINVAL):   codec not opened, or it is a decoder"]
    #[doc = "      other errors: legitimate encoding errors"]
    pub fn avcodec_receive_packet(avctx: *mut AVCodecContext, avpkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    #[doc = " Create and return a AVHWFramesContext with values adequate for hardware"]
    #[doc = " decoding. This is meant to get called from the get_format callback, and is"]
    #[doc = " a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx."]
    #[doc = " This API is for decoding with certain hardware acceleration modes/APIs only."]
    #[doc = ""]
    #[doc = " The returned AVHWFramesContext is not initialized. The caller must do this"]
    #[doc = " with av_hwframe_ctx_init()."]
    #[doc = ""]
    #[doc = " Calling this function is not a requirement, but makes it simpler to avoid"]
    #[doc = " codec or hardware API specific details when manually allocating frames."]
    #[doc = ""]
    #[doc = " Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,"]
    #[doc = " which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes"]
    #[doc = " it unnecessary to call this function or having to care about"]
    #[doc = " AVHWFramesContext initialization at all."]
    #[doc = ""]
    #[doc = " There are a number of requirements for calling this function:"]
    #[doc = ""]
    #[doc = " - It must be called from get_format with the same avctx parameter that was"]
    #[doc = "   passed to get_format. Calling it outside of get_format is not allowed, and"]
    #[doc = "   can trigger undefined behavior."]
    #[doc = " - The function is not always supported (see description of return values)."]
    #[doc = "   Even if this function returns successfully, hwaccel initialization could"]
    #[doc = "   fail later. (The degree to which implementations check whether the stream"]
    #[doc = "   is actually supported varies. Some do this check only after the user's"]
    #[doc = "   get_format callback returns.)"]
    #[doc = " - The hw_pix_fmt must be one of the choices suggested by get_format. If the"]
    #[doc = "   user decides to use a AVHWFramesContext prepared with this API function,"]
    #[doc = "   the user must return the same hw_pix_fmt from get_format."]
    #[doc = " - The device_ref passed to this function must support the given hw_pix_fmt."]
    #[doc = " - After calling this API function, it is the user's responsibility to"]
    #[doc = "   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),"]
    #[doc = "   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done"]
    #[doc = "   before returning from get_format (this is implied by the normal"]
    #[doc = "   AVCodecContext.hw_frames_ctx API rules)."]
    #[doc = " - The AVHWFramesContext parameters may change every time time get_format is"]
    #[doc = "   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So"]
    #[doc = "   you are inherently required to go through this process again on every"]
    #[doc = "   get_format call."]
    #[doc = " - It is perfectly possible to call this function without actually using"]
    #[doc = "   the resulting AVHWFramesContext. One use-case might be trying to reuse a"]
    #[doc = "   previously initialized AVHWFramesContext, and calling this API function"]
    #[doc = "   only to test whether the required frame parameters have changed."]
    #[doc = " - Fields that use dynamically allocated values of any kind must not be set"]
    #[doc = "   by the user unless setting them is explicitly allowed by the documentation."]
    #[doc = "   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,"]
    #[doc = "   the new free callback must call the potentially set previous free callback."]
    #[doc = "   This API call may set any dynamically allocated fields, including the free"]
    #[doc = "   callback."]
    #[doc = ""]
    #[doc = " The function will set at least the following fields on AVHWFramesContext"]
    #[doc = " (potentially more, depending on hwaccel API):"]
    #[doc = ""]
    #[doc = " - All fields set by av_hwframe_ctx_alloc()."]
    #[doc = " - Set the format field to hw_pix_fmt."]
    #[doc = " - Set the sw_format field to the most suited and most versatile format. (An"]
    #[doc = "   implication is that this will prefer generic formats over opaque formats"]
    #[doc = "   with arbitrary restrictions, if possible.)"]
    #[doc = " - Set the width/height fields to the coded frame size, rounded up to the"]
    #[doc = "   API-specific minimum alignment."]
    #[doc = " - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size"]
    #[doc = "   field to the number of maximum reference surfaces possible with the codec,"]
    #[doc = "   plus 1 surface for the user to work (meaning the user can safely reference"]
    #[doc = "   at most 1 decoded surface at a time), plus additional buffering introduced"]
    #[doc = "   by frame threading. If the hwaccel does not require pre-allocation, the"]
    #[doc = "   field is left to 0, and the decoder will allocate new surfaces on demand"]
    #[doc = "   during decoding."]
    #[doc = " - Possibly AVHWFramesContext.hwctx fields, depending on the underlying"]
    #[doc = "   hardware API."]
    #[doc = ""]
    #[doc = " Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but"]
    #[doc = " with basic frame parameters set."]
    #[doc = ""]
    #[doc = " The function is stateless, and does not change the AVCodecContext or the"]
    #[doc = " device_ref AVHWDeviceContext."]
    #[doc = ""]
    #[doc = " @param avctx The context which is currently calling get_format, and which"]
    #[doc = "              implicitly contains all state needed for filling the returned"]
    #[doc = "              AVHWFramesContext properly."]
    #[doc = " @param device_ref A reference to the AVHWDeviceContext describing the device"]
    #[doc = "                   which will be used by the hardware decoder."]
    #[doc = " @param hw_pix_fmt The hwaccel format you are going to return from get_format."]
    #[doc = " @param out_frames_ref On success, set to a reference to an _uninitialized_"]
    #[doc = "                       AVHWFramesContext, created from the given device_ref."]
    #[doc = "                       Fields will be set to values required for decoding."]
    #[doc = "                       Not changed if an error is returned."]
    #[doc = " @return zero on success, a negative value on error. The following error codes"]
    #[doc = "         have special semantics:"]
    #[doc = "      AVERROR(ENOENT): the decoder does not support this functionality. Setup"]
    #[doc = "                       is always manual, or it is a decoder which does not"]
    #[doc = "                       support setting AVCodecContext.hw_frames_ctx at all,"]
    #[doc = "                       or it is a software format."]
    #[doc = "      AVERROR(EINVAL): it is known that hardware decoding is not supported for"]
    #[doc = "                       this configuration, or the device_ref is not supported"]
    #[doc = "                       for the hwaccel referenced by hw_pix_fmt."]
    pub fn avcodec_get_hw_frames_parameters(
        avctx: *mut AVCodecContext,
        device_ref: *mut AVBufferRef,
        hw_pix_fmt: AVPixelFormat,
        out_frames_ref: *mut *mut AVBufferRef,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " @defgroup lavc_parsing Frame parsing"]
#[doc = " @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPictureStructure {
    AV_PICTURE_STRUCTURE_UNKNOWN = 0,
    AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
    AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
    AV_PICTURE_STRUCTURE_FRAME = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParserContext {
    pub priv_data: *mut libc::c_void,
    pub parser: *const AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: libc::c_int,
    #[doc = " This field is used for proper frame duration computation in lavf."]
    #[doc = " It signals, how much longer the frame duration of the current frame"]
    #[doc = " is compared to normal frame duration."]
    #[doc = ""]
    #[doc = " frame_duration = (1 + repeat_pict) * time_base"]
    #[doc = ""]
    #[doc = " It is used by codecs like H.264 to display telecined material."]
    pub repeat_pict: libc::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: libc::c_int,
    pub cur_frame_start_index: libc::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: libc::c_int,
    #[doc = "< byte offset from starting packet start"]
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    #[doc = " Set by parser to 1 for key frames and 0 for non-key frames."]
    #[doc = " It is initialized to -1, so if the parser doesn't set this flag,"]
    #[doc = " old-style fallback using AV_PICTURE_TYPE_I picture type as key frames"]
    #[doc = " will be used."]
    pub key_frame: libc::c_int,
    #[doc = " Synchronization point for start of timestamp generation."]
    #[doc = ""]
    #[doc = " Set to >0 for sync point, 0 for no sync point and <0 for undefined"]
    #[doc = " (default)."]
    #[doc = ""]
    #[doc = " For example, this corresponds to presence of H.264 buffering period"]
    #[doc = " SEI message."]
    pub dts_sync_point: libc::c_int,
    #[doc = " Offset of the current timestamp against last timestamp sync point in"]
    #[doc = " units of AVCodecContext.time_base."]
    #[doc = ""]
    #[doc = " Set to INT_MIN when dts_sync_point unused. Otherwise, it must"]
    #[doc = " contain a valid timestamp offset."]
    #[doc = ""]
    #[doc = " Note that the timestamp of sync point has usually a nonzero"]
    #[doc = " dts_ref_dts_delta, which refers to the previous sync point. Offset of"]
    #[doc = " the next frame after timestamp sync point will be usually 1."]
    #[doc = ""]
    #[doc = " For example, this corresponds to H.264 cpb_removal_delay."]
    pub dts_ref_dts_delta: libc::c_int,
    #[doc = " Presentation delay of current frame in units of AVCodecContext.time_base."]
    #[doc = ""]
    #[doc = " Set to INT_MIN when dts_sync_point unused. Otherwise, it must"]
    #[doc = " contain valid non-negative timestamp delta (presentation time of a frame"]
    #[doc = " must not lie in the past)."]
    #[doc = ""]
    #[doc = " This delay represents the difference between decoding and presentation"]
    #[doc = " time of the frame."]
    #[doc = ""]
    #[doc = " For example, this corresponds to H.264 dpb_output_delay."]
    pub pts_dts_delta: libc::c_int,
    #[doc = " Position of the packet in file."]
    #[doc = ""]
    #[doc = " Analogous to cur_frame_pts/dts"]
    pub cur_frame_pos: [i64; 4usize],
    #[doc = " Byte position of currently parsed frame in stream."]
    pub pos: i64,
    #[doc = " Previous frame byte position."]
    pub last_pos: i64,
    #[doc = " Duration of the current frame."]
    #[doc = " For audio, this is in units of 1 / AVCodecContext.sample_rate."]
    #[doc = " For all other types, this is in units of AVCodecContext.time_base."]
    pub duration: libc::c_int,
    pub field_order: AVFieldOrder,
    #[doc = " Indicate whether a picture is coded as a frame, top field or bottom field."]
    #[doc = ""]
    #[doc = " For example, H.264 field_pic_flag equal to 0 corresponds to"]
    #[doc = " AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag"]
    #[doc = " equal to 1 and bottom_field_flag equal to 0 corresponds to"]
    #[doc = " AV_PICTURE_STRUCTURE_TOP_FIELD."]
    pub picture_structure: AVPictureStructure,
    #[doc = " Picture number incremented in presentation or output order."]
    #[doc = " This field may be reinitialized at the first picture of a new sequence."]
    #[doc = ""]
    #[doc = " For example, this corresponds to H.264 PicOrderCnt."]
    pub output_picture_number: libc::c_int,
    #[doc = " Dimensions of the decoded video intended for presentation."]
    pub width: libc::c_int,
    pub height: libc::c_int,
    #[doc = " Dimensions of the coded video."]
    pub coded_width: libc::c_int,
    pub coded_height: libc::c_int,
    #[doc = " The format of the coded data, corresponds to enum AVPixelFormat for video"]
    #[doc = " and for enum AVSampleFormat for audio."]
    #[doc = ""]
    #[doc = " Note that a decoder can have considerable freedom in how exactly it"]
    #[doc = " decodes the data, so the format reported here might be different from the"]
    #[doc = " one returned by a decoder."]
    pub format: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParserContext() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParserContext>(),
        336usize,
        concat!("Size of: ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).priv_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).parser as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).frame_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(frame_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).cur_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).next_frame_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(next_frame_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pict_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).repeat_pict as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pts as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).dts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_pts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_dts as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).fetch_timestamp as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(fetch_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_start_index as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_start_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_offset as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_pts as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_dts as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).flags as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).offset as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_end as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).key_frame as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).dts_sync_point as *const _ as usize
        },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_sync_point)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).dts_ref_dts_delta as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_ref_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).pts_dts_delta as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_pos as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pos as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_pos as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).duration as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).field_order as *const _ as usize
        },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).picture_structure as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).output_picture_number as *const _
                as usize
        },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(output_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).width as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).height as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).coded_width as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).coded_height as *const _ as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).format as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParser {
    pub codec_ids: [libc::c_int; 7usize],
    pub priv_data_size: libc::c_int,
    pub parser_init:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext) -> libc::c_int>,
    pub parser_parse: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut libc::c_int,
            buf: *const u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVCodecParser() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParser>(),
        64usize,
        concat!("Size of: ", stringify!(AVCodecParser))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParser>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).codec_ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).priv_data_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_init as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_parse as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_close as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).split as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(split)
        )
    );
}
extern "C" {
    #[doc = " Iterate over all registered codec parsers."]
    #[doc = ""]
    #[doc = " @param opaque a pointer where libavcodec will store the iteration state. Must"]
    #[doc = "               point to NULL to start the iteration."]
    #[doc = ""]
    #[doc = " @return the next registered codec parser or NULL when the iteration is"]
    #[doc = "         finished"]
    pub fn av_parser_iterate(opaque: *mut *mut libc::c_void) -> *const AVCodecParser;
}
extern "C" {
    pub fn av_parser_init(codec_id: libc::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    #[doc = " Parse a packet."]
    #[doc = ""]
    #[doc = " @param s             parser context."]
    #[doc = " @param avctx         codec context."]
    #[doc = " @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished."]
    #[doc = " @param poutbuf_size  set to size of parsed buffer or zero if not yet finished."]
    #[doc = " @param buf           input buffer."]
    #[doc = " @param buf_size      buffer size in bytes without the padding. I.e. the full buffer"]
    #[doc = "size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE."]
    #[doc = "To signal EOF, this should be 0 (so that the last frame"]
    #[doc = "can be output)."]
    #[doc = " @param pts           input presentation timestamp."]
    #[doc = " @param dts           input decoding timestamp."]
    #[doc = " @param pos           input byte position in stream."]
    #[doc = " @return the number of bytes of the input bitstream used."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = " @code"]
    #[doc = "   while(in_len){"]
    #[doc = "       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,"]
    #[doc = "                                        in_data, in_len,"]
    #[doc = "                                        pts, dts, pos);"]
    #[doc = "       in_data += len;"]
    #[doc = "       in_len  -= len;"]
    #[doc = ""]
    #[doc = "       if(size)"]
    #[doc = "          decode_frame(data, size);"]
    #[doc = "   }"]
    #[doc = " @endcode"]
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut libc::c_int,
        buf: *const u8,
        buf_size: libc::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    #[doc = " @addtogroup lavc_encoding"]
    #[doc = " @{"]
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: libc::c_int,
        sub: *const AVSubtitle,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a value representing the fourCC code associated to the"]
    #[doc = " pixel format pix_fmt, or 0 if no associated fourCC code can be"]
    #[doc = " found."]
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> libc::c_uint;
}
extern "C" {
    #[doc = " Find the best pixel format to convert to given a certain source pixel"]
    #[doc = " format.  When converting from one pixel format to another, information loss"]
    #[doc = " may occur.  For example, when converting from RGB24 to GRAY, the color"]
    #[doc = " information will be lost. Similarly, other losses occur when converting from"]
    #[doc = " some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of"]
    #[doc = " the given pixel formats should be used to suffer the least amount of loss."]
    #[doc = " The pixel formats from which it chooses one, are determined by the"]
    #[doc = " pix_fmt_list parameter."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from"]
    #[doc = " @param[in] src_pix_fmt source pixel format"]
    #[doc = " @param[in] has_alpha Whether the source pixel format alpha channel is used."]
    #[doc = " @param[out] loss_ptr Combination of flags informing you what kind of losses will occur."]
    #[doc = " @return The best pixel format to convert to or -1 if none was found."]
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " @}"]
    pub fn avcodec_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        enc: *mut AVCodecContext,
        encode: libc::c_int,
    );
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(c2: *mut AVCodecContext, arg2: *mut libc::c_void) -> libc::c_int,
        >,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        count: libc::c_int,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut libc::c_void,
                arg1: libc::c_int,
                arg2: libc::c_int,
            ) -> libc::c_int,
        >,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill AVFrame audio data and linesize pointers."]
    #[doc = ""]
    #[doc = " The buffer buf must be a preallocated buffer with a size big enough"]
    #[doc = " to contain the specified samples amount. The filled AVFrame data"]
    #[doc = " pointers will point to this buffer."]
    #[doc = ""]
    #[doc = " AVFrame extended_data channel pointers are allocated if necessary for"]
    #[doc = " planar audio."]
    #[doc = ""]
    #[doc = " @param frame       the AVFrame"]
    #[doc = "                    frame->nb_samples must be set prior to calling the"]
    #[doc = "                    function. This function fills in frame->data,"]
    #[doc = "                    frame->extended_data, frame->linesize[0]."]
    #[doc = " @param nb_channels channel count"]
    #[doc = " @param sample_fmt  sample format"]
    #[doc = " @param buf         buffer to use for frame data"]
    #[doc = " @param buf_size    size of buffer"]
    #[doc = " @param align       plane size sample alignment (0 = default)"]
    #[doc = " @return            >=0 on success, negative error code on failure"]
    #[doc = " @todo return the size in bytes required to store the samples in"]
    #[doc = " case of success, at the next libavutil bump"]
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Reset the internal codec state / flush internal buffers. Should be called"]
    #[doc = " e.g. when seeking or when switching to a different stream."]
    #[doc = ""]
    #[doc = " @note for decoders, this function just releases any references the decoder"]
    #[doc = " might keep internally, but the caller's references remain valid."]
    #[doc = ""]
    #[doc = " @note for encoders, this function will only do something if the encoder"]
    #[doc = " declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder"]
    #[doc = " will drain any remaining packets, and can then be re-used for a different"]
    #[doc = " stream (as opposed to sending a null frame which will leave the encoder"]
    #[doc = " in a permanent EOF state after draining). This can be desirable if the"]
    #[doc = " cost of tearing down and replacing the encoder instance is high."]
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    #[doc = " Return audio frame duration."]
    #[doc = ""]
    #[doc = " @param avctx        codec context"]
    #[doc = " @param frame_bytes  size of the frame, or 0 if unknown"]
    #[doc = " @return             frame duration, in samples, if known. 0 if not able to"]
    #[doc = "                     determine."]
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Same behaviour av_fast_malloc but the buffer has additional"]
    #[doc = " AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0."]
    #[doc = ""]
    #[doc = " In addition the whole buffer will initially and after resizes"]
    #[doc = " be 0-initialized so that no uninitialized data will ever appear."]
    pub fn av_fast_padded_malloc(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    #[doc = " Same behaviour av_fast_padded_malloc except that buffer will always"]
    #[doc = " be 0-initialized after call."]
    pub fn av_fast_padded_mallocz(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    #[doc = " @return a positive value if s is open (i.e. avcodec_open2() was called on it"]
    #[doc = " with no corresponding avcodec_close()), 0 otherwise."]
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDVProfile {
    pub dsf: libc::c_int,
    pub video_stype: libc::c_int,
    pub frame_size: libc::c_int,
    pub difseg_size: libc::c_int,
    pub n_difchan: libc::c_int,
    pub time_base: AVRational,
    pub ltc_divisor: libc::c_int,
    pub height: libc::c_int,
    pub width: libc::c_int,
    pub sar: [AVRational; 2usize],
    pub pix_fmt: AVPixelFormat,
    pub bpm: libc::c_int,
    pub block_sizes: *const u8,
    pub audio_stride: libc::c_int,
    pub audio_min_samples: [libc::c_int; 3usize],
    pub audio_samples_dist: [libc::c_int; 5usize],
    pub audio_shuffle: *const [u8; 9usize],
}
#[test]
fn bindgen_test_layout_AVDVProfile() {
    assert_eq!(
        ::std::mem::size_of::<AVDVProfile>(),
        120usize,
        concat!("Size of: ", stringify!(AVDVProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDVProfile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).dsf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(dsf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).video_stype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(video_stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).frame_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).difseg_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(difseg_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).n_difchan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(n_difchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).time_base as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).ltc_divisor as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(ltc_divisor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).width as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).sar as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(sar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).pix_fmt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).bpm as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(bpm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).block_sizes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(block_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_stride as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_min_samples as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_min_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_samples_dist as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_samples_dist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_shuffle as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_shuffle)
        )
    );
}
extern "C" {
    #[doc = " Get a DV profile for the provided compressed frame."]
    #[doc = ""]
    #[doc = " @param sys the profile used for the previous frame, may be NULL"]
    #[doc = " @param frame the compressed data buffer"]
    #[doc = " @param buf_size size of the buffer in bytes"]
    #[doc = " @return the DV profile for the supplied data or NULL on failure"]
    pub fn av_dv_frame_profile(
        sys: *const AVDVProfile,
        frame: *const u8,
        buf_size: libc::c_uint,
    ) -> *const AVDVProfile;
}
extern "C" {
    #[doc = " Get a DV profile for the provided stream parameters."]
    pub fn av_dv_codec_profile(
        width: libc::c_int,
        height: libc::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *const AVDVProfile;
}
extern "C" {
    #[doc = " Get a DV profile for the provided stream parameters."]
    #[doc = " The frame rate is used as a best-effort parameter."]
    pub fn av_dv_codec_profile2(
        width: libc::c_int,
        height: libc::c_int,
        pix_fmt: AVPixelFormat,
        frame_rate: AVRational,
    ) -> *const AVDVProfile;
}
#[doc = " @defgroup lavc_fft FFT functions"]
#[doc = " @ingroup lavc_misc"]
#[doc = ""]
#[doc = " @{"]
pub type FFTSample = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct FFTComplex {
    pub re: FFTSample,
    pub im: FFTSample,
}
#[test]
fn bindgen_test_layout_FFTComplex() {
    assert_eq!(
        ::std::mem::size_of::<FFTComplex>(),
        8usize,
        concat!("Size of: ", stringify!(FFTComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<FFTComplex>(),
        4usize,
        concat!("Alignment of ", stringify!(FFTComplex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FFTComplex>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTComplex),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FFTComplex>())).im as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTComplex),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a complex FFT."]
    #[doc = " @param nbits           log2 of the length of the input array"]
    #[doc = " @param inverse         if 0 perform the forward transform, if 1 perform the inverse"]
    pub fn av_fft_init(nbits: libc::c_int, inverse: libc::c_int) -> *mut FFTContext;
}
extern "C" {
    #[doc = " Do the permutation needed BEFORE calling ff_fft_calc()."]
    pub fn av_fft_permute(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    #[doc = " Do a complex FFT with the parameters defined in av_fft_init(). The"]
    #[doc = " input data must be permuted before. No 1.0/sqrt(n) normalization is done."]
    pub fn av_fft_calc(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    pub fn av_fft_end(s: *mut FFTContext);
}
extern "C" {
    pub fn av_mdct_init(nbits: libc::c_int, inverse: libc::c_int, scale: f64) -> *mut FFTContext;
}
extern "C" {
    pub fn av_imdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_imdct_half(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_end(s: *mut FFTContext);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RDFTransformType {
    DFT_R2C = 0,
    IDFT_C2R = 1,
    IDFT_R2C = 2,
    DFT_C2R = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RDFTContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a real FFT."]
    #[doc = " @param nbits           log2 of the length of the input array"]
    #[doc = " @param trans           the type of transform"]
    pub fn av_rdft_init(nbits: libc::c_int, trans: RDFTransformType) -> *mut RDFTContext;
}
extern "C" {
    pub fn av_rdft_calc(s: *mut RDFTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_rdft_end(s: *mut RDFTContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTContext {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DCTTransformType {
    DCT_II = 0,
    DCT_III = 1,
    DCT_I = 2,
    DST_I = 3,
}
extern "C" {
    #[doc = " Set up DCT."]
    #[doc = ""]
    #[doc = " @param nbits           size of the input array:"]
    #[doc = "                        (1 << nbits)     for DCT-II, DCT-III and DST-I"]
    #[doc = "                        (1 << nbits) + 1 for DCT-I"]
    #[doc = " @param type            the type of transform"]
    #[doc = ""]
    #[doc = " @note the first element of the input of DST-I is ignored"]
    pub fn av_dct_init(nbits: libc::c_int, type_: DCTTransformType) -> *mut DCTContext;
}
extern "C" {
    pub fn av_dct_calc(s: *mut DCTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_dct_end(s: *mut DCTContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVorbisParseContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize the Vorbis parser using headers in the extradata."]
    pub fn av_vorbis_parse_init(
        extradata: *const u8,
        extradata_size: libc::c_int,
    ) -> *mut AVVorbisParseContext;
}
extern "C" {
    #[doc = " Free the parser and everything associated with it."]
    pub fn av_vorbis_parse_free(s: *mut *mut AVVorbisParseContext);
}
extern "C" {
    #[doc = " Get the duration for a Vorbis packet."]
    #[doc = ""]
    #[doc = " If @p flags is @c NULL,"]
    #[doc = " special frames are considered invalid."]
    #[doc = ""]
    #[doc = " @param s        Vorbis parser context"]
    #[doc = " @param buf      buffer containing a Vorbis frame"]
    #[doc = " @param buf_size size of the buffer"]
    #[doc = " @param flags    flags for special frames"]
    pub fn av_vorbis_parse_frame_flags(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: libc::c_int,
        flags: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the duration for a Vorbis packet."]
    #[doc = ""]
    #[doc = " @param s        Vorbis parser context"]
    #[doc = " @param buf      buffer containing a Vorbis frame"]
    #[doc = " @param buf_size size of the buffer"]
    pub fn av_vorbis_parse_frame(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_vorbis_parse_reset(s: *mut AVVorbisParseContext);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVOptionType {
    AV_OPT_TYPE_FLAGS = 0,
    AV_OPT_TYPE_INT = 1,
    AV_OPT_TYPE_INT64 = 2,
    AV_OPT_TYPE_DOUBLE = 3,
    AV_OPT_TYPE_FLOAT = 4,
    AV_OPT_TYPE_STRING = 5,
    AV_OPT_TYPE_RATIONAL = 6,
    AV_OPT_TYPE_BINARY = 7,
    AV_OPT_TYPE_DICT = 8,
    AV_OPT_TYPE_UINT64 = 9,
    AV_OPT_TYPE_CONST = 10,
    AV_OPT_TYPE_IMAGE_SIZE = 11,
    AV_OPT_TYPE_PIXEL_FMT = 12,
    AV_OPT_TYPE_SAMPLE_FMT = 13,
    AV_OPT_TYPE_VIDEO_RATE = 14,
    AV_OPT_TYPE_DURATION = 15,
    AV_OPT_TYPE_COLOR = 16,
    AV_OPT_TYPE_CHANNEL_LAYOUT = 17,
    AV_OPT_TYPE_BOOL = 18,
    AV_OPT_TYPE_CHLAYOUT = 19,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVOption {
    pub name: *const libc::c_char,
    pub help: *const libc::c_char,
    pub offset: libc::c_int,
    pub type_: AVOptionType,
    pub default_val: AVOption__bindgen_ty_1,
    pub min: f64,
    pub max: f64,
    pub flags: libc::c_int,
    pub unit: *const libc::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVOption__bindgen_ty_1 {
    pub i64_: i64,
    pub dbl: f64,
    pub str_: *const libc::c_char,
    pub q: AVRational,
}
#[test]
fn bindgen_test_layout_AVOption__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).i64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).dbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(dbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(q)
        )
    );
}
#[test]
fn bindgen_test_layout_AVOption() {
    assert_eq!(
        ::std::mem::size_of::<AVOption>(),
        64usize,
        concat!("Size of: ", stringify!(AVOption))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOption>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).help as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).default_val as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(default_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).unit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(unit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVOptionRange {
    pub str_: *const libc::c_char,
    pub value_min: f64,
    pub value_max: f64,
    pub component_min: f64,
    pub component_max: f64,
    pub is_range: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRange() {
    assert_eq!(
        ::std::mem::size_of::<AVOptionRange>(),
        48usize,
        concat!("Size of: ", stringify!(AVOptionRange))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOptionRange>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).value_min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).value_max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).component_min as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).component_max as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).is_range as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(is_range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVOptionRanges {
    pub range: *mut *mut AVOptionRange,
    pub nb_ranges: libc::c_int,
    pub nb_components: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRanges() {
    assert_eq!(
        ::std::mem::size_of::<AVOptionRanges>(),
        16usize,
        concat!("Size of: ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOptionRanges>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRanges>())).range as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRanges>())).nb_ranges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_ranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRanges>())).nb_components as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_components)
        )
    );
}
extern "C" {
    pub fn av_opt_show2(
        obj: *mut libc::c_void,
        av_log_obj: *mut libc::c_void,
        req_flags: libc::c_int,
        rej_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_defaults(s: *mut libc::c_void);
}
extern "C" {
    pub fn av_opt_set_defaults2(s: *mut libc::c_void, mask: libc::c_int, flags: libc::c_int);
}
extern "C" {
    pub fn av_set_options_string(
        ctx: *mut libc::c_void,
        opts: *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_from_string(
        ctx: *mut libc::c_void,
        opts: *const libc::c_char,
        shorthand: *const *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_free(obj: *mut libc::c_void);
}
extern "C" {
    pub fn av_opt_flag_is_set(
        obj: *mut libc::c_void,
        field_name: *const libc::c_char,
        flag_name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_dict(obj: *mut libc::c_void, options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_dict2(
        obj: *mut libc::c_void,
        options: *mut *mut AVDictionary,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_key_value(
        ropts: *mut *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
        flags: libc::c_uint,
        rkey: *mut *mut libc::c_char,
        rval: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
pub const AV_OPT_FLAG_IMPLICIT_KEY: _bindgen_ty_5 = _bindgen_ty_5::AV_OPT_FLAG_IMPLICIT_KEY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    AV_OPT_FLAG_IMPLICIT_KEY = 1,
}
extern "C" {
    pub fn av_opt_eval_flags(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        flags_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        int_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int64(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        int64_out: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_float(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        float_out: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_double(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        double_out: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_q(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        q_out: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_find(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        unit: *const libc::c_char,
        opt_flags: libc::c_int,
        search_flags: libc::c_int,
    ) -> *const AVOption;
}
extern "C" {
    pub fn av_opt_find2(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        unit: *const libc::c_char,
        opt_flags: libc::c_int,
        search_flags: libc::c_int,
        target_obj: *mut *mut libc::c_void,
    ) -> *const AVOption;
}
extern "C" {
    pub fn av_opt_next(obj: *const libc::c_void, prev: *const AVOption) -> *const AVOption;
}
extern "C" {
    pub fn av_opt_child_next(obj: *mut libc::c_void, prev: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_opt_child_class_iterate(
        parent: *const AVClass,
        iter: *mut *mut libc::c_void,
    ) -> *const AVClass;
}
extern "C" {
    pub fn av_opt_set(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const libc::c_char,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_int(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: i64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_double(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: f64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_q(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: AVRational,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_bin(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const u8,
        size: libc::c_int,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_image_size(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        w: libc::c_int,
        h: libc::c_int,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_pixel_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        fmt: AVPixelFormat,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_sample_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        fmt: AVSampleFormat,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_video_rate(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: AVRational,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_channel_layout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        ch_layout: i64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_chlayout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        layout: *const AVChannelLayout,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_dict_val(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const AVDictionary,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut *mut u8,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_int(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_double(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_q(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_image_size(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        w_out: *mut libc::c_int,
        h_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_pixel_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_fmt: *mut AVPixelFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_sample_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_fmt: *mut AVSampleFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_video_rate(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_channel_layout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        ch_layout: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_chlayout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        layout: *mut AVChannelLayout,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_dict_val(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_ptr(
        avclass: *const AVClass,
        obj: *mut libc::c_void,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_opt_freep_ranges(ranges: *mut *mut AVOptionRanges);
}
extern "C" {
    pub fn av_opt_query_ranges(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut libc::c_void,
        key: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_copy(dest: *mut libc::c_void, src: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_query_ranges_default(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut libc::c_void,
        key: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_is_set_to_default(obj: *mut libc::c_void, o: *const AVOption) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_is_set_to_default_by_name(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_serialize(
        obj: *mut libc::c_void,
        opt_flags: libc::c_int,
        flags: libc::c_int,
        buffer: *mut *mut libc::c_char,
        key_val_sep: libc::c_char,
        pairs_sep: libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: libc::c_int;
}
extern "C" {
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIOInterruptCB {
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    pub opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_AVIOInterruptCB() {
    assert_eq!(
        ::std::mem::size_of::<AVIOInterruptCB>(),
        16usize,
        concat!("Size of: ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIOInterruptCB>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOInterruptCB>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOInterruptCB>())).opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVIODirEntryType {
    AVIO_ENTRY_UNKNOWN = 0,
    AVIO_ENTRY_BLOCK_DEVICE = 1,
    AVIO_ENTRY_CHARACTER_DEVICE = 2,
    AVIO_ENTRY_DIRECTORY = 3,
    AVIO_ENTRY_NAMED_PIPE = 4,
    AVIO_ENTRY_SYMBOLIC_LINK = 5,
    AVIO_ENTRY_SOCKET = 6,
    AVIO_ENTRY_FILE = 7,
    AVIO_ENTRY_SERVER = 8,
    AVIO_ENTRY_SHARE = 9,
    AVIO_ENTRY_WORKGROUP = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIODirEntry {
    pub name: *mut libc::c_char,
    pub type_: libc::c_int,
    pub utf8: libc::c_int,
    pub size: i64,
    pub modification_timestamp: i64,
    pub access_timestamp: i64,
    pub status_change_timestamp: i64,
    pub user_id: i64,
    pub group_id: i64,
    pub filemode: i64,
}
#[test]
fn bindgen_test_layout_AVIODirEntry() {
    assert_eq!(
        ::std::mem::size_of::<AVIODirEntry>(),
        72usize,
        concat!("Size of: ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIODirEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).utf8 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(utf8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVIODirEntry>())).modification_timestamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(modification_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).access_timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(access_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVIODirEntry>())).status_change_timestamp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(status_change_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).user_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(user_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).group_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).filemode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(filemode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[test]
fn bindgen_test_layout_AVIODirContext() {
    assert_eq!(
        ::std::mem::size_of::<AVIODirContext>(),
        8usize,
        concat!("Size of: ", stringify!(AVIODirContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIODirContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirContext>())).url_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirContext),
            "::",
            stringify!(url_context)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVIODataMarkerType {
    AVIO_DATA_MARKER_HEADER = 0,
    AVIO_DATA_MARKER_SYNC_POINT = 1,
    AVIO_DATA_MARKER_BOUNDARY_POINT = 2,
    AVIO_DATA_MARKER_UNKNOWN = 3,
    AVIO_DATA_MARKER_TRAILER = 4,
    AVIO_DATA_MARKER_FLUSH_POINT = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIOContext {
    pub av_class: *const AVClass,
    pub buffer: *mut libc::c_uchar,
    pub buffer_size: libc::c_int,
    pub buf_ptr: *mut libc::c_uchar,
    pub buf_end: *mut libc::c_uchar,
    pub opaque: *mut libc::c_void,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            buf: *mut u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            buf: *mut u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, offset: i64, whence: libc::c_int) -> i64,
    >,
    pub pos: i64,
    pub eof_reached: libc::c_int,
    pub error: libc::c_int,
    pub write_flag: libc::c_int,
    pub max_packet_size: libc::c_int,
    pub min_packet_size: libc::c_int,
    pub checksum: libc::c_ulong,
    pub checksum_ptr: *mut libc::c_uchar,
    pub update_checksum: ::std::option::Option<
        unsafe extern "C" fn(
            checksum: libc::c_ulong,
            buf: *const u8,
            size: libc::c_uint,
        ) -> libc::c_ulong,
    >,
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, pause: libc::c_int) -> libc::c_int,
    >,
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            stream_index: libc::c_int,
            timestamp: i64,
            flags: libc::c_int,
        ) -> i64,
    >,
    pub seekable: libc::c_int,
    pub direct: libc::c_int,
    pub protocol_whitelist: *const libc::c_char,
    pub protocol_blacklist: *const libc::c_char,
    pub write_data_type: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            buf: *mut u8,
            buf_size: libc::c_int,
            type_: AVIODataMarkerType,
            time: i64,
        ) -> libc::c_int,
    >,
    pub ignore_boundary_point: libc::c_int,
    pub written: i64,
    pub buf_ptr_max: *mut libc::c_uchar,
    pub bytes_read: i64,
    pub bytes_written: i64,
}
#[test]
fn bindgen_test_layout_AVIOContext() {
    assert_eq!(
        ::std::mem::size_of::<AVIOContext>(),
        216usize,
        concat!("Size of: ", stringify!(AVIOContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIOContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buf_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buf_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).opaque as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).read_packet as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).write_packet as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).seek as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).eof_reached as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(eof_reached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).error as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).write_flag as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).max_packet_size as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(max_packet_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).min_packet_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(min_packet_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).checksum as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).checksum_ptr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).update_checksum as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(update_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).read_pause as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).read_seek as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).seekable as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seekable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).direct as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(direct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).protocol_whitelist as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).protocol_blacklist as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).write_data_type as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_data_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVIOContext>())).ignore_boundary_point as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(ignore_boundary_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).written as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buf_ptr_max as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).bytes_read as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(bytes_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).bytes_written as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(bytes_written)
        )
    );
}
extern "C" {
    pub fn avio_find_protocol_name(url: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn avio_check(url: *const libc::c_char, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn avio_open_dir(
        s: *mut *mut AVIODirContext,
        url: *const libc::c_char,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_read_dir(s: *mut AVIODirContext, next: *mut *mut AVIODirEntry) -> libc::c_int;
}
extern "C" {
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    pub fn avio_alloc_context(
        buffer: *mut libc::c_uchar,
        buffer_size: libc::c_int,
        write_flag: libc::c_int,
        opaque: *mut libc::c_void,
        read_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut libc::c_void,
                buf: *mut u8,
                buf_size: libc::c_int,
            ) -> libc::c_int,
        >,
        write_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut libc::c_void,
                buf: *mut u8,
                buf_size: libc::c_int,
            ) -> libc::c_int,
        >,
        seek: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut libc::c_void,
                offset: i64,
                whence: libc::c_int,
            ) -> i64,
        >,
    ) -> *mut AVIOContext;
}
extern "C" {
    pub fn avio_context_free(s: *mut *mut AVIOContext);
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: libc::c_int);
}
extern "C" {
    pub fn avio_write(s: *mut AVIOContext, buf: *const libc::c_uchar, size: libc::c_int);
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_put_str(s: *mut AVIOContext, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn avio_put_str16le(s: *mut AVIOContext, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn avio_put_str16be(s: *mut AVIOContext, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64, type_: AVIODataMarkerType);
}
extern "C" {
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: libc::c_int) -> i64;
}
extern "C" {
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    pub fn avio_feof(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_vprintf(
        s: *mut AVIOContext,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_printf(s: *mut AVIOContext, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn avio_print_string_array(s: *mut AVIOContext, strings: *mut *const libc::c_char);
}
extern "C" {
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    pub fn avio_read(
        s: *mut AVIOContext,
        buf: *mut libc::c_uchar,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_read_partial(
        s: *mut AVIOContext,
        buf: *mut libc::c_uchar,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_r8(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_get_str(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_get_str16le(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_get_str16be(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_open(
        s: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_open2(
        s: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_close(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_closep(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> libc::c_int;
}
extern "C" {
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> libc::c_int;
}
extern "C" {
    pub fn avio_enum_protocols(
        opaque: *mut *mut libc::c_void,
        output: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn avio_protocol_get_class(name: *const libc::c_char) -> *const AVClass;
}
extern "C" {
    pub fn avio_pause(h: *mut AVIOContext, pause: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn avio_seek_time(
        h: *mut AVIOContext,
        stream_index: libc::c_int,
        timestamp: i64,
        flags: libc::c_int,
    ) -> i64;
}
extern "C" {
    pub fn avio_read_to_bprint(
        h: *mut AVIOContext,
        pb: *mut AVBPrint,
        max_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_handshake(c: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn av_get_packet(s: *mut AVIOContext, pkt: *mut AVPacket, size: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    pub fn av_append_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: libc::c_int,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProbeData {
    pub filename: *const libc::c_char,
    pub buf: *mut libc::c_uchar,
    pub buf_size: libc::c_int,
    pub mime_type: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVProbeData() {
    assert_eq!(
        ::std::mem::size_of::<AVProbeData>(),
        32usize,
        concat!("Size of: ", stringify!(AVProbeData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProbeData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProbeData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).filename as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).buf_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).mime_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(mime_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVOutputFormat {
    pub name: *const libc::c_char,
    pub long_name: *const libc::c_char,
    pub mime_type: *const libc::c_char,
    pub extensions: *const libc::c_char,
    pub audio_codec: AVCodecID,
    pub video_codec: AVCodecID,
    pub subtitle_codec: AVCodecID,
    pub flags: libc::c_int,
    pub codec_tag: *const *const AVCodecTag,
    pub priv_class: *const AVClass,
    pub priv_data_size: libc::c_int,
    pub flags_internal: libc::c_int,
    pub write_header:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    pub write_trailer:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    pub interleave_packet: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pkt: *mut AVPacket,
            flush: libc::c_int,
            has_packet: libc::c_int,
        ) -> libc::c_int,
    >,
    pub query_codec: ::std::option::Option<
        unsafe extern "C" fn(id: AVCodecID, std_compliance: libc::c_int) -> libc::c_int,
    >,
    pub get_output_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream: libc::c_int,
            dts: *mut i64,
            wall: *mut i64,
        ),
    >,
    pub control_message: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            type_: libc::c_int,
            data: *mut libc::c_void,
            data_size: usize,
        ) -> libc::c_int,
    >,
    pub write_uncoded_frame: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: libc::c_int,
            frame: *mut *mut AVFrame,
            flags: libc::c_uint,
        ) -> libc::c_int,
    >,
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> libc::c_int,
    >,
    pub data_codec: AVCodecID,
    pub init:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    pub deinit: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext)>,
    pub check_bitstream: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            st: *mut AVStream,
            pkt: *const AVPacket,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVOutputFormat() {
    assert_eq!(
        ::std::mem::size_of::<AVOutputFormat>(),
        176usize,
        concat!("Size of: ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOutputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).mime_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).extensions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).audio_codec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).video_codec as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).subtitle_codec as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).codec_tag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).priv_class as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).priv_data_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).flags_internal as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(flags_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).write_header as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).write_packet as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).write_trailer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_trailer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).interleave_packet as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(interleave_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).query_codec as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(query_codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).get_output_timestamp as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(get_output_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).control_message as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(control_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).write_uncoded_frame as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_uncoded_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).get_device_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(get_device_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).data_codec as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(data_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).init as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).deinit as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).check_bitstream as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(check_bitstream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVInputFormat {
    pub name: *const libc::c_char,
    pub long_name: *const libc::c_char,
    pub flags: libc::c_int,
    pub extensions: *const libc::c_char,
    pub codec_tag: *const *const AVCodecTag,
    pub priv_class: *const AVClass,
    pub mime_type: *const libc::c_char,
    pub raw_codec_id: libc::c_int,
    pub priv_data_size: libc::c_int,
    pub flags_internal: libc::c_int,
    pub read_probe:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const AVProbeData) -> libc::c_int>,
    pub read_header:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    pub read_close:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: libc::c_int,
            timestamp: i64,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    pub read_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: libc::c_int,
            pos: *mut i64,
            pos_limit: i64,
        ) -> i64,
    >,
    pub read_play:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    pub read_pause:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    pub read_seek2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: libc::c_int,
            min_ts: i64,
            ts: i64,
            max_ts: i64,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVInputFormat() {
    assert_eq!(
        ::std::mem::size_of::<AVInputFormat>(),
        152usize,
        concat!("Size of: ", stringify!(AVInputFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<AVInputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVInputFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).extensions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).codec_tag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).priv_class as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).mime_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).raw_codec_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(raw_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).priv_data_size as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).flags_internal as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(flags_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_probe as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_header as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_packet as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_close as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_seek as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_timestamp as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_play as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_play)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_pause as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_seek2 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).get_device_list as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(get_device_list)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVStreamParseType {
    AVSTREAM_PARSE_NONE = 0,
    AVSTREAM_PARSE_FULL = 1,
    AVSTREAM_PARSE_HEADERS = 2,
    AVSTREAM_PARSE_TIMESTAMPS = 3,
    AVSTREAM_PARSE_FULL_ONCE = 4,
    AVSTREAM_PARSE_FULL_RAW = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIndexEntry {
    pub pos: i64,
    pub timestamp: i64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub min_distance: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVIndexEntry() {
    assert_eq!(
        ::std::mem::size_of::<AVIndexEntry>(),
        24usize,
        concat!("Size of: ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIndexEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIndexEntry>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIndexEntry>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIndexEntry>())).min_distance as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(min_distance)
        )
    );
}
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: libc::c_int,
        size: libc::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn av_disposition_from_string(disp: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn av_disposition_to_string(disposition: libc::c_int) -> *const libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVStream {
    pub index: libc::c_int,
    pub id: libc::c_int,
    pub priv_data: *mut libc::c_void,
    pub time_base: AVRational,
    pub start_time: i64,
    pub duration: i64,
    pub nb_frames: i64,
    pub disposition: libc::c_int,
    pub discard: AVDiscard,
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    pub avg_frame_rate: AVRational,
    pub attached_pic: AVPacket,
    pub side_data: *mut AVPacketSideData,
    pub nb_side_data: libc::c_int,
    pub event_flags: libc::c_int,
    pub r_frame_rate: AVRational,
    pub codecpar: *mut AVCodecParameters,
    pub pts_wrap_bits: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVStream() {
    assert_eq!(
        ::std::mem::size_of::<AVStream>(),
        224usize,
        concat!("Size of: ", stringify!(AVStream))
    );
    assert_eq!(
        ::std::mem::align_of::<AVStream>(),
        8usize,
        concat!("Alignment of ", stringify!(AVStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).priv_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).time_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).start_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).duration as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).nb_frames as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).disposition as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(disposition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).discard as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).sample_aspect_ratio as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).metadata as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).avg_frame_rate as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(avg_frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).attached_pic as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(attached_pic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).side_data as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).nb_side_data as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).event_flags as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).r_frame_rate as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(r_frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).codecpar as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codecpar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).pts_wrap_bits as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_bits)
        )
    );
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream) -> *mut AVCodecParserContext;
}
extern "C" {
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
extern "C" {
    pub fn av_stream_get_first_dts(st: *const AVStream) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProgram {
    pub id: libc::c_int,
    pub flags: libc::c_int,
    pub discard: AVDiscard,
    pub stream_index: *mut libc::c_uint,
    pub nb_stream_indexes: libc::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: libc::c_int,
    pub pmt_pid: libc::c_int,
    pub pcr_pid: libc::c_int,
    pub pmt_version: libc::c_int,
    pub start_time: i64,
    pub end_time: i64,
    pub pts_wrap_reference: i64,
    pub pts_wrap_behavior: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVProgram() {
    assert_eq!(
        ::std::mem::size_of::<AVProgram>(),
        88usize,
        concat!("Size of: ", stringify!(AVProgram))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProgram>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProgram))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).discard as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).stream_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).nb_stream_indexes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(nb_stream_indexes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).metadata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).program_num as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(program_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pmt_pid as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pmt_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pcr_pid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pcr_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pmt_version as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pmt_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).start_time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).end_time as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(end_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pts_wrap_reference as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pts_wrap_behavior as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVChapter {
    pub id: i64,
    pub time_base: AVRational,
    pub start: i64,
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[test]
fn bindgen_test_layout_AVChapter() {
    assert_eq!(
        ::std::mem::size_of::<AVChapter>(),
        40usize,
        concat!("Size of: ", stringify!(AVChapter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChapter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChapter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).time_base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).metadata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(metadata)
        )
    );
}
pub type av_format_control_message = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        type_: libc::c_int,
        data: *mut libc::c_void,
        data_size: usize,
    ) -> libc::c_int,
>;
pub type AVOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        pb: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int,
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDurationEstimationMethod {
    AVFMT_DURATION_FROM_PTS = 0,
    AVFMT_DURATION_FROM_STREAM = 1,
    AVFMT_DURATION_FROM_BITRATE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFormatContext {
    pub av_class: *const AVClass,
    pub iformat: *const AVInputFormat,
    pub oformat: *const AVOutputFormat,
    pub priv_data: *mut libc::c_void,
    pub pb: *mut AVIOContext,
    pub ctx_flags: libc::c_int,
    pub nb_streams: libc::c_uint,
    pub streams: *mut *mut AVStream,
    pub url: *mut libc::c_char,
    pub start_time: i64,
    pub duration: i64,
    pub bit_rate: i64,
    pub packet_size: libc::c_uint,
    pub max_delay: libc::c_int,
    pub flags: libc::c_int,
    pub probesize: i64,
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: libc::c_int,
    pub nb_programs: libc::c_uint,
    pub programs: *mut *mut AVProgram,
    pub video_codec_id: AVCodecID,
    pub audio_codec_id: AVCodecID,
    pub subtitle_codec_id: AVCodecID,
    pub max_index_size: libc::c_uint,
    pub max_picture_buffer: libc::c_uint,
    pub nb_chapters: libc::c_uint,
    pub chapters: *mut *mut AVChapter,
    pub metadata: *mut AVDictionary,
    pub start_time_realtime: i64,
    pub fps_probe_size: libc::c_int,
    pub error_recognition: libc::c_int,
    pub interrupt_callback: AVIOInterruptCB,
    pub debug: libc::c_int,
    pub max_interleave_delta: i64,
    pub strict_std_compliance: libc::c_int,
    pub event_flags: libc::c_int,
    pub max_ts_probe: libc::c_int,
    pub avoid_negative_ts: libc::c_int,
    pub ts_id: libc::c_int,
    pub audio_preload: libc::c_int,
    pub max_chunk_duration: libc::c_int,
    pub max_chunk_size: libc::c_int,
    pub use_wallclock_as_timestamps: libc::c_int,
    pub avio_flags: libc::c_int,
    pub duration_estimation_method: AVDurationEstimationMethod,
    pub skip_initial_bytes: i64,
    pub correct_ts_overflow: libc::c_uint,
    pub seek2any: libc::c_int,
    pub flush_packets: libc::c_int,
    pub probe_score: libc::c_int,
    pub format_probesize: libc::c_int,
    pub codec_whitelist: *mut libc::c_char,
    pub format_whitelist: *mut libc::c_char,
    pub io_repositioned: libc::c_int,
    pub video_codec: *const AVCodec,
    pub audio_codec: *const AVCodec,
    pub subtitle_codec: *const AVCodec,
    pub data_codec: *const AVCodec,
    pub metadata_header_padding: libc::c_int,
    pub opaque: *mut libc::c_void,
    pub control_message_cb: av_format_control_message,
    pub output_ts_offset: i64,
    pub dump_separator: *mut u8,
    pub data_codec_id: AVCodecID,
    pub protocol_whitelist: *mut libc::c_char,
    pub io_open: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut *mut AVIOContext,
            url: *const libc::c_char,
            flags: libc::c_int,
            options: *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    pub io_close:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext)>,
    pub protocol_blacklist: *mut libc::c_char,
    pub max_streams: libc::c_int,
    pub skip_estimate_duration_from_pts: libc::c_int,
    pub max_probe_packets: libc::c_int,
    pub io_close2: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVFormatContext() {
    assert_eq!(
        ::std::mem::size_of::<AVFormatContext>(),
        472usize,
        concat!("Size of: ", stringify!(AVFormatContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFormatContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFormatContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).iformat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(iformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).oformat as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(oformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).priv_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).pb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(pb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).ctx_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ctx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).nb_streams as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_streams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).streams as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(streams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).url as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).start_time as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).duration as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).bit_rate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).packet_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(packet_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_delay as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).flags as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).probesize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_analyze_duration as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_analyze_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).key as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).keylen as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).nb_programs as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_programs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).programs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(programs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).video_codec_id as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).audio_codec_id as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).subtitle_codec_id as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_index_size as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_index_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_picture_buffer as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_picture_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).nb_chapters as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_chapters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).chapters as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(chapters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).metadata as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).start_time_realtime as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time_realtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).fps_probe_size as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(fps_probe_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).error_recognition as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(error_recognition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).interrupt_callback as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(interrupt_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).debug as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_interleave_delta as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_interleave_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).strict_std_compliance as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).event_flags as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_ts_probe as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_ts_probe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).avoid_negative_ts as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avoid_negative_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).ts_id as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ts_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).audio_preload as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_preload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_chunk_duration as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_chunk_size as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).use_wallclock_as_timestamps as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(use_wallclock_as_timestamps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).avio_flags as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avio_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).duration_estimation_method as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration_estimation_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).skip_initial_bytes as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(skip_initial_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).correct_ts_overflow as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(correct_ts_overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).seek2any as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(seek2any)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).flush_packets as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flush_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).probe_score as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probe_score)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).format_probesize as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_probesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).codec_whitelist as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).format_whitelist as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).io_repositioned as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_repositioned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).video_codec as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).audio_codec as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).subtitle_codec as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).data_codec as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).metadata_header_padding as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata_header_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).opaque as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).control_message_cb as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(control_message_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).output_ts_offset as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(output_ts_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).dump_separator as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).data_codec_id as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).protocol_whitelist as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).io_open as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).io_close as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).protocol_blacklist as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_streams as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_streams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).skip_estimate_duration_from_pts as *const _
                as usize
        },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(skip_estimate_duration_from_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_probe_packets as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_probe_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).io_close2 as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_close2)
        )
    );
}
extern "C" {
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    pub fn av_fmt_ctx_get_duration_estimation_method(
        ctx: *const AVFormatContext,
    ) -> AVDurationEstimationMethod;
}
extern "C" {
    pub fn avformat_version() -> libc::c_uint;
}
extern "C" {
    pub fn avformat_configuration() -> *const libc::c_char;
}
extern "C" {
    pub fn avformat_license() -> *const libc::c_char;
}
extern "C" {
    pub fn avformat_network_init() -> libc::c_int;
}
extern "C" {
    pub fn avformat_network_deinit() -> libc::c_int;
}
extern "C" {
    pub fn av_muxer_iterate(opaque: *mut *mut libc::c_void) -> *const AVOutputFormat;
}
extern "C" {
    pub fn av_demuxer_iterate(opaque: *mut *mut libc::c_void) -> *const AVInputFormat;
}
extern "C" {
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    pub fn av_stream_get_class() -> *const AVClass;
}
extern "C" {
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec) -> *mut AVStream;
}
extern "C" {
    pub fn av_stream_add_side_data(
        st: *mut AVStream,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_stream_new_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_stream_get_side_data(
        stream: *const AVStream,
        type_: AVPacketSideDataType,
        size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: libc::c_int) -> *mut AVProgram;
}
extern "C" {
    pub fn avformat_alloc_output_context2(
        ctx: *mut *mut AVFormatContext,
        oformat: *const AVOutputFormat,
        format_name: *const libc::c_char,
        filename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_find_input_format(short_name: *const libc::c_char) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_format(
        pd: *const AVProbeData,
        is_opened: libc::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_format2(
        pd: *const AVProbeData,
        is_opened: libc::c_int,
        score_max: *mut libc::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_format3(
        pd: *const AVProbeData,
        is_opened: libc::c_int,
        score_ret: *mut libc::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_buffer2(
        pb: *mut AVIOContext,
        fmt: *mut *const AVInputFormat,
        url: *const libc::c_char,
        logctx: *mut libc::c_void,
        offset: libc::c_uint,
        max_probe_size: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_probe_input_buffer(
        pb: *mut AVIOContext,
        fmt: *mut *const AVInputFormat,
        url: *const libc::c_char,
        logctx: *mut libc::c_void,
        offset: libc::c_uint,
        max_probe_size: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const libc::c_char,
        fmt: *const AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_find_program_from_stream(
        ic: *mut AVFormatContext,
        last: *mut AVProgram,
        s: libc::c_int,
    ) -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(
        ac: *mut AVFormatContext,
        progid: libc::c_int,
        idx: libc::c_uint,
    );
}
extern "C" {
    pub fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_: AVMediaType,
        wanted_stream_nb: libc::c_int,
        related_stream: libc::c_int,
        decoder_ret: *mut *const AVCodec,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        timestamp: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_seek_file(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        min_ts: i64,
        ts: i64,
        max_ts: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_flush(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_read_play(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_read_pause(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    pub fn avformat_write_header(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_init_output(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_interleaved_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        frame: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_interleaved_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        frame: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_write_uncoded_frame_query(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_write_trailer(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_guess_format(
        short_name: *const libc::c_char,
        filename: *const libc::c_char,
        mime_type: *const libc::c_char,
    ) -> *const AVOutputFormat;
}
extern "C" {
    pub fn av_guess_codec(
        fmt: *const AVOutputFormat,
        short_name: *const libc::c_char,
        filename: *const libc::c_char,
        mime_type: *const libc::c_char,
        type_: AVMediaType,
    ) -> AVCodecID;
}
extern "C" {
    pub fn av_get_output_timestamp(
        s: *mut AVFormatContext,
        stream: libc::c_int,
        dts: *mut i64,
        wall: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: libc::c_int);
}
extern "C" {
    pub fn av_hex_dump_log(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        buf: *const u8,
        size: libc::c_int,
    );
}
extern "C" {
    pub fn av_pkt_dump2(
        f: *mut FILE,
        pkt: *const AVPacket,
        dump_payload: libc::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    pub fn av_pkt_dump_log2(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        pkt: *const AVPacket,
        dump_payload: libc::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    pub fn av_codec_get_id(tags: *const *const AVCodecTag, tag: libc::c_uint) -> AVCodecID;
}
extern "C" {
    pub fn av_codec_get_tag(tags: *const *const AVCodecTag, id: AVCodecID) -> libc::c_uint;
}
extern "C" {
    pub fn av_codec_get_tag2(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
        tag: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_index_search_timestamp(
        st: *mut AVStream,
        timestamp: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_index_get_entries_count(st: *const AVStream) -> libc::c_int;
}
extern "C" {
    pub fn avformat_index_get_entry(st: *mut AVStream, idx: libc::c_int) -> *const AVIndexEntry;
}
extern "C" {
    pub fn avformat_index_get_entry_from_timestamp(
        st: *mut AVStream,
        wanted_timestamp: i64,
        flags: libc::c_int,
    ) -> *const AVIndexEntry;
}
extern "C" {
    pub fn av_add_index_entry(
        st: *mut AVStream,
        pos: i64,
        timestamp: i64,
        size: libc::c_int,
        distance: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_url_split(
        proto: *mut libc::c_char,
        proto_size: libc::c_int,
        authorization: *mut libc::c_char,
        authorization_size: libc::c_int,
        hostname: *mut libc::c_char,
        hostname_size: libc::c_int,
        port_ptr: *mut libc::c_int,
        path: *mut libc::c_char,
        path_size: libc::c_int,
        url: *const libc::c_char,
    );
}
extern "C" {
    pub fn av_dump_format(
        ic: *mut AVFormatContext,
        index: libc::c_int,
        url: *const libc::c_char,
        is_output: libc::c_int,
    );
}
extern "C" {
    pub fn av_get_frame_filename2(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        path: *const libc::c_char,
        number: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        path: *const libc::c_char,
        number: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_filename_number_test(filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn av_sdp_create(
        ac: *mut *mut AVFormatContext,
        n_files: libc::c_int,
        buf: *mut libc::c_char,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_match_ext(
        filename: *const libc::c_char,
        extensions: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_query_codec(
        ofmt: *const AVOutputFormat,
        codec_id: AVCodecID,
        std_compliance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn av_guess_sample_aspect_ratio(
        format: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    pub fn av_guess_frame_rate(
        ctx: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    pub fn avformat_match_stream_specifier(
        s: *mut AVFormatContext,
        st: *mut AVStream,
        spec: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> libc::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVTimebaseSource {
    AVFMT_TBCF_AUTO = -1,
    AVFMT_TBCF_DECODER = 0,
    AVFMT_TBCF_DEMUXER = 1,
    AVFMT_TBCF_R_FRAMERATE = 2,
}
extern "C" {
    pub fn avformat_transfer_internal_stream_timing_info(
        ofmt: *const AVOutputFormat,
        ost: *mut AVStream,
        ist: *const AVStream,
        copy_tb: AVTimebaseSource,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
extern "C" {
    #[doc = " Return the LIBAVDEVICE_VERSION_INT constant."]
    pub fn avdevice_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the libavdevice build-time configuration."]
    pub fn avdevice_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libavdevice license."]
    pub fn avdevice_license() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Initialize libavdevice and register all the input and output devices."]
    pub fn avdevice_register_all();
}
extern "C" {
    #[doc = " Audio input devices iterator."]
    #[doc = ""]
    #[doc = " If d is NULL, returns the first registered input audio/video device,"]
    #[doc = " if d is non-NULL, returns the next registered input audio/video device after d"]
    #[doc = " or NULL if d is the last one."]
    pub fn av_input_audio_device_next(d: *const AVInputFormat) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Video input devices iterator."]
    #[doc = ""]
    #[doc = " If d is NULL, returns the first registered input audio/video device,"]
    #[doc = " if d is non-NULL, returns the next registered input audio/video device after d"]
    #[doc = " or NULL if d is the last one."]
    pub fn av_input_video_device_next(d: *const AVInputFormat) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Audio output devices iterator."]
    #[doc = ""]
    #[doc = " If d is NULL, returns the first registered output audio/video device,"]
    #[doc = " if d is non-NULL, returns the next registered output audio/video device after d"]
    #[doc = " or NULL if d is the last one."]
    pub fn av_output_audio_device_next(d: *const AVOutputFormat) -> *const AVOutputFormat;
}
extern "C" {
    #[doc = " Video output devices iterator."]
    #[doc = ""]
    #[doc = " If d is NULL, returns the first registered output audio/video device,"]
    #[doc = " if d is non-NULL, returns the next registered output audio/video device after d"]
    #[doc = " or NULL if d is the last one."]
    pub fn av_output_video_device_next(d: *const AVOutputFormat) -> *const AVOutputFormat;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceRect {
    #[doc = "< x coordinate of top left corner"]
    pub x: libc::c_int,
    #[doc = "< y coordinate of top left corner"]
    pub y: libc::c_int,
    #[doc = "< width"]
    pub width: libc::c_int,
    #[doc = "< height"]
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceRect() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceRect>(),
        16usize,
        concat!("Size of: ", stringify!(AVDeviceRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceRect>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDeviceRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(height)
        )
    );
}
#[repr(u32)]
#[doc = " Message types used by avdevice_app_to_dev_control_message()."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVAppToDevMessageType {
    #[doc = " Dummy message."]
    AV_APP_TO_DEV_NONE = 1313820229,
    #[doc = " Window size change message."]
    #[doc = ""]
    #[doc = " Message is sent to the device every time the application changes the size"]
    #[doc = " of the window device renders to."]
    #[doc = " Message should also be sent right after window is created."]
    #[doc = ""]
    #[doc = " data: AVDeviceRect: new window size."]
    AV_APP_TO_DEV_WINDOW_SIZE = 1195724621,
    #[doc = " Repaint request message."]
    #[doc = ""]
    #[doc = " Message is sent to the device when window has to be repainted."]
    #[doc = ""]
    #[doc = " data: AVDeviceRect: area required to be repainted."]
    #[doc = "       NULL: whole area is required to be repainted."]
    AV_APP_TO_DEV_WINDOW_REPAINT = 1380274241,
    #[doc = " Request pause/play."]
    #[doc = ""]
    #[doc = " Application requests pause/unpause playback."]
    #[doc = " Mostly usable with devices that have internal buffer."]
    #[doc = " By default devices are not paused."]
    #[doc = ""]
    #[doc = " data: NULL"]
    AV_APP_TO_DEV_PAUSE = 1346458912,
    #[doc = " Request pause/play."]
    #[doc = ""]
    #[doc = " Application requests pause/unpause playback."]
    #[doc = " Mostly usable with devices that have internal buffer."]
    #[doc = " By default devices are not paused."]
    #[doc = ""]
    #[doc = " data: NULL"]
    AV_APP_TO_DEV_PLAY = 1347174745,
    #[doc = " Request pause/play."]
    #[doc = ""]
    #[doc = " Application requests pause/unpause playback."]
    #[doc = " Mostly usable with devices that have internal buffer."]
    #[doc = " By default devices are not paused."]
    #[doc = ""]
    #[doc = " data: NULL"]
    AV_APP_TO_DEV_TOGGLE_PAUSE = 1346458964,
    #[doc = " Volume control message."]
    #[doc = ""]
    #[doc = " Set volume level. It may be device-dependent if volume"]
    #[doc = " is changed per stream or system wide. Per stream volume"]
    #[doc = " change is expected when possible."]
    #[doc = ""]
    #[doc = " data: double: new volume with range of 0.0 - 1.0."]
    AV_APP_TO_DEV_SET_VOLUME = 1398165324,
    #[doc = " Mute control messages."]
    #[doc = ""]
    #[doc = " Change mute state. It may be device-dependent if mute status"]
    #[doc = " is changed per stream or system wide. Per stream mute status"]
    #[doc = " change is expected when possible."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_APP_TO_DEV_MUTE = 541939028,
    #[doc = " Mute control messages."]
    #[doc = ""]
    #[doc = " Change mute state. It may be device-dependent if mute status"]
    #[doc = " is changed per stream or system wide. Per stream mute status"]
    #[doc = " change is expected when possible."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_APP_TO_DEV_UNMUTE = 1431131476,
    #[doc = " Mute control messages."]
    #[doc = ""]
    #[doc = " Change mute state. It may be device-dependent if mute status"]
    #[doc = " is changed per stream or system wide. Per stream mute status"]
    #[doc = " change is expected when possible."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_APP_TO_DEV_TOGGLE_MUTE = 1414354260,
    #[doc = " Get volume/mute messages."]
    #[doc = ""]
    #[doc = " Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or"]
    #[doc = " AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_APP_TO_DEV_GET_VOLUME = 1196838732,
    #[doc = " Get volume/mute messages."]
    #[doc = ""]
    #[doc = " Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or"]
    #[doc = " AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_APP_TO_DEV_GET_MUTE = 1196250452,
}
#[repr(u32)]
#[doc = " Message types used by avdevice_dev_to_app_control_message()."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDevToAppMessageType {
    #[doc = " Dummy message."]
    AV_DEV_TO_APP_NONE = 1313820229,
    #[doc = " Create window buffer message."]
    #[doc = ""]
    #[doc = " Device requests to create a window buffer. Exact meaning is device-"]
    #[doc = " and application-dependent. Message is sent before rendering first"]
    #[doc = " frame and all one-shot initializations should be done here."]
    #[doc = " Application is allowed to ignore preferred window buffer size."]
    #[doc = ""]
    #[doc = " @note: Application is obligated to inform about window buffer size"]
    #[doc = "        with AV_APP_TO_DEV_WINDOW_SIZE message."]
    #[doc = ""]
    #[doc = " data: AVDeviceRect: preferred size of the window buffer."]
    #[doc = "       NULL: no preferred size of the window buffer."]
    AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = 1111708229,
    #[doc = " Prepare window buffer message."]
    #[doc = ""]
    #[doc = " Device requests to prepare a window buffer for rendering."]
    #[doc = " Exact meaning is device- and application-dependent."]
    #[doc = " Message is sent before rendering of each frame."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = 1112560197,
    #[doc = " Display window buffer message."]
    #[doc = ""]
    #[doc = " Device requests to display a window buffer."]
    #[doc = " Message is sent when new frame is ready to be displayed."]
    #[doc = " Usually buffers need to be swapped in handler of this message."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = 1111771475,
    #[doc = " Destroy window buffer message."]
    #[doc = ""]
    #[doc = " Device requests to destroy a window buffer."]
    #[doc = " Message is sent when device is about to be destroyed and window"]
    #[doc = " buffer is not required anymore."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = 1111770451,
    #[doc = " Buffer fullness status messages."]
    #[doc = ""]
    #[doc = " Device signals buffer overflow/underflow."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_DEV_TO_APP_BUFFER_OVERFLOW = 1112491596,
    #[doc = " Buffer fullness status messages."]
    #[doc = ""]
    #[doc = " Device signals buffer overflow/underflow."]
    #[doc = ""]
    #[doc = " data: NULL."]
    AV_DEV_TO_APP_BUFFER_UNDERFLOW = 1112884812,
    #[doc = " Buffer readable/writable."]
    #[doc = ""]
    #[doc = " Device informs that buffer is readable/writable."]
    #[doc = " When possible, device informs how many bytes can be read/write."]
    #[doc = ""]
    #[doc = " @warning Device may not inform when number of bytes than can be read/write changes."]
    #[doc = ""]
    #[doc = " data: int64_t: amount of bytes available to read/write."]
    #[doc = "       NULL: amount of bytes available to read/write is not known."]
    AV_DEV_TO_APP_BUFFER_READABLE = 1112687648,
    #[doc = " Buffer readable/writable."]
    #[doc = ""]
    #[doc = " Device informs that buffer is readable/writable."]
    #[doc = " When possible, device informs how many bytes can be read/write."]
    #[doc = ""]
    #[doc = " @warning Device may not inform when number of bytes than can be read/write changes."]
    #[doc = ""]
    #[doc = " data: int64_t: amount of bytes available to read/write."]
    #[doc = "       NULL: amount of bytes available to read/write is not known."]
    AV_DEV_TO_APP_BUFFER_WRITABLE = 1113018912,
    #[doc = " Mute state change message."]
    #[doc = ""]
    #[doc = " Device informs that mute state has changed."]
    #[doc = ""]
    #[doc = " data: int: 0 for not muted state, non-zero for muted state."]
    AV_DEV_TO_APP_MUTE_STATE_CHANGED = 1129141588,
    #[doc = " Volume level change message."]
    #[doc = ""]
    #[doc = " Device informs that volume level has changed."]
    #[doc = ""]
    #[doc = " data: double: new volume with range of 0.0 - 1.0."]
    AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = 1129729868,
}
extern "C" {
    #[doc = " Send control message from application to device."]
    #[doc = ""]
    #[doc = " @param s         device context."]
    #[doc = " @param type      message type."]
    #[doc = " @param data      message data. Exact type depends on message type."]
    #[doc = " @param data_size size of message data."]
    #[doc = " @return >= 0 on success, negative on error."]
    #[doc = "         AVERROR(ENOSYS) when device doesn't implement handler of the message."]
    pub fn avdevice_app_to_dev_control_message(
        s: *mut AVFormatContext,
        type_: AVAppToDevMessageType,
        data: *mut libc::c_void,
        data_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Send control message from device to application."]
    #[doc = ""]
    #[doc = " @param s         device context."]
    #[doc = " @param type      message type."]
    #[doc = " @param data      message data. Can be NULL."]
    #[doc = " @param data_size size of message data."]
    #[doc = " @return >= 0 on success, negative on error."]
    #[doc = "         AVERROR(ENOSYS) when application doesn't implement handler of the message."]
    pub fn avdevice_dev_to_app_control_message(
        s: *mut AVFormatContext,
        type_: AVDevToAppMessageType,
        data: *mut libc::c_void,
        data_size: usize,
    ) -> libc::c_int;
}
#[doc = " Structure describes device capabilities."]
#[doc = ""]
#[doc = " It is used by devices in conjunction with av_device_capabilities AVOption table"]
#[doc = " to implement capabilities probing API based on AVOption API. Should not be used directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceCapabilitiesQuery {
    pub av_class: *const AVClass,
    pub device_context: *mut AVFormatContext,
    pub codec: AVCodecID,
    pub sample_format: AVSampleFormat,
    pub pixel_format: AVPixelFormat,
    pub sample_rate: libc::c_int,
    pub channels: libc::c_int,
    pub channel_layout: i64,
    pub window_width: libc::c_int,
    pub window_height: libc::c_int,
    pub frame_width: libc::c_int,
    pub frame_height: libc::c_int,
    pub fps: AVRational,
}
#[test]
fn bindgen_test_layout_AVDeviceCapabilitiesQuery() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceCapabilitiesQuery>(),
        72usize,
        concat!("Size of: ", stringify!(AVDeviceCapabilitiesQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceCapabilitiesQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceCapabilitiesQuery))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).av_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).device_context as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(device_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).codec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).sample_format as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(sample_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).pixel_format as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).sample_rate as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).channels as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).channel_layout as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).window_width as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(window_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).window_height as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(window_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).frame_width as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(frame_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).frame_height as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(frame_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).fps as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(fps)
        )
    );
}
extern "C" {
    #[doc = " AVOption table used by devices to implement device capabilities API. Should not be used by a user."]
    pub static mut av_device_capabilities: [AVOption; 0usize];
}
extern "C" {
    #[doc = " Initialize capabilities probing API based on AVOption API."]
    #[doc = ""]
    #[doc = " avdevice_capabilities_free() must be called when query capabilities API is"]
    #[doc = " not used anymore."]
    #[doc = ""]
    #[doc = " @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed."]
    #[doc = " @param s              Context of the device."]
    #[doc = " @param device_options An AVDictionary filled with device-private options."]
    #[doc = "                       On return this parameter will be destroyed and replaced with a dict"]
    #[doc = "                       containing options that were not found. May be NULL."]
    #[doc = "                       The same options must be passed later to avformat_write_header() for output"]
    #[doc = "                       devices or avformat_open_input() for input devices, or at any other place"]
    #[doc = "                       that affects device-private options."]
    #[doc = ""]
    #[doc = " @return >= 0 on success, negative otherwise."]
    pub fn avdevice_capabilities_create(
        caps: *mut *mut AVDeviceCapabilitiesQuery,
        s: *mut AVFormatContext,
        device_options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free resources created by avdevice_capabilities_create()"]
    #[doc = ""]
    #[doc = " @param caps Device capabilities data to be freed."]
    #[doc = " @param s    Context of the device."]
    pub fn avdevice_capabilities_free(
        caps: *mut *mut AVDeviceCapabilitiesQuery,
        s: *mut AVFormatContext,
    );
}
#[doc = " Structure describes basic parameters of the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceInfo {
    #[doc = "< device name, format depends on device"]
    pub device_name: *mut libc::c_char,
    #[doc = "< human friendly name"]
    pub device_description: *mut libc::c_char,
    #[doc = "< array indicating what media types(s), if any, a device can provide. If null, cannot provide any"]
    pub media_types: *mut AVMediaType,
    #[doc = "< length of media_types array, 0 if device cannot provide any media types"]
    pub nb_media_types: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceInfo() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceInfo>(),
        32usize,
        concat!("Size of: ", stringify!(AVDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfo>())).device_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(device_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfo>())).device_description as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(device_description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfo>())).media_types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(media_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfo>())).nb_media_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(nb_media_types)
        )
    );
}
#[doc = " List of devices."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceInfoList {
    #[doc = "< list of autodetected devices"]
    pub devices: *mut *mut AVDeviceInfo,
    #[doc = "< number of autodetected devices"]
    pub nb_devices: libc::c_int,
    #[doc = "< index of default device or -1 if no default"]
    pub default_device: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceInfoList() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(AVDeviceInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceInfoList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfoList>())).devices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfoList>())).nb_devices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(nb_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfoList>())).default_device as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(default_device)
        )
    );
}
extern "C" {
    #[doc = " List devices."]
    #[doc = ""]
    #[doc = " Returns available device names and their parameters."]
    #[doc = ""]
    #[doc = " @note: Some devices may accept system-dependent device names that cannot be"]
    #[doc = "        autodetected. The list returned by this function cannot be assumed to"]
    #[doc = "        be always completed."]
    #[doc = ""]
    #[doc = " @param s                device context."]
    #[doc = " @param[out] device_list list of autodetected devices."]
    #[doc = " @return count of autodetected devices, negative on error."]
    pub fn avdevice_list_devices(
        s: *mut AVFormatContext,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convenient function to free result of avdevice_list_devices()."]
    #[doc = ""]
    #[doc = " @param devices device list to be freed."]
    pub fn avdevice_free_list_devices(device_list: *mut *mut AVDeviceInfoList);
}
extern "C" {
    #[doc = " List devices."]
    #[doc = ""]
    #[doc = " Returns available device names and their parameters."]
    #[doc = " These are convinient wrappers for avdevice_list_devices()."]
    #[doc = " Device context is allocated and deallocated internally."]
    #[doc = ""]
    #[doc = " @param device           device format. May be NULL if device name is set."]
    #[doc = " @param device_name      device name. May be NULL if device format is set."]
    #[doc = " @param device_options   An AVDictionary filled with device-private options. May be NULL."]
    #[doc = "                         The same options must be passed later to avformat_write_header() for output"]
    #[doc = "                         devices or avformat_open_input() for input devices, or at any other place"]
    #[doc = "                         that affects device-private options."]
    #[doc = " @param[out] device_list list of autodetected devices"]
    #[doc = " @return count of autodetected devices, negative on error."]
    #[doc = " @note device argument takes precedence over device_name when both are set."]
    pub fn avdevice_list_input_sources(
        device: *const AVInputFormat,
        device_name: *const libc::c_char,
        device_options: *mut AVDictionary,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avdevice_list_output_sinks(
        device: *const AVOutputFormat,
        device_name: *const libc::c_char,
        device_options: *mut AVDictionary,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the LIBAVFILTER_VERSION_INT constant."]
    pub fn avfilter_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the libavfilter build-time configuration."]
    pub fn avfilter_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libavfilter license."]
    pub fn avfilter_license() -> *const libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterPad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterFormats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterChannelLayouts {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the number of elements in an AVFilter's inputs or outputs array."]
    #[doc = ""]
    #[doc = " @deprecated Use avfilter_filter_pad_count() instead."]
    pub fn avfilter_pad_count(pads: *const AVFilterPad) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name of an AVFilterPad."]
    #[doc = ""]
    #[doc = " @param pads an array of AVFilterPads"]
    #[doc = " @param pad_idx index of the pad in the array; it is the caller's"]
    #[doc = "                responsibility to ensure the index is valid"]
    #[doc = ""]
    #[doc = " @return name of the pad_idx'th pad in pads"]
    pub fn avfilter_pad_get_name(
        pads: *const AVFilterPad,
        pad_idx: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of an AVFilterPad."]
    #[doc = ""]
    #[doc = " @param pads an array of AVFilterPads"]
    #[doc = " @param pad_idx index of the pad in the array; it is the caller's"]
    #[doc = "                responsibility to ensure the index is valid"]
    #[doc = ""]
    #[doc = " @return type of the pad_idx'th pad in pads"]
    pub fn avfilter_pad_get_type(pads: *const AVFilterPad, pad_idx: libc::c_int) -> AVMediaType;
}
#[doc = " Filter definition. This defines the pads a filter contains, and all the"]
#[doc = " callback functions used to interact with the filter."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFilter {
    #[doc = " Filter name. Must be non-NULL and unique among filters."]
    pub name: *const libc::c_char,
    #[doc = " A description of the filter. May be NULL."]
    #[doc = ""]
    #[doc = " You should use the NULL_IF_CONFIG_SMALL() macro to define it."]
    pub description: *const libc::c_char,
    #[doc = " List of static inputs."]
    #[doc = ""]
    #[doc = " NULL if there are no (static) inputs. Instances of filters with"]
    #[doc = " AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in"]
    #[doc = " this list."]
    pub inputs: *const AVFilterPad,
    #[doc = " List of static outputs."]
    #[doc = ""]
    #[doc = " NULL if there are no (static) outputs. Instances of filters with"]
    #[doc = " AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in"]
    #[doc = " this list."]
    pub outputs: *const AVFilterPad,
    #[doc = " A class for the private data, used to declare filter private AVOptions."]
    #[doc = " This field is NULL for filters that do not declare any options."]
    #[doc = ""]
    #[doc = " If this field is non-NULL, the first member of the filter private data"]
    #[doc = " must be a pointer to AVClass, which will be set by libavfilter generic"]
    #[doc = " code to this class."]
    pub priv_class: *const AVClass,
    #[doc = " A combination of AVFILTER_FLAG_*"]
    pub flags: libc::c_int,
    #[doc = " The number of entries in the list of inputs."]
    pub nb_inputs: u8,
    #[doc = " The number of entries in the list of outputs."]
    pub nb_outputs: u8,
    #[doc = " This field determines the state of the formats union."]
    #[doc = " It is an enum FilterFormatsState value."]
    pub formats_state: u8,
    #[doc = " Filter pre-initialization function"]
    #[doc = ""]
    #[doc = " This callback will be called immediately after the filter context is"]
    #[doc = " allocated, to allow allocating and initing sub-objects."]
    #[doc = ""]
    #[doc = " If this callback is not NULL, the uninit callback will be called on"]
    #[doc = " allocation failure."]
    #[doc = ""]
    #[doc = " @return 0 on success,"]
    #[doc = "         AVERROR code on failure (but the code will be"]
    #[doc = "           dropped and treated as ENOMEM by the calling code)"]
    pub preinit:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext) -> libc::c_int>,
    #[doc = " Filter initialization function."]
    #[doc = ""]
    #[doc = " This callback will be called only once during the filter lifetime, after"]
    #[doc = " all the options have been set, but before links between filters are"]
    #[doc = " established and format negotiation is done."]
    #[doc = ""]
    #[doc = " Basic filter initialization should be done here. Filters with dynamic"]
    #[doc = " inputs and/or outputs should create those inputs/outputs here based on"]
    #[doc = " provided options. No more changes to this filter's inputs/outputs can be"]
    #[doc = " done after this callback."]
    #[doc = ""]
    #[doc = " This callback must not assume that the filter links exist or frame"]
    #[doc = " parameters are known."]
    #[doc = ""]
    #[doc = " @ref AVFilter.uninit \"uninit\" is guaranteed to be called even if"]
    #[doc = " initialization fails, so this callback does not have to clean up on"]
    #[doc = " failure."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on failure"]
    pub init: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext) -> libc::c_int>,
    #[doc = " Should be set instead of @ref AVFilter.init \"init\" by the filters that"]
    #[doc = " want to pass a dictionary of AVOptions to nested contexts that are"]
    #[doc = " allocated during init."]
    #[doc = ""]
    #[doc = " On return, the options dict should be freed and replaced with one that"]
    #[doc = " contains all the options which could not be processed by this filter (or"]
    #[doc = " with NULL if all the options were processed)."]
    #[doc = ""]
    #[doc = " Otherwise the semantics is the same as for @ref AVFilter.init \"init\"."]
    pub init_dict: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut AVFilterContext,
            options: *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    #[doc = " Filter uninitialization function."]
    #[doc = ""]
    #[doc = " Called only once right before the filter is freed. Should deallocate any"]
    #[doc = " memory held by the filter, release any buffer references, etc. It does"]
    #[doc = " not need to deallocate the AVFilterContext.priv memory itself."]
    #[doc = ""]
    #[doc = " This callback may be called even if @ref AVFilter.init \"init\" was not"]
    #[doc = " called or failed, so it must be prepared to handle such a situation."]
    pub uninit: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext)>,
    pub formats: AVFilter__bindgen_ty_1,
    #[doc = "< size of private data to allocate for the filter"]
    pub priv_size: libc::c_int,
    #[doc = "< Additional flags for avfilter internal use only."]
    pub flags_internal: libc::c_int,
    #[doc = " Make the filter instance process a command."]
    #[doc = ""]
    #[doc = " @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only"]
    #[doc = " @param arg    the argument for the command"]
    #[doc = " @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported."]
    #[doc = " @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be"]
    #[doc = "               time consuming then a filter should treat it like an unsupported command"]
    #[doc = ""]
    #[doc = " @returns >=0 on success otherwise an error code."]
    #[doc = "          AVERROR(ENOSYS) on unsupported commands"]
    pub process_command: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFilterContext,
            cmd: *const libc::c_char,
            arg: *const libc::c_char,
            res: *mut libc::c_char,
            res_len: libc::c_int,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    #[doc = " Filter activation function."]
    #[doc = ""]
    #[doc = " Called when any processing is needed from the filter, instead of any"]
    #[doc = " filter_frame and request_frame on pads."]
    #[doc = ""]
    #[doc = " The function must examine inlinks and outlinks and perform a single"]
    #[doc = " step of processing. If there is nothing to do, the function must do"]
    #[doc = " nothing and not return an error. If more steps are or may be"]
    #[doc = " possible, it must use ff_filter_set_ready() to schedule another"]
    #[doc = " activation."]
    pub activate:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext) -> libc::c_int>,
}
#[doc = " The state of the following union is determined by formats_state."]
#[doc = " See the documentation of enum FilterFormatsState in internal.h."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVFilter__bindgen_ty_1 {
    #[doc = " Query formats supported by the filter on its inputs and outputs."]
    #[doc = ""]
    #[doc = " This callback is called after the filter is initialized (so the inputs"]
    #[doc = " and outputs are fixed), shortly before the format negotiation. This"]
    #[doc = " callback may be called more than once."]
    #[doc = ""]
    #[doc = " This callback must set AVFilterLink.outcfg.formats on every input link"]
    #[doc = " and AVFilterLink.incfg.formats on every output link to a list of"]
    #[doc = " pixel/sample formats that the filter supports on that link. For audio"]
    #[doc = " links, this filter must also set @ref AVFilterLink.incfg.samplerates"]
    #[doc = " \"in_samplerates\" / @ref AVFilterLink.outcfg.samplerates \"out_samplerates\""]
    #[doc = " and @ref AVFilterLink.incfg.channel_layouts \"in_channel_layouts\" /"]
    #[doc = " @ref AVFilterLink.outcfg.channel_layouts \"out_channel_layouts\" analogously."]
    #[doc = ""]
    #[doc = " This callback must never be NULL if the union is in this state."]
    #[doc = ""]
    #[doc = " @return zero on success, a negative value corresponding to an"]
    #[doc = " AVERROR code otherwise"]
    pub query_func:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFilterContext) -> libc::c_int>,
    #[doc = " A pointer to an array of admissible pixel formats delimited"]
    #[doc = " by AV_PIX_FMT_NONE. The generic code will use this list"]
    #[doc = " to indicate that this filter supports each of these pixel formats,"]
    #[doc = " provided that all inputs and outputs use the same pixel format."]
    #[doc = ""]
    #[doc = " This list must never be NULL if the union is in this state."]
    #[doc = " The type of all inputs and outputs of filters using this must"]
    #[doc = " be AVMEDIA_TYPE_VIDEO."]
    pub pixels_list: *const AVPixelFormat,
    #[doc = " Analogous to pixels, but delimited by AV_SAMPLE_FMT_NONE"]
    #[doc = " and restricted to filters that only have AVMEDIA_TYPE_AUDIO"]
    #[doc = " inputs and outputs."]
    #[doc = ""]
    #[doc = " In addition to that the generic code will mark all inputs"]
    #[doc = " and all outputs as supporting all sample rates and every"]
    #[doc = " channel count and channel layout, as long as all inputs"]
    #[doc = " and outputs use the same sample rate and channel count/layout."]
    pub samples_list: *const AVSampleFormat,
    #[doc = " Equivalent to { pix_fmt, AV_PIX_FMT_NONE } as pixels_list."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Equivalent to { sample_fmt, AV_SAMPLE_FMT_NONE } as samples_list."]
    pub sample_fmt: AVSampleFormat,
}
#[test]
fn bindgen_test_layout_AVFilter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AVFilter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVFilter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilter__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilter__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilter__bindgen_ty_1>())).query_func as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(query_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilter__bindgen_ty_1>())).pixels_list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(pixels_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilter__bindgen_ty_1>())).samples_list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(samples_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter__bindgen_ty_1>())).pix_fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilter__bindgen_ty_1>())).sample_fmt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(sample_fmt)
        )
    );
}
#[test]
fn bindgen_test_layout_AVFilter() {
    assert_eq!(
        ::std::mem::size_of::<AVFilter>(),
        112usize,
        concat!("Size of: ", stringify!(AVFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).description as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).inputs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).outputs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).priv_class as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).nb_inputs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(nb_inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).nb_outputs as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(nb_outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).formats_state as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(formats_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).preinit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(preinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).init as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).init_dict as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(init_dict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).uninit as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(uninit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).formats as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).priv_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).flags_internal as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(flags_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).process_command as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(process_command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).activate as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(activate)
        )
    );
}
extern "C" {
    #[doc = " Get the number of elements in an AVFilter's inputs or outputs array."]
    pub fn avfilter_filter_pad_count(
        filter: *const AVFilter,
        is_output: libc::c_int,
    ) -> libc::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterInternal {
    _unused: [u8; 0],
}
#[doc = " An instance of a filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterContext {
    #[doc = "< needed for av_log() and filters common options"]
    pub av_class: *const AVClass,
    #[doc = "< the AVFilter of which this is an instance"]
    pub filter: *const AVFilter,
    #[doc = "< name of this filter instance"]
    pub name: *mut libc::c_char,
    #[doc = "< array of input pads"]
    pub input_pads: *mut AVFilterPad,
    #[doc = "< array of pointers to input links"]
    pub inputs: *mut *mut AVFilterLink,
    #[doc = "< number of input pads"]
    pub nb_inputs: libc::c_uint,
    #[doc = "< array of output pads"]
    pub output_pads: *mut AVFilterPad,
    #[doc = "< array of pointers to output links"]
    pub outputs: *mut *mut AVFilterLink,
    #[doc = "< number of output pads"]
    pub nb_outputs: libc::c_uint,
    #[doc = "< private data for use by the filter"]
    pub priv_: *mut libc::c_void,
    #[doc = "< filtergraph this filter belongs to"]
    pub graph: *mut AVFilterGraph,
    #[doc = " Type of multithreading being allowed/used. A combination of"]
    #[doc = " AVFILTER_THREAD_* flags."]
    #[doc = ""]
    #[doc = " May be set by the caller before initializing the filter to forbid some"]
    #[doc = " or all kinds of multithreading for this filter. The default is allowing"]
    #[doc = " everything."]
    #[doc = ""]
    #[doc = " When the filter is initialized, this field is combined using bit AND with"]
    #[doc = " AVFilterGraph.thread_type to get the final mask used for determining"]
    #[doc = " allowed threading types. I.e. a threading type needs to be set in both"]
    #[doc = " to be allowed."]
    #[doc = ""]
    #[doc = " After the filter is initialized, libavfilter sets this field to the"]
    #[doc = " threading type that is actually used (0 for no multithreading)."]
    pub thread_type: libc::c_int,
    #[doc = " An opaque struct for libavfilter internal use."]
    pub internal: *mut AVFilterInternal,
    pub command_queue: *mut AVFilterCommand,
    #[doc = "< enable expression string"]
    pub enable_str: *mut libc::c_char,
    #[doc = "< parsed expression (AVExpr*)"]
    pub enable: *mut libc::c_void,
    #[doc = "< variable values for the enable expression"]
    pub var_values: *mut f64,
    #[doc = "< the enabled state from the last expression evaluation"]
    pub is_disabled: libc::c_int,
    #[doc = " For filters which will create hardware frames, sets the device the"]
    #[doc = " filter should create them in.  All other filters will ignore this field:"]
    #[doc = " in particular, a filter which consumes or processes hardware frames will"]
    #[doc = " instead use the hw_frames_ctx field in AVFilterLink to carry the"]
    #[doc = " hardware context information."]
    pub hw_device_ctx: *mut AVBufferRef,
    #[doc = " Max number of threads allowed in this filter instance."]
    #[doc = " If <= 0, its value is ignored."]
    #[doc = " Overrides global number of threads set per filter graph."]
    pub nb_threads: libc::c_int,
    #[doc = " Ready status of the filter."]
    #[doc = " A non-0 value means that the filter needs activating;"]
    #[doc = " a higher value suggests a more urgent activation."]
    pub ready: libc::c_uint,
    #[doc = " Sets the number of extra hardware frames which the filter will"]
    #[doc = " allocate on its output links for use in following filters or by"]
    #[doc = " the caller."]
    #[doc = ""]
    #[doc = " Some hardware filters require all frames that they will use for"]
    #[doc = " output to be defined in advance before filtering starts.  For such"]
    #[doc = " filters, any hardware frame pools used for output must therefore be"]
    #[doc = " of fixed size.  The extra frames set here are on top of any number"]
    #[doc = " that the filter needs internally in order to operate normally."]
    #[doc = ""]
    #[doc = " This field must be set before the graph containing this filter is"]
    #[doc = " configured."]
    pub extra_hw_frames: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVFilterContext() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterContext>(),
        168usize,
        concat!("Size of: ", stringify!(AVFilterContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).input_pads as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(input_pads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).inputs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).nb_inputs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).output_pads as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(output_pads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).outputs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).nb_outputs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).priv_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).graph as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).thread_type as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).internal as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).command_queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(command_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).enable_str as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(enable_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).enable as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).var_values as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(var_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).is_disabled as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(is_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).hw_device_ctx as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).nb_threads as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).ready as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(ready)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).extra_hw_frames as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(extra_hw_frames)
        )
    );
}
#[doc = " Lists of formats / etc. supported by an end of a link."]
#[doc = ""]
#[doc = " This structure is directly part of AVFilterLink, in two copies:"]
#[doc = " one for the source filter, one for the destination filter."]
#[doc = ""]
#[doc = " These lists are used for negotiating the format to actually be used,"]
#[doc = " which will be loaded into the format and channel_layout members of"]
#[doc = " AVFilterLink, when chosen."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterFormatsConfig {
    #[doc = " List of supported formats (pixel or sample)."]
    pub formats: *mut AVFilterFormats,
    #[doc = " Lists of supported sample rates, only for audio."]
    pub samplerates: *mut AVFilterFormats,
    #[doc = " Lists of supported channel layouts, only for audio."]
    pub channel_layouts: *mut AVFilterChannelLayouts,
}
#[test]
fn bindgen_test_layout_AVFilterFormatsConfig() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterFormatsConfig>(),
        24usize,
        concat!("Size of: ", stringify!(AVFilterFormatsConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterFormatsConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterFormatsConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterFormatsConfig>())).formats as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterFormatsConfig),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterFormatsConfig>())).samplerates as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterFormatsConfig),
            "::",
            stringify!(samplerates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterFormatsConfig>())).channel_layouts as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterFormatsConfig),
            "::",
            stringify!(channel_layouts)
        )
    );
}
#[doc = " A link between two filters. This contains pointers to the source and"]
#[doc = " destination filters between which this link exists, and the indexes of"]
#[doc = " the pads involved. In addition, this link also contains the parameters"]
#[doc = " which have been negotiated and agreed upon between the filter, such as"]
#[doc = " image dimensions, format, etc."]
#[doc = ""]
#[doc = " Applications must not normally access the link structure directly."]
#[doc = " Use the buffersrc and buffersink API instead."]
#[doc = " In the future, access to the header may be reserved for filters"]
#[doc = " implementation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFilterLink {
    #[doc = "< source filter"]
    pub src: *mut AVFilterContext,
    #[doc = "< output pad on the source filter"]
    pub srcpad: *mut AVFilterPad,
    #[doc = "< dest filter"]
    pub dst: *mut AVFilterContext,
    #[doc = "< input pad on the dest filter"]
    pub dstpad: *mut AVFilterPad,
    #[doc = "< filter media type"]
    pub type_: AVMediaType,
    #[doc = "< agreed upon image width"]
    pub w: libc::c_int,
    #[doc = "< agreed upon image height"]
    pub h: libc::c_int,
    #[doc = "< agreed upon sample aspect ratio"]
    pub sample_aspect_ratio: AVRational,
    #[doc = " channel layout of current buffer (see libavutil/channel_layout.h)"]
    #[doc = " @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = "< samples per second"]
    pub sample_rate: libc::c_int,
    #[doc = "< agreed upon media format"]
    pub format: libc::c_int,
    #[doc = " Define the time base used by the PTS of the frames/samples"]
    #[doc = " which will pass through this link."]
    #[doc = " During the configuration stage, each filter is supposed to"]
    #[doc = " change only the output timebase, while the timebase of the"]
    #[doc = " input link is assumed to be an unchangeable property."]
    pub time_base: AVRational,
    #[doc = "< channel layout of current buffer (see libavutil/channel_layout.h)"]
    pub ch_layout: AVChannelLayout,
    #[doc = " Lists of supported formats / etc. supported by the input filter."]
    pub incfg: AVFilterFormatsConfig,
    #[doc = " Lists of supported formats / etc. supported by the output filter."]
    pub outcfg: AVFilterFormatsConfig,
    pub init_state: AVFilterLink__bindgen_ty_1,
    #[doc = " Graph the filter belongs to."]
    pub graph: *mut AVFilterGraph,
    #[doc = " Current timestamp of the link, as defined by the most recent"]
    #[doc = " frame(s), in link time_base units."]
    pub current_pts: i64,
    #[doc = " Current timestamp of the link, as defined by the most recent"]
    #[doc = " frame(s), in AV_TIME_BASE units."]
    pub current_pts_us: i64,
    #[doc = " Index in the age array."]
    pub age_index: libc::c_int,
    #[doc = " Frame rate of the stream on the link, or 1/0 if unknown or variable;"]
    #[doc = " if left to 0/0, will be automatically copied from the first input"]
    #[doc = " of the source filter if it exists."]
    #[doc = ""]
    #[doc = " Sources should set it to the best estimation of the real frame rate."]
    #[doc = " If the source frame rate is unknown or variable, set this to 1/0."]
    #[doc = " Filters should update it if necessary depending on their function."]
    #[doc = " Sinks can use it to set a default output frame rate."]
    #[doc = " It is similar to the r_frame_rate field in AVStream."]
    pub frame_rate: AVRational,
    #[doc = " Minimum number of samples to filter at once. If filter_frame() is"]
    #[doc = " called with fewer samples, it will accumulate them in fifo."]
    #[doc = " This field and the related ones must not be changed after filtering"]
    #[doc = " has started."]
    #[doc = " If 0, all related fields are ignored."]
    pub min_samples: libc::c_int,
    #[doc = " Maximum number of samples to filter at once. If filter_frame() is"]
    #[doc = " called with more samples, it will split them."]
    pub max_samples: libc::c_int,
    #[doc = " Number of past frames sent through the link."]
    pub frame_count_in: i64,
    #[doc = " Number of past frames sent through the link."]
    pub frame_count_out: i64,
    #[doc = " Number of past samples sent through the link."]
    pub sample_count_in: i64,
    #[doc = " Number of past samples sent through the link."]
    pub sample_count_out: i64,
    #[doc = " A pointer to a FFFramePool struct."]
    pub frame_pool: *mut libc::c_void,
    #[doc = " True if a frame is currently wanted on the output of this filter."]
    #[doc = " Set when ff_request_frame() is called by the output,"]
    #[doc = " cleared when a frame is filtered."]
    pub frame_wanted_out: libc::c_int,
    #[doc = " For hwaccel pixel formats, this should be a reference to the"]
    #[doc = " AVHWFramesContext describing the frames."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Internal structure members."]
    #[doc = " The fields below this limit are internal for libavfilter's use"]
    #[doc = " and must in no way be accessed by applications."]
    pub reserved: [libc::c_char; 61440usize],
}
pub const AVFilterLink_AVLINK_UNINIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_UNINIT;
pub const AVFilterLink_AVLINK_STARTINIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_STARTINIT;
pub const AVFilterLink_AVLINK_INIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_INIT;
#[repr(u32)]
#[doc = " stage of the initialization of the link properties (dimensions, etc)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVFilterLink__bindgen_ty_1 {
    #[doc = "< not started"]
    AVLINK_UNINIT = 0,
    #[doc = "< started, but incomplete"]
    AVLINK_STARTINIT = 1,
    #[doc = "< complete"]
    AVLINK_INIT = 2,
}
#[test]
fn bindgen_test_layout_AVFilterLink() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterLink>(),
        61704usize,
        concat!("Size of: ", stringify!(AVFilterLink))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterLink>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterLink))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).srcpad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(srcpad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).dst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).dstpad as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(dstpad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).w as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).h as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterLink>())).sample_aspect_ratio as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).channel_layout as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).sample_rate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).format as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).time_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).ch_layout as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(ch_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).incfg as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(incfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).outcfg as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(outcfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).init_state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(init_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).graph as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).current_pts as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(current_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).current_pts_us as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(current_pts_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).age_index as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(age_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_rate as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).min_samples as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(min_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).max_samples as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_count_in as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_count_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_count_out as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_count_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).sample_count_in as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_count_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).sample_count_out as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_count_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_pool as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_wanted_out as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_wanted_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).hw_frames_ctx as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).reserved as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[doc = " Link two filters together."]
    #[doc = ""]
    #[doc = " @param src    the source filter"]
    #[doc = " @param srcpad index of the output pad on the source filter"]
    #[doc = " @param dst    the destination filter"]
    #[doc = " @param dstpad index of the input pad on the destination filter"]
    #[doc = " @return       zero on success"]
    pub fn avfilter_link(
        src: *mut AVFilterContext,
        srcpad: libc::c_uint,
        dst: *mut AVFilterContext,
        dstpad: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free the link in *link, and set its pointer to NULL."]
    pub fn avfilter_link_free(link: *mut *mut AVFilterLink);
}
extern "C" {
    #[doc = " Negotiate the media format, dimensions, etc of all inputs to a filter."]
    #[doc = ""]
    #[doc = " @param filter the filter to negotiate the properties for its inputs"]
    #[doc = " @return       zero on successful negotiation"]
    pub fn avfilter_config_links(filter: *mut AVFilterContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Make the filter instance process a command."]
    #[doc = " It is recommended to use avfilter_graph_send_command()."]
    pub fn avfilter_process_command(
        filter: *mut AVFilterContext,
        cmd: *const libc::c_char,
        arg: *const libc::c_char,
        res: *mut libc::c_char,
        res_len: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Iterate over all registered filters."]
    #[doc = ""]
    #[doc = " @param opaque a pointer where libavfilter will store the iteration state. Must"]
    #[doc = "               point to NULL to start the iteration."]
    #[doc = ""]
    #[doc = " @return the next registered filter or NULL when the iteration is"]
    #[doc = "         finished"]
    pub fn av_filter_iterate(opaque: *mut *mut libc::c_void) -> *const AVFilter;
}
extern "C" {
    #[doc = " Get a filter definition matching the given name."]
    #[doc = ""]
    #[doc = " @param name the filter name to find"]
    #[doc = " @return     the filter definition, if any matching one is registered."]
    #[doc = "             NULL if none found."]
    pub fn avfilter_get_by_name(name: *const libc::c_char) -> *const AVFilter;
}
extern "C" {
    #[doc = " Initialize a filter with the supplied parameters."]
    #[doc = ""]
    #[doc = " @param ctx  uninitialized filter context to initialize"]
    #[doc = " @param args Options to initialize the filter with. This must be a"]
    #[doc = "             ':'-separated list of options in the 'key=value' form."]
    #[doc = "             May be NULL if the options have been set directly using the"]
    #[doc = "             AVOptions API or there are no options that need to be set."]
    #[doc = " @return 0 on success, a negative AVERROR on failure"]
    pub fn avfilter_init_str(ctx: *mut AVFilterContext, args: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize a filter with the supplied dictionary of options."]
    #[doc = ""]
    #[doc = " @param ctx     uninitialized filter context to initialize"]
    #[doc = " @param options An AVDictionary filled with options for this filter. On"]
    #[doc = "                return this parameter will be destroyed and replaced with"]
    #[doc = "                a dict containing options that were not found. This dictionary"]
    #[doc = "                must be freed by the caller."]
    #[doc = "                May be NULL, then this function is equivalent to"]
    #[doc = "                avfilter_init_str() with the second parameter set to NULL."]
    #[doc = " @return 0 on success, a negative AVERROR on failure"]
    #[doc = ""]
    #[doc = " @note This function and avfilter_init_str() do essentially the same thing,"]
    #[doc = " the difference is in manner in which the options are passed. It is up to the"]
    #[doc = " calling code to choose whichever is more preferable. The two functions also"]
    #[doc = " behave differently when some of the provided options are not declared as"]
    #[doc = " supported by the filter. In such a case, avfilter_init_str() will fail, but"]
    #[doc = " this function will leave those extra options in the options AVDictionary and"]
    #[doc = " continue as usual."]
    pub fn avfilter_init_dict(
        ctx: *mut AVFilterContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a filter context. This will also remove the filter from its"]
    #[doc = " filtergraph's list of filters."]
    #[doc = ""]
    #[doc = " @param filter the filter to free"]
    pub fn avfilter_free(filter: *mut AVFilterContext);
}
extern "C" {
    #[doc = " Insert a filter in the middle of an existing link."]
    #[doc = ""]
    #[doc = " @param link the link into which the filter should be inserted"]
    #[doc = " @param filt the filter to be inserted"]
    #[doc = " @param filt_srcpad_idx the input pad on the filter to connect"]
    #[doc = " @param filt_dstpad_idx the output pad on the filter to connect"]
    #[doc = " @return     zero on success"]
    pub fn avfilter_insert_filter(
        link: *mut AVFilterLink,
        filt: *mut AVFilterContext,
        filt_srcpad_idx: libc::c_uint,
        filt_dstpad_idx: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @return AVClass for AVFilterContext."]
    #[doc = ""]
    #[doc = " @see av_opt_find()."]
    pub fn avfilter_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterGraphInternal {
    _unused: [u8; 0],
}
#[doc = " A function pointer passed to the @ref AVFilterGraph.execute callback to be"]
#[doc = " executed multiple times, possibly in parallel."]
#[doc = ""]
#[doc = " @param ctx the filter context the job belongs to"]
#[doc = " @param arg an opaque parameter passed through from @ref"]
#[doc = "            AVFilterGraph.execute"]
#[doc = " @param jobnr the index of the job being executed"]
#[doc = " @param nb_jobs the total number of jobs"]
#[doc = ""]
#[doc = " @return 0 on success, a negative AVERROR on error"]
pub type avfilter_action_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        arg: *mut libc::c_void,
        jobnr: libc::c_int,
        nb_jobs: libc::c_int,
    ) -> libc::c_int,
>;
#[doc = " A function executing multiple jobs, possibly in parallel."]
#[doc = ""]
#[doc = " @param ctx the filter context to which the jobs belong"]
#[doc = " @param func the function to be called multiple times"]
#[doc = " @param arg the argument to be passed to func"]
#[doc = " @param ret a nb_jobs-sized array to be filled with return values from each"]
#[doc = "            invocation of func"]
#[doc = " @param nb_jobs the number of jobs to execute"]
#[doc = ""]
#[doc = " @return 0 on success, a negative AVERROR on error"]
pub type avfilter_execute_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        func: avfilter_action_func,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        nb_jobs: libc::c_int,
    ) -> libc::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterGraph {
    pub av_class: *const AVClass,
    pub filters: *mut *mut AVFilterContext,
    pub nb_filters: libc::c_uint,
    #[doc = "< sws options to use for the auto-inserted scale filters"]
    pub scale_sws_opts: *mut libc::c_char,
    #[doc = " Type of multithreading allowed for filters in this graph. A combination"]
    #[doc = " of AVFILTER_THREAD_* flags."]
    #[doc = ""]
    #[doc = " May be set by the caller at any point, the setting will apply to all"]
    #[doc = " filters initialized after that. The default is allowing everything."]
    #[doc = ""]
    #[doc = " When a filter in this graph is initialized, this field is combined using"]
    #[doc = " bit AND with AVFilterContext.thread_type to get the final mask used for"]
    #[doc = " determining allowed threading types. I.e. a threading type needs to be"]
    #[doc = " set in both to be allowed."]
    pub thread_type: libc::c_int,
    #[doc = " Maximum number of threads used by filters in this graph. May be set by"]
    #[doc = " the caller before adding any filters to the filtergraph. Zero (the"]
    #[doc = " default) means that the number of threads is determined automatically."]
    pub nb_threads: libc::c_int,
    #[doc = " Opaque object for libavfilter internal use."]
    pub internal: *mut AVFilterGraphInternal,
    #[doc = " Opaque user data. May be set by the caller to an arbitrary value, e.g. to"]
    #[doc = " be used from callbacks like @ref AVFilterGraph.execute."]
    #[doc = " Libavfilter will not touch this field in any way."]
    pub opaque: *mut libc::c_void,
    #[doc = " This callback may be set by the caller immediately after allocating the"]
    #[doc = " graph and before adding any filters to it, to provide a custom"]
    #[doc = " multithreading implementation."]
    #[doc = ""]
    #[doc = " If set, filters with slice threading capability will call this callback"]
    #[doc = " to execute multiple jobs in parallel."]
    #[doc = ""]
    #[doc = " If this field is left unset, libavfilter will use its internal"]
    #[doc = " implementation, which may or may not be multithreaded depending on the"]
    #[doc = " platform and build options."]
    pub execute: avfilter_execute_func,
    #[doc = "< swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions"]
    pub aresample_swr_opts: *mut libc::c_char,
    #[doc = " Private fields"]
    #[doc = ""]
    #[doc = " The following fields are for internal use only."]
    #[doc = " Their type, offset, number and semantic can change without notice."]
    pub sink_links: *mut *mut AVFilterLink,
    pub sink_links_count: libc::c_int,
    pub disable_auto_convert: libc::c_uint,
}
#[test]
fn bindgen_test_layout_AVFilterGraph() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterGraph>(),
        88usize,
        concat!("Size of: ", stringify!(AVFilterGraph))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterGraph>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterGraph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).filters as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).nb_filters as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(nb_filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).scale_sws_opts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(scale_sws_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).thread_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).nb_threads as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(nb_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).internal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).execute as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterGraph>())).aresample_swr_opts as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(aresample_swr_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).sink_links as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(sink_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).sink_links_count as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(sink_links_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterGraph>())).disable_auto_convert as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(disable_auto_convert)
        )
    );
}
extern "C" {
    #[doc = " Allocate a filter graph."]
    #[doc = ""]
    #[doc = " @return the allocated filter graph on success or NULL."]
    pub fn avfilter_graph_alloc() -> *mut AVFilterGraph;
}
extern "C" {
    #[doc = " Create a new filter instance in a filter graph."]
    #[doc = ""]
    #[doc = " @param graph graph in which the new filter will be used"]
    #[doc = " @param filter the filter to create an instance of"]
    #[doc = " @param name Name to give to the new instance (will be copied to"]
    #[doc = "             AVFilterContext.name). This may be used by the caller to identify"]
    #[doc = "             different filters, libavfilter itself assigns no semantics to"]
    #[doc = "             this parameter. May be NULL."]
    #[doc = ""]
    #[doc = " @return the context of the newly created filter instance (note that it is"]
    #[doc = "         also retrievable directly through AVFilterGraph.filters or with"]
    #[doc = "         avfilter_graph_get_filter()) on success or NULL on failure."]
    pub fn avfilter_graph_alloc_filter(
        graph: *mut AVFilterGraph,
        filter: *const AVFilter,
        name: *const libc::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    #[doc = " Get a filter instance identified by instance name from graph."]
    #[doc = ""]
    #[doc = " @param graph filter graph to search through."]
    #[doc = " @param name filter instance name (should be unique in the graph)."]
    #[doc = " @return the pointer to the found filter instance or NULL if it"]
    #[doc = " cannot be found."]
    pub fn avfilter_graph_get_filter(
        graph: *mut AVFilterGraph,
        name: *const libc::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    #[doc = " Create and add a filter instance into an existing graph."]
    #[doc = " The filter instance is created from the filter filt and inited"]
    #[doc = " with the parameter args. opaque is currently ignored."]
    #[doc = ""]
    #[doc = " In case of success put in *filt_ctx the pointer to the created"]
    #[doc = " filter instance, otherwise set *filt_ctx to NULL."]
    #[doc = ""]
    #[doc = " @param name the instance name to give to the created filter instance"]
    #[doc = " @param graph_ctx the filter graph"]
    #[doc = " @return a negative AVERROR error code in case of failure, a non"]
    #[doc = " negative value otherwise"]
    pub fn avfilter_graph_create_filter(
        filt_ctx: *mut *mut AVFilterContext,
        filt: *const AVFilter,
        name: *const libc::c_char,
        args: *const libc::c_char,
        opaque: *mut libc::c_void,
        graph_ctx: *mut AVFilterGraph,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Enable or disable automatic format conversion inside the graph."]
    #[doc = ""]
    #[doc = " Note that format conversion can still happen inside explicitly inserted"]
    #[doc = " scale and aresample filters."]
    #[doc = ""]
    #[doc = " @param flags  any of the AVFILTER_AUTO_CONVERT_* constants"]
    pub fn avfilter_graph_set_auto_convert(graph: *mut AVFilterGraph, flags: libc::c_uint);
}
pub const AVFILTER_AUTO_CONVERT_ALL: _bindgen_ty_6 = _bindgen_ty_6::AVFILTER_AUTO_CONVERT_ALL;
pub const AVFILTER_AUTO_CONVERT_NONE: _bindgen_ty_6 = _bindgen_ty_6::AVFILTER_AUTO_CONVERT_NONE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    #[doc = "< all automatic conversions enabled"]
    AVFILTER_AUTO_CONVERT_ALL = 0,
    #[doc = "< all automatic conversions disabled"]
    AVFILTER_AUTO_CONVERT_NONE = -1,
}
extern "C" {
    #[doc = " Check validity and configure all the links and formats in the graph."]
    #[doc = ""]
    #[doc = " @param graphctx the filter graph"]
    #[doc = " @param log_ctx context used for logging"]
    #[doc = " @return >= 0 in case of success, a negative AVERROR code otherwise"]
    pub fn avfilter_graph_config(
        graphctx: *mut AVFilterGraph,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a graph, destroy its links, and set *graph to NULL."]
    #[doc = " If *graph is NULL, do nothing."]
    pub fn avfilter_graph_free(graph: *mut *mut AVFilterGraph);
}
#[doc = " A linked-list of the inputs/outputs of the filter chain."]
#[doc = ""]
#[doc = " This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),"]
#[doc = " where it is used to communicate open (unlinked) inputs and outputs from and"]
#[doc = " to the caller."]
#[doc = " This struct specifies, per each not connected pad contained in the graph, the"]
#[doc = " filter context and the pad index required for establishing a link."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterInOut {
    #[doc = " unique name for this input/output in the list"]
    pub name: *mut libc::c_char,
    #[doc = " filter context associated to this input/output"]
    pub filter_ctx: *mut AVFilterContext,
    #[doc = " index of the filt_ctx pad to use for linking"]
    pub pad_idx: libc::c_int,
    #[doc = " next input/input in the list, NULL if this is the last"]
    pub next: *mut AVFilterInOut,
}
#[test]
fn bindgen_test_layout_AVFilterInOut() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterInOut>(),
        32usize,
        concat!("Size of: ", stringify!(AVFilterInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterInOut))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).filter_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(filter_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).pad_idx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(pad_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Allocate a single AVFilterInOut entry."]
    #[doc = " Must be freed with avfilter_inout_free()."]
    #[doc = " @return allocated AVFilterInOut on success, NULL on failure."]
    pub fn avfilter_inout_alloc() -> *mut AVFilterInOut;
}
extern "C" {
    #[doc = " Free the supplied list of AVFilterInOut and set *inout to NULL."]
    #[doc = " If *inout is NULL, do nothing."]
    pub fn avfilter_inout_free(inout: *mut *mut AVFilterInOut);
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph."]
    #[doc = ""]
    #[doc = " @note The caller must provide the lists of inputs and outputs,"]
    #[doc = " which therefore must be known before calling the function."]
    #[doc = ""]
    #[doc = " @note The inputs parameter describes inputs of the already existing"]
    #[doc = " part of the graph; i.e. from the point of view of the newly created"]
    #[doc = " part, they are outputs. Similarly the outputs parameter describes"]
    #[doc = " outputs of the already existing filters, which are provided as"]
    #[doc = " inputs to the parsed filters."]
    #[doc = ""]
    #[doc = " @param graph   the filter graph where to link the parsed graph context"]
    #[doc = " @param filters string to be parsed"]
    #[doc = " @param inputs  linked list to the inputs of the graph"]
    #[doc = " @param outputs linked list to the outputs of the graph"]
    #[doc = " @return zero on success, a negative AVERROR code on error"]
    pub fn avfilter_graph_parse(
        graph: *mut AVFilterGraph,
        filters: *const libc::c_char,
        inputs: *mut AVFilterInOut,
        outputs: *mut AVFilterInOut,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph."]
    #[doc = ""]
    #[doc = " In the graph filters description, if the input label of the first"]
    #[doc = " filter is not specified, \"in\" is assumed; if the output label of"]
    #[doc = " the last filter is not specified, \"out\" is assumed."]
    #[doc = ""]
    #[doc = " @param graph   the filter graph where to link the parsed graph context"]
    #[doc = " @param filters string to be parsed"]
    #[doc = " @param inputs  pointer to a linked list to the inputs of the graph, may be NULL."]
    #[doc = "                If non-NULL, *inputs is updated to contain the list of open inputs"]
    #[doc = "                after the parsing, should be freed with avfilter_inout_free()."]
    #[doc = " @param outputs pointer to a linked list to the outputs of the graph, may be NULL."]
    #[doc = "                If non-NULL, *outputs is updated to contain the list of open outputs"]
    #[doc = "                after the parsing, should be freed with avfilter_inout_free()."]
    #[doc = " @return non negative on success, a negative AVERROR code on error"]
    pub fn avfilter_graph_parse_ptr(
        graph: *mut AVFilterGraph,
        filters: *const libc::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph."]
    #[doc = ""]
    #[doc = " @param[in]  graph   the filter graph where to link the parsed graph context"]
    #[doc = " @param[in]  filters string to be parsed"]
    #[doc = " @param[out] inputs  a linked list of all free (unlinked) inputs of the"]
    #[doc = "                     parsed graph will be returned here. It is to be freed"]
    #[doc = "                     by the caller using avfilter_inout_free()."]
    #[doc = " @param[out] outputs a linked list of all free (unlinked) outputs of the"]
    #[doc = "                     parsed graph will be returned here. It is to be freed by the"]
    #[doc = "                     caller using avfilter_inout_free()."]
    #[doc = " @return zero on success, a negative AVERROR code on error"]
    #[doc = ""]
    #[doc = " @note This function returns the inputs and outputs that are left"]
    #[doc = " unlinked after parsing the graph and the caller then deals with"]
    #[doc = " them."]
    #[doc = " @note This function makes no reference whatsoever to already"]
    #[doc = " existing parts of the graph and the inputs parameter will on return"]
    #[doc = " contain inputs of the newly parsed part of the graph.  Analogously"]
    #[doc = " the outputs parameter will contain outputs of the newly created"]
    #[doc = " filters."]
    pub fn avfilter_graph_parse2(
        graph: *mut AVFilterGraph,
        filters: *const libc::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a command to one or more filter instances."]
    #[doc = ""]
    #[doc = " @param graph  the filter graph"]
    #[doc = " @param target the filter(s) to which the command should be sent"]
    #[doc = "               \"all\" sends to all filters"]
    #[doc = "               otherwise it can be a filter or filter instance name"]
    #[doc = "               which will send the command to all matching filters."]
    #[doc = " @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only"]
    #[doc = " @param arg    the argument for the command"]
    #[doc = " @param res    a buffer with size res_size where the filter(s) can return a response."]
    #[doc = ""]
    #[doc = " @returns >=0 on success otherwise an error code."]
    #[doc = "              AVERROR(ENOSYS) on unsupported commands"]
    pub fn avfilter_graph_send_command(
        graph: *mut AVFilterGraph,
        target: *const libc::c_char,
        cmd: *const libc::c_char,
        arg: *const libc::c_char,
        res: *mut libc::c_char,
        res_len: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Queue a command for one or more filter instances."]
    #[doc = ""]
    #[doc = " @param graph  the filter graph"]
    #[doc = " @param target the filter(s) to which the command should be sent"]
    #[doc = "               \"all\" sends to all filters"]
    #[doc = "               otherwise it can be a filter or filter instance name"]
    #[doc = "               which will send the command to all matching filters."]
    #[doc = " @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only"]
    #[doc = " @param arg    the argument for the command"]
    #[doc = " @param ts     time at which the command should be sent to the filter"]
    #[doc = ""]
    #[doc = " @note As this executes commands after this function returns, no return code"]
    #[doc = "       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported."]
    pub fn avfilter_graph_queue_command(
        graph: *mut AVFilterGraph,
        target: *const libc::c_char,
        cmd: *const libc::c_char,
        arg: *const libc::c_char,
        flags: libc::c_int,
        ts: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Dump a graph into a human-readable string representation."]
    #[doc = ""]
    #[doc = " @param graph    the graph to dump"]
    #[doc = " @param options  formatting options; currently ignored"]
    #[doc = " @return  a string, or NULL in case of memory allocation failure;"]
    #[doc = "          the string must be freed using av_free"]
    pub fn avfilter_graph_dump(
        graph: *mut AVFilterGraph,
        options: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Request a frame on the oldest sink link."]
    #[doc = ""]
    #[doc = " If the request returns AVERROR_EOF, try the next."]
    #[doc = ""]
    #[doc = " Note that this function is not meant to be the sole scheduling mechanism"]
    #[doc = " of a filtergraph, only a convenience function to help drain a filtergraph"]
    #[doc = " in a balanced way under normal circumstances."]
    #[doc = ""]
    #[doc = " Also note that AVERROR_EOF does not mean that frames did not arrive on"]
    #[doc = " some of the sinks during the process."]
    #[doc = " When there are multiple sink links, in case the requested link"]
    #[doc = " returns an EOF, this may cause a filter to flush pending frames"]
    #[doc = " which are sent to another sink link, although unrequested."]
    #[doc = ""]
    #[doc = " @return  the return value of ff_request_frame(),"]
    #[doc = "          or AVERROR_EOF if all links returned AVERROR_EOF"]
    pub fn avfilter_graph_request_oldest(graph: *mut AVFilterGraph) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a frame with filtered data from sink and put it in frame."]
    #[doc = ""]
    #[doc = " @param ctx    pointer to a buffersink or abuffersink filter context."]
    #[doc = " @param frame  pointer to an allocated frame that will be filled with data."]
    #[doc = "               The data must be freed using av_frame_unref() / av_frame_free()"]
    #[doc = " @param flags  a combination of AV_BUFFERSINK_FLAG_* flags"]
    #[doc = ""]
    #[doc = " @return  >= 0 in for success, a negative AVERROR code for failure."]
    pub fn av_buffersink_get_frame_flags(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
#[doc = " Deprecated and unused struct to use for initializing a buffersink context."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBufferSinkParams {
    #[doc = "< list of allowed pixel formats, terminated by AV_PIX_FMT_NONE"]
    pub pixel_fmts: *const AVPixelFormat,
}
#[test]
fn bindgen_test_layout_AVBufferSinkParams() {
    assert_eq!(
        ::std::mem::size_of::<AVBufferSinkParams>(),
        8usize,
        concat!("Size of: ", stringify!(AVBufferSinkParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferSinkParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferSinkParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSinkParams>())).pixel_fmts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSinkParams),
            "::",
            stringify!(pixel_fmts)
        )
    );
}
extern "C" {
    #[doc = " Create an AVBufferSinkParams structure."]
    #[doc = ""]
    #[doc = " Must be freed with av_free()."]
    pub fn av_buffersink_params_alloc() -> *mut AVBufferSinkParams;
}
#[doc = " Deprecated and unused struct to use for initializing an abuffersink context."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVABufferSinkParams {
    #[doc = "< list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE"]
    pub sample_fmts: *const AVSampleFormat,
    #[doc = "< list of allowed channel layouts, terminated by -1"]
    pub channel_layouts: *const i64,
    #[doc = "< list of allowed channel counts, terminated by -1"]
    pub channel_counts: *const libc::c_int,
    #[doc = "< if not 0, accept any channel count or layout"]
    pub all_channel_counts: libc::c_int,
    #[doc = "< list of allowed sample rates, terminated by -1"]
    pub sample_rates: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_AVABufferSinkParams() {
    assert_eq!(
        ::std::mem::size_of::<AVABufferSinkParams>(),
        40usize,
        concat!("Size of: ", stringify!(AVABufferSinkParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVABufferSinkParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVABufferSinkParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVABufferSinkParams>())).sample_fmts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(sample_fmts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).channel_layouts as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(channel_layouts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).channel_counts as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(channel_counts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).all_channel_counts as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(all_channel_counts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).sample_rates as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(sample_rates)
        )
    );
}
extern "C" {
    #[doc = " Create an AVABufferSinkParams structure."]
    #[doc = ""]
    #[doc = " Must be freed with av_free()."]
    pub fn av_abuffersink_params_alloc() -> *mut AVABufferSinkParams;
}
extern "C" {
    #[doc = " Set the frame size for an audio buffer sink."]
    #[doc = ""]
    #[doc = " All calls to av_buffersink_get_buffer_ref will return a buffer with"]
    #[doc = " exactly the specified number of samples, or AVERROR(EAGAIN) if there is"]
    #[doc = " not enough. The last buffer at EOF will be padded with 0."]
    pub fn av_buffersink_set_frame_size(ctx: *mut AVFilterContext, frame_size: libc::c_uint);
}
extern "C" {
    #[doc = " @defgroup lavfi_buffersink_accessors Buffer sink accessors"]
    #[doc = " Get the properties of the stream"]
    #[doc = " @{"]
    pub fn av_buffersink_get_type(ctx: *const AVFilterContext) -> AVMediaType;
}
extern "C" {
    pub fn av_buffersink_get_time_base(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_format(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_frame_rate(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_w(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_h(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_sample_aspect_ratio(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_channels(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_channel_layout(ctx: *const AVFilterContext) -> u64;
}
extern "C" {
    pub fn av_buffersink_get_ch_layout(
        ctx: *const AVFilterContext,
        ch_layout: *mut AVChannelLayout,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_sample_rate(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_hw_frames_ctx(ctx: *const AVFilterContext) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Get a frame with filtered data from sink and put it in frame."]
    #[doc = ""]
    #[doc = " @param ctx pointer to a context of a buffersink or abuffersink AVFilter."]
    #[doc = " @param frame pointer to an allocated frame that will be filled with data."]
    #[doc = "              The data must be freed using av_frame_unref() / av_frame_free()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - >= 0 if a frame was successfully returned."]
    #[doc = "         - AVERROR(EAGAIN) if no frames are available at this point; more"]
    #[doc = "           input frames must be added to the filtergraph to get more output."]
    #[doc = "         - AVERROR_EOF if there will be no more output frames on this sink."]
    #[doc = "         - A different negative AVERROR code in other failure cases."]
    pub fn av_buffersink_get_frame(ctx: *mut AVFilterContext, frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Same as av_buffersink_get_frame(), but with the ability to specify the number"]
    #[doc = " of samples read. This function is less efficient than"]
    #[doc = " av_buffersink_get_frame(), because it copies the data around."]
    #[doc = ""]
    #[doc = " @param ctx pointer to a context of the abuffersink AVFilter."]
    #[doc = " @param frame pointer to an allocated frame that will be filled with data."]
    #[doc = "              The data must be freed using av_frame_unref() / av_frame_free()"]
    #[doc = "              frame will contain exactly nb_samples audio samples, except at"]
    #[doc = "              the end of stream, when it can contain less than nb_samples."]
    #[doc = ""]
    #[doc = " @return The return codes have the same meaning as for"]
    #[doc = "         av_buffersink_get_frame()."]
    #[doc = ""]
    #[doc = " @warning do not mix this function with av_buffersink_get_frame(). Use only one or"]
    #[doc = " the other with a single sink, not both."]
    pub fn av_buffersink_get_samples(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
pub const AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT: _bindgen_ty_7 =
    _bindgen_ty_7::AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT;
pub const AV_BUFFERSRC_FLAG_PUSH: _bindgen_ty_7 = _bindgen_ty_7::AV_BUFFERSRC_FLAG_PUSH;
pub const AV_BUFFERSRC_FLAG_KEEP_REF: _bindgen_ty_7 = _bindgen_ty_7::AV_BUFFERSRC_FLAG_KEEP_REF;
#[repr(u32)]
#[doc = " @defgroup lavfi_buffersrc Buffer source API"]
#[doc = " @ingroup lavfi"]
#[doc = " @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    #[doc = " Do not check for format changes."]
    AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1,
    #[doc = " Immediately push the frame to the output."]
    AV_BUFFERSRC_FLAG_PUSH = 4,
    #[doc = " Keep a reference to the frame."]
    #[doc = " If the frame if reference-counted, create a new reference; otherwise"]
    #[doc = " copy the frame data."]
    AV_BUFFERSRC_FLAG_KEEP_REF = 8,
}
extern "C" {
    #[doc = " Get the number of failed requests."]
    #[doc = ""]
    #[doc = " A failed request is when the request_frame method is called while no"]
    #[doc = " frame is present in the buffer."]
    #[doc = " The number is reset when a frame is added."]
    pub fn av_buffersrc_get_nb_failed_requests(buffer_src: *mut AVFilterContext) -> libc::c_uint;
}
#[doc = " This structure contains the parameters describing the frames that will be"]
#[doc = " passed to this filter."]
#[doc = ""]
#[doc = " It should be allocated with av_buffersrc_parameters_alloc() and freed with"]
#[doc = " av_free(). All the allocated fields in it remain owned by the caller."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVBufferSrcParameters {
    #[doc = " video: the pixel format, value corresponds to enum AVPixelFormat"]
    #[doc = " audio: the sample format, value corresponds to enum AVSampleFormat"]
    pub format: libc::c_int,
    #[doc = " The timebase to be used for the timestamps on the input frames."]
    pub time_base: AVRational,
    #[doc = " Video only, the display dimensions of the input frames."]
    pub width: libc::c_int,
    #[doc = " Video only, the display dimensions of the input frames."]
    pub height: libc::c_int,
    #[doc = " Video only, the sample (pixel) aspect ratio."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Video only, the frame rate of the input video. This field must only be"]
    #[doc = " set to a non-zero value if input stream has a known constant framerate"]
    #[doc = " and should be left at its initial value if the framerate is variable or"]
    #[doc = " unknown."]
    pub frame_rate: AVRational,
    #[doc = " Video with a hwaccel pixel format only. This should be a reference to an"]
    #[doc = " AVHWFramesContext instance describing the input frames."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Audio only, the audio sampling rate in samples per second."]
    pub sample_rate: libc::c_int,
    #[doc = " Audio only, the audio channel layout"]
    #[doc = " @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Audio only, the audio channel layout"]
    pub ch_layout: AVChannelLayout,
}
#[test]
fn bindgen_test_layout_AVBufferSrcParameters() {
    assert_eq!(
        ::std::mem::size_of::<AVBufferSrcParameters>(),
        88usize,
        concat!("Size of: ", stringify!(AVBufferSrcParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferSrcParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferSrcParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).time_base as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).sample_aspect_ratio as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).frame_rate as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).hw_frames_ctx as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).sample_rate as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).channel_layout as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).ch_layout as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(ch_layout)
        )
    );
}
extern "C" {
    #[doc = " Allocate a new AVBufferSrcParameters instance. It should be freed by the"]
    #[doc = " caller with av_free()."]
    pub fn av_buffersrc_parameters_alloc() -> *mut AVBufferSrcParameters;
}
extern "C" {
    #[doc = " Initialize the buffersrc or abuffersrc filter with the provided parameters."]
    #[doc = " This function may be called multiple times, the later calls override the"]
    #[doc = " previous ones. Some of the parameters may also be set through AVOptions, then"]
    #[doc = " whatever method is used last takes precedence."]
    #[doc = ""]
    #[doc = " @param ctx an instance of the buffersrc or abuffersrc filter"]
    #[doc = " @param param the stream parameters. The frames later passed to this filter"]
    #[doc = "              must conform to those parameters. All the allocated fields in"]
    #[doc = "              param remain owned by the caller, libavfilter will make internal"]
    #[doc = "              copies or references when necessary."]
    #[doc = " @return 0 on success, a negative AVERROR code on failure."]
    pub fn av_buffersrc_parameters_set(
        ctx: *mut AVFilterContext,
        param: *mut AVBufferSrcParameters,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a frame to the buffer source."]
    #[doc = ""]
    #[doc = " @param ctx   an instance of the buffersrc filter"]
    #[doc = " @param frame frame to be added. If the frame is reference counted, this"]
    #[doc = " function will make a new reference to it. Otherwise the frame data will be"]
    #[doc = " copied."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error"]
    #[doc = ""]
    #[doc = " This function is equivalent to av_buffersrc_add_frame_flags() with the"]
    #[doc = " AV_BUFFERSRC_FLAG_KEEP_REF flag."]
    pub fn av_buffersrc_write_frame(
        ctx: *mut AVFilterContext,
        frame: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a frame to the buffer source."]
    #[doc = ""]
    #[doc = " @param ctx   an instance of the buffersrc filter"]
    #[doc = " @param frame frame to be added. If the frame is reference counted, this"]
    #[doc = " function will take ownership of the reference(s) and reset the frame."]
    #[doc = " Otherwise the frame data will be copied. If this function returns an error,"]
    #[doc = " the input frame is not touched."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error."]
    #[doc = ""]
    #[doc = " @note the difference between this function and av_buffersrc_write_frame() is"]
    #[doc = " that av_buffersrc_write_frame() creates a new reference to the input frame,"]
    #[doc = " while this function takes ownership of the reference passed to it."]
    #[doc = ""]
    #[doc = " This function is equivalent to av_buffersrc_add_frame_flags() without the"]
    #[doc = " AV_BUFFERSRC_FLAG_KEEP_REF flag."]
    pub fn av_buffersrc_add_frame(ctx: *mut AVFilterContext, frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a frame to the buffer source."]
    #[doc = ""]
    #[doc = " By default, if the frame is reference-counted, this function will take"]
    #[doc = " ownership of the reference(s) and reset the frame. This can be controlled"]
    #[doc = " using the flags."]
    #[doc = ""]
    #[doc = " If this function returns an error, the input frame is not touched."]
    #[doc = ""]
    #[doc = " @param buffer_src  pointer to a buffer source context"]
    #[doc = " @param frame       a frame, or NULL to mark EOF"]
    #[doc = " @param flags       a combination of AV_BUFFERSRC_FLAG_*"]
    #[doc = " @return            >= 0 in case of success, a negative AVERROR code"]
    #[doc = "                    in case of failure"]
    pub fn av_buffersrc_add_frame_flags(
        buffer_src: *mut AVFilterContext,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close the buffer source after EOF."]
    #[doc = ""]
    #[doc = " This is similar to passing NULL to av_buffersrc_add_frame_flags()"]
    #[doc = " except it takes the timestamp of the EOF, i.e. the timestamp of the end"]
    #[doc = " of the last frame."]
    pub fn av_buffersrc_close(
        ctx: *mut AVFilterContext,
        pts: i64,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
#[doc = " @defgroup lavu_adler32 Adler-32"]
#[doc = " @ingroup lavu_hash"]
#[doc = " Adler-32 hash function implementation."]
#[doc = ""]
#[doc = " @{"]
pub type AVAdler = u32;
extern "C" {
    #[doc = " Calculate the Adler32 checksum of a buffer."]
    #[doc = ""]
    #[doc = " Passing the return value to a subsequent av_adler32_update() call"]
    #[doc = " allows the checksum of multiple buffers to be calculated as though"]
    #[doc = " they were concatenated."]
    #[doc = ""]
    #[doc = " @param adler initial checksum value"]
    #[doc = " @param buf   pointer to input buffer"]
    #[doc = " @param len   size of input buffer"]
    #[doc = " @return      updated checksum"]
    pub fn av_adler32_update(adler: AVAdler, buf: *const u8, len: usize) -> AVAdler;
}
extern "C" {
    #[doc = " @defgroup lavu_aes AES"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    pub static av_aes_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAES {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVAES context."]
    pub fn av_aes_alloc() -> *mut AVAES;
}
extern "C" {
    #[doc = " Initialize an AVAES context."]
    #[doc = " @param key_bits 128, 192 or 256"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_aes_init(
        a: *mut AVAES,
        key: *const u8,
        key_bits: libc::c_int,
        decrypt: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context."]
    #[doc = " @param count number of 16 byte blocks"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_aes_crypt(
        a: *mut AVAES,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAudioFifo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Free an AVAudioFifo."]
    #[doc = ""]
    #[doc = " @param af  AVAudioFifo to free"]
    pub fn av_audio_fifo_free(af: *mut AVAudioFifo);
}
extern "C" {
    #[doc = " Allocate an AVAudioFifo."]
    #[doc = ""]
    #[doc = " @param sample_fmt  sample format"]
    #[doc = " @param channels    number of channels"]
    #[doc = " @param nb_samples  initial allocation size, in samples"]
    #[doc = " @return            newly allocated AVAudioFifo, or NULL on error"]
    pub fn av_audio_fifo_alloc(
        sample_fmt: AVSampleFormat,
        channels: libc::c_int,
        nb_samples: libc::c_int,
    ) -> *mut AVAudioFifo;
}
extern "C" {
    #[doc = " Reallocate an AVAudioFifo."]
    #[doc = ""]
    #[doc = " @param af          AVAudioFifo to reallocate"]
    #[doc = " @param nb_samples  new allocation size, in samples"]
    #[doc = " @return            0 if OK, or negative AVERROR code on failure"]
    pub fn av_audio_fifo_realloc(af: *mut AVAudioFifo, nb_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Write data to an AVAudioFifo."]
    #[doc = ""]
    #[doc = " The AVAudioFifo will be reallocated automatically if the available space"]
    #[doc = " is less than nb_samples."]
    #[doc = ""]
    #[doc = " @see enum AVSampleFormat"]
    #[doc = " The documentation for AVSampleFormat describes the data layout."]
    #[doc = ""]
    #[doc = " @param af          AVAudioFifo to write to"]
    #[doc = " @param data        audio data plane pointers"]
    #[doc = " @param nb_samples  number of samples to write"]
    #[doc = " @return            number of samples actually written, or negative AVERROR"]
    #[doc = "                    code on failure. If successful, the number of samples"]
    #[doc = "                    actually written will always be nb_samples."]
    pub fn av_audio_fifo_write(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Peek data from an AVAudioFifo."]
    #[doc = ""]
    #[doc = " @see enum AVSampleFormat"]
    #[doc = " The documentation for AVSampleFormat describes the data layout."]
    #[doc = ""]
    #[doc = " @param af          AVAudioFifo to read from"]
    #[doc = " @param data        audio data plane pointers"]
    #[doc = " @param nb_samples  number of samples to peek"]
    #[doc = " @return            number of samples actually peek, or negative AVERROR code"]
    #[doc = "                    on failure. The number of samples actually peek will not"]
    #[doc = "                    be greater than nb_samples, and will only be less than"]
    #[doc = "                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_peek(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Peek data from an AVAudioFifo."]
    #[doc = ""]
    #[doc = " @see enum AVSampleFormat"]
    #[doc = " The documentation for AVSampleFormat describes the data layout."]
    #[doc = ""]
    #[doc = " @param af          AVAudioFifo to read from"]
    #[doc = " @param data        audio data plane pointers"]
    #[doc = " @param nb_samples  number of samples to peek"]
    #[doc = " @param offset      offset from current read position"]
    #[doc = " @return            number of samples actually peek, or negative AVERROR code"]
    #[doc = "                    on failure. The number of samples actually peek will not"]
    #[doc = "                    be greater than nb_samples, and will only be less than"]
    #[doc = "                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_peek_at(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
        offset: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read data from an AVAudioFifo."]
    #[doc = ""]
    #[doc = " @see enum AVSampleFormat"]
    #[doc = " The documentation for AVSampleFormat describes the data layout."]
    #[doc = ""]
    #[doc = " @param af          AVAudioFifo to read from"]
    #[doc = " @param data        audio data plane pointers"]
    #[doc = " @param nb_samples  number of samples to read"]
    #[doc = " @return            number of samples actually read, or negative AVERROR code"]
    #[doc = "                    on failure. The number of samples actually read will not"]
    #[doc = "                    be greater than nb_samples, and will only be less than"]
    #[doc = "                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_read(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Drain data from an AVAudioFifo."]
    #[doc = ""]
    #[doc = " Removes the data without reading it."]
    #[doc = ""]
    #[doc = " @param af          AVAudioFifo to drain"]
    #[doc = " @param nb_samples  number of samples to drain"]
    #[doc = " @return            0 if OK, or negative AVERROR code on failure"]
    pub fn av_audio_fifo_drain(af: *mut AVAudioFifo, nb_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Reset the AVAudioFifo buffer."]
    #[doc = ""]
    #[doc = " This empties all data in the buffer."]
    #[doc = ""]
    #[doc = " @param af  AVAudioFifo to reset"]
    pub fn av_audio_fifo_reset(af: *mut AVAudioFifo);
}
extern "C" {
    #[doc = " Get the current number of samples in the AVAudioFifo available for reading."]
    #[doc = ""]
    #[doc = " @param af  the AVAudioFifo to query"]
    #[doc = " @return    number of samples available for reading"]
    pub fn av_audio_fifo_size(af: *mut AVAudioFifo) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current number of samples in the AVAudioFifo available for writing."]
    #[doc = ""]
    #[doc = " @param af  the AVAudioFifo to query"]
    #[doc = " @return    number of samples available for writing"]
    pub fn av_audio_fifo_space(af: *mut AVAudioFifo) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode a base64-encoded string."]
    #[doc = ""]
    #[doc = " @param out      buffer for decoded data"]
    #[doc = " @param in       null-terminated input string"]
    #[doc = " @param out_size size in bytes of the out buffer, must be at"]
    #[doc = "                 least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))"]
    #[doc = " @return         number of bytes written, or a negative value in case of"]
    #[doc = "                 invalid input"]
    pub fn av_base64_decode(
        out: *mut u8,
        in_: *const libc::c_char,
        out_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encode data to base64 and null-terminate."]
    #[doc = ""]
    #[doc = " @param out      buffer for encoded data"]
    #[doc = " @param out_size size in bytes of the out buffer (including the"]
    #[doc = "                 null terminator), must be at least AV_BASE64_SIZE(in_size)"]
    #[doc = " @param in       input buffer containing the data to encode"]
    #[doc = " @param in_size  size in bytes of the in buffer"]
    #[doc = " @return         out or NULL in case of error"]
    pub fn av_base64_encode(
        out: *mut libc::c_char,
        out_size: libc::c_int,
        in_: *const u8,
        in_size: libc::c_int,
    ) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBlowfish {
    pub p: [u32; 18usize],
    pub s: [[u32; 256usize]; 4usize],
}
#[test]
fn bindgen_test_layout_AVBlowfish() {
    assert_eq!(
        ::std::mem::size_of::<AVBlowfish>(),
        4168usize,
        concat!("Size of: ", stringify!(AVBlowfish))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBlowfish>(),
        4usize,
        concat!("Alignment of ", stringify!(AVBlowfish))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBlowfish>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBlowfish),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBlowfish>())).s as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBlowfish),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVBlowfish context."]
    pub fn av_blowfish_alloc() -> *mut AVBlowfish;
}
extern "C" {
    #[doc = " Initialize an AVBlowfish context."]
    #[doc = ""]
    #[doc = " @param ctx an AVBlowfish context"]
    #[doc = " @param key a key"]
    #[doc = " @param key_len length of the key"]
    pub fn av_blowfish_init(ctx: *mut AVBlowfish, key: *const u8, key_len: libc::c_int);
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context."]
    #[doc = ""]
    #[doc = " @param ctx an AVBlowfish context"]
    #[doc = " @param xl left four bytes halves of input to be encrypted"]
    #[doc = " @param xr right four bytes halves of input to be encrypted"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_blowfish_crypt_ecb(
        ctx: *mut AVBlowfish,
        xl: *mut u32,
        xr: *mut u32,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context."]
    #[doc = ""]
    #[doc = " @param ctx an AVBlowfish context"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param count number of 8 byte blocks"]
    #[doc = " @param iv initialization vector for CBC mode, if NULL ECB will be used"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_blowfish_crypt(
        ctx: *mut AVBlowfish,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str. If it is, *ptr is set to"]
    #[doc = " the address of the first character in str after the prefix."]
    #[doc = ""]
    #[doc = " @param str input string"]
    #[doc = " @param pfx prefix to test"]
    #[doc = " @param ptr updated if the prefix is matched inside str"]
    #[doc = " @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_strstart(
        str_: *const libc::c_char,
        pfx: *const libc::c_char,
        ptr: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str independent of case. If"]
    #[doc = " it is, *ptr is set to the address of the first character in str"]
    #[doc = " after the prefix."]
    #[doc = ""]
    #[doc = " @param str input string"]
    #[doc = " @param pfx prefix to test"]
    #[doc = " @param ptr updated if the prefix is matched inside str"]
    #[doc = " @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_stristart(
        str_: *const libc::c_char,
        pfx: *const libc::c_char,
        ptr: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Locate the first case-independent occurrence in the string haystack"]
    #[doc = " of the string needle.  A zero-length string needle is considered to"]
    #[doc = " match at the start of haystack."]
    #[doc = ""]
    #[doc = " This function is a case-insensitive version of the standard strstr()."]
    #[doc = ""]
    #[doc = " @param haystack string to search in"]
    #[doc = " @param needle   string to search for"]
    #[doc = " @return         pointer to the located match within haystack"]
    #[doc = "                 or a null pointer if no match"]
    pub fn av_stristr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Locate the first occurrence of the string needle in the string haystack"]
    #[doc = " where not more than hay_length characters are searched. A zero-length"]
    #[doc = " string needle is considered to match at the start of haystack."]
    #[doc = ""]
    #[doc = " This function is a length-limited version of the standard strstr()."]
    #[doc = ""]
    #[doc = " @param haystack   string to search in"]
    #[doc = " @param needle     string to search for"]
    #[doc = " @param hay_length length of string to search in"]
    #[doc = " @return           pointer to the located match within haystack"]
    #[doc = "                   or a null pointer if no match"]
    pub fn av_strnstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
        hay_length: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Copy the string src to dst, but no more than size - 1 bytes, and"]
    #[doc = " null-terminate dst."]
    #[doc = ""]
    #[doc = " This function is the same as BSD strlcpy()."]
    #[doc = ""]
    #[doc = " @param dst destination buffer"]
    #[doc = " @param src source string"]
    #[doc = " @param size size of destination buffer"]
    #[doc = " @return the length of src"]
    #[doc = ""]
    #[doc = " @warning since the return value is the length of src, src absolutely"]
    #[doc = " _must_ be a properly 0-terminated string, otherwise this will read beyond"]
    #[doc = " the end of the buffer and possibly crash."]
    pub fn av_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Append the string src to the string dst, but to a total length of"]
    #[doc = " no more than size - 1 bytes, and null-terminate dst."]
    #[doc = ""]
    #[doc = " This function is similar to BSD strlcat(), but differs when"]
    #[doc = " size <= strlen(dst)."]
    #[doc = ""]
    #[doc = " @param dst destination buffer"]
    #[doc = " @param src source string"]
    #[doc = " @param size size of destination buffer"]
    #[doc = " @return the total length of src and dst"]
    #[doc = ""]
    #[doc = " @warning since the return value use the length of src and dst, these"]
    #[doc = " absolutely _must_ be a properly 0-terminated strings, otherwise this"]
    #[doc = " will read beyond the end of the buffer and possibly crash."]
    pub fn av_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Append output to a string, according to a format. Never write out of"]
    #[doc = " the destination buffer, and always put a terminating 0 within"]
    #[doc = " the buffer."]
    #[doc = " @param dst destination buffer (string to which the output is"]
    #[doc = "  appended)"]
    #[doc = " @param size total size of the destination buffer"]
    #[doc = " @param fmt printf-compatible format string, specifying how the"]
    #[doc = "  following parameters are used"]
    #[doc = " @return the length of the string that would have been generated"]
    #[doc = "  if enough space had been available"]
    pub fn av_strlcatf(dst: *mut libc::c_char, size: usize, fmt: *const libc::c_char, ...)
        -> usize;
}
extern "C" {
    #[doc = " Print arguments following specified format into a large enough auto"]
    #[doc = " allocated buffer. It is similar to GNU asprintf()."]
    #[doc = " @param fmt printf-compatible format string, specifying how the"]
    #[doc = "            following parameters are used."]
    #[doc = " @return the allocated string"]
    #[doc = " @note You have to free the string yourself with av_free()."]
    pub fn av_asprintf(fmt: *const libc::c_char, ...) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Convert a number to an av_malloced string."]
    #[doc = " @deprecated  use av_asprintf() with \"%f\" or a more specific format"]
    pub fn av_d2str(d: f64) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Unescape the given string until a non escaped terminating char,"]
    #[doc = " and return the token corresponding to the unescaped string."]
    #[doc = ""]
    #[doc = " The normal \\ and ' escaping is supported. Leading and trailing"]
    #[doc = " whitespaces are removed, unless they are escaped with '\\' or are"]
    #[doc = " enclosed between ''."]
    #[doc = ""]
    #[doc = " @param buf the buffer to parse, buf will be updated to point to the"]
    #[doc = " terminating char"]
    #[doc = " @param term a 0-terminated list of terminating chars"]
    #[doc = " @return the malloced unescaped string, which must be av_freed by"]
    #[doc = " the user, NULL in case of allocation failure"]
    pub fn av_get_token(
        buf: *mut *const libc::c_char,
        term: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Split the string into several tokens which can be accessed by"]
    #[doc = " successive calls to av_strtok()."]
    #[doc = ""]
    #[doc = " A token is defined as a sequence of characters not belonging to the"]
    #[doc = " set specified in delim."]
    #[doc = ""]
    #[doc = " On the first call to av_strtok(), s should point to the string to"]
    #[doc = " parse, and the value of saveptr is ignored. In subsequent calls, s"]
    #[doc = " should be NULL, and saveptr should be unchanged since the previous"]
    #[doc = " call."]
    #[doc = ""]
    #[doc = " This function is similar to strtok_r() defined in POSIX.1."]
    #[doc = ""]
    #[doc = " @param s the string to parse, may be NULL"]
    #[doc = " @param delim 0-terminated list of token delimiters, must be non-NULL"]
    #[doc = " @param saveptr user-provided pointer which points to stored"]
    #[doc = " information necessary for av_strtok() to continue scanning the same"]
    #[doc = " string. saveptr is updated to point to the next character after the"]
    #[doc = " first delimiter found, or to NULL if the string was terminated"]
    #[doc = " @return the found token, or NULL when no token is found"]
    pub fn av_strtok(
        s: *mut libc::c_char,
        delim: *const libc::c_char,
        saveptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Locale-independent case-insensitive compare."]
    #[doc = " @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strcasecmp(a: *const libc::c_char, b: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Locale-independent case-insensitive compare."]
    #[doc = " @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strncasecmp(a: *const libc::c_char, b: *const libc::c_char, n: usize) -> libc::c_int;
}
extern "C" {
    #[doc = " Locale-independent strings replace."]
    #[doc = " @note This means only ASCII-range characters are replace"]
    pub fn av_strireplace(
        str_: *const libc::c_char,
        from: *const libc::c_char,
        to: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Thread safe basename."]
    #[doc = " @param path the string to parse, on DOS both \\ and / are considered separators."]
    #[doc = " @return pointer to the basename substring."]
    #[doc = " If path does not contain a slash, the function returns a copy of path."]
    #[doc = " If path is a NULL pointer or points to an empty string, a pointer"]
    #[doc = " to a string \".\" is returned."]
    pub fn av_basename(path: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Thread safe dirname."]
    #[doc = " @param path the string to parse, on DOS both \\ and / are considered separators."]
    #[doc = " @return A pointer to a string that's the parent directory of path."]
    #[doc = " If path is a NULL pointer or points to an empty string, a pointer"]
    #[doc = " to a string \".\" is returned."]
    #[doc = " @note the function may modify the contents of the path, so copies should be passed."]
    pub fn av_dirname(path: *mut libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Match instances of a name in a comma-separated list of names."]
    #[doc = " List entries are checked from the start to the end of the names list,"]
    #[doc = " the first match ends further processing. If an entry prefixed with '-'"]
    #[doc = " matches, then 0 is returned. The \"ALL\" list entry is considered to"]
    #[doc = " match all names."]
    #[doc = ""]
    #[doc = " @param name  Name to look for."]
    #[doc = " @param names List of names."]
    #[doc = " @return 1 on match, 0 otherwise."]
    pub fn av_match_name(name: *const libc::c_char, names: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Append path component to the existing path."]
    #[doc = " Path separator '/' is placed between when needed."]
    #[doc = " Resulting string have to be freed with av_free()."]
    #[doc = " @param path      base path"]
    #[doc = " @param component component to be appended"]
    #[doc = " @return new path or NULL on error."]
    pub fn av_append_path_component(
        path: *const libc::c_char,
        component: *const libc::c_char,
    ) -> *mut libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVEscapeMode {
    #[doc = "< Use auto-selected escaping mode."]
    AV_ESCAPE_MODE_AUTO = 0,
    #[doc = "< Use backslash escaping."]
    AV_ESCAPE_MODE_BACKSLASH = 1,
    #[doc = "< Use single-quote escaping."]
    AV_ESCAPE_MODE_QUOTE = 2,
    #[doc = "< Use XML non-markup character data escaping."]
    AV_ESCAPE_MODE_XML = 3,
}
extern "C" {
    #[doc = " Escape string in src, and put the escaped string in an allocated"]
    #[doc = " string in *dst, which must be freed with av_free()."]
    #[doc = ""]
    #[doc = " @param dst           pointer where an allocated string is put"]
    #[doc = " @param src           string to escape, must be non-NULL"]
    #[doc = " @param special_chars string containing the special characters which"]
    #[doc = "                      need to be escaped, can be NULL"]
    #[doc = " @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros."]
    #[doc = "                      Any unknown value for mode will be considered equivalent to"]
    #[doc = "                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without"]
    #[doc = "                      notice."]
    #[doc = " @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros"]
    #[doc = " @return the length of the allocated string, or a negative error code in case of error"]
    #[doc = " @see av_bprint_escape()"]
    pub fn av_escape(
        dst: *mut *mut libc::c_char,
        src: *const libc::c_char,
        special_chars: *const libc::c_char,
        mode: AVEscapeMode,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read and decode a single UTF-8 code point (character) from the"]
    #[doc = " buffer in *buf, and update *buf to point to the next byte to"]
    #[doc = " decode."]
    #[doc = ""]
    #[doc = " In case of an invalid byte sequence, the pointer will be updated to"]
    #[doc = " the next byte after the invalid sequence and the function will"]
    #[doc = " return an error code."]
    #[doc = ""]
    #[doc = " Depending on the specified flags, the function will also fail in"]
    #[doc = " case the decoded code point does not belong to a valid range."]
    #[doc = ""]
    #[doc = " @note For speed-relevant code a carefully implemented use of"]
    #[doc = " GET_UTF8() may be preferred."]
    #[doc = ""]
    #[doc = " @param codep   pointer used to return the parsed code in case of success."]
    #[doc = "                The value in *codep is set even in case the range check fails."]
    #[doc = " @param bufp    pointer to the address the first byte of the sequence"]
    #[doc = "                to decode, updated by the function to point to the"]
    #[doc = "                byte next after the decoded sequence"]
    #[doc = " @param buf_end pointer to the end of the buffer, points to the next"]
    #[doc = "                byte past the last in the buffer. This is used to"]
    #[doc = "                avoid buffer overreads (in case of an unfinished"]
    #[doc = "                UTF-8 sequence towards the end of the buffer)."]
    #[doc = " @param flags   a collection of AV_UTF8_FLAG_* flags"]
    #[doc = " @return >= 0 in case a sequence was successfully read, a negative"]
    #[doc = " value in case of invalid sequence"]
    pub fn av_utf8_decode(
        codep: *mut i32,
        bufp: *mut *const u8,
        buf_end: *const u8,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if a name is in a list."]
    #[doc = " @returns 0 if not found, or the 1 based index where it has been found in the"]
    #[doc = "            list."]
    pub fn av_match_list(
        name: *const libc::c_char,
        list: *const libc::c_char,
        separator: libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " See libc sscanf manual for more information."]
    #[doc = " Locale-independent sscanf implementation."]
    pub fn av_sscanf(string: *const libc::c_char, format: *const libc::c_char, ...) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ff_pad_helper_AVBPrint {
    pub str_: *mut libc::c_char,
    pub len: libc::c_uint,
    pub size: libc::c_uint,
    pub size_max: libc::c_uint,
    pub reserved_internal_buffer: [libc::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_ff_pad_helper_AVBPrint() {
    assert_eq!(
        ::std::mem::size_of::<ff_pad_helper_AVBPrint>(),
        24usize,
        concat!("Size of: ", stringify!(ff_pad_helper_AVBPrint))
    );
    assert_eq!(
        ::std::mem::align_of::<ff_pad_helper_AVBPrint>(),
        8usize,
        concat!("Alignment of ", stringify!(ff_pad_helper_AVBPrint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).size_max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(size_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).reserved_internal_buffer as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(reserved_internal_buffer)
        )
    );
}
#[doc = " Buffer to print data progressively"]
#[doc = ""]
#[doc = " The string buffer grows as necessary and is always 0-terminated."]
#[doc = " The content of the string is never accessed, and thus is"]
#[doc = " encoding-agnostic and can even hold binary data."]
#[doc = ""]
#[doc = " Small buffers are kept in the structure itself, and thus require no"]
#[doc = " memory allocation at all (unless the contents of the buffer is needed"]
#[doc = " after the structure goes out of scope). This is almost as lightweight as"]
#[doc = " declaring a local \"char buf[512]\"."]
#[doc = ""]
#[doc = " The length of the string can go beyond the allocated size: the buffer is"]
#[doc = " then truncated, but the functions still keep account of the actual total"]
#[doc = " length."]
#[doc = ""]
#[doc = " In other words, buf->len can be greater than buf->size and records the"]
#[doc = " total length of what would have been to the buffer if there had been"]
#[doc = " enough memory."]
#[doc = ""]
#[doc = " Append operations do not need to be tested for failure: if a memory"]
#[doc = " allocation fails, data stop being appended to the buffer, but the length"]
#[doc = " is still updated. This situation can be tested with"]
#[doc = " av_bprint_is_complete()."]
#[doc = ""]
#[doc = " The size_max field determines several possible behaviours:"]
#[doc = ""]
#[doc = " size_max = -1 (= UINT_MAX) or any large value will let the buffer be"]
#[doc = " reallocated as necessary, with an amortized linear cost."]
#[doc = ""]
#[doc = " size_max = 0 prevents writing anything to the buffer: only the total"]
#[doc = " length is computed. The write operations can then possibly be repeated in"]
#[doc = " a buffer with exactly the necessary size"]
#[doc = " (using size_init = size_max = len + 1)."]
#[doc = ""]
#[doc = " size_max = 1 is automatically replaced by the exact size available in the"]
#[doc = " structure itself, thus ensuring no dynamic memory allocation. The"]
#[doc = " internal buffer is large enough to hold a reasonable paragraph of text,"]
#[doc = " such as the current paragraph."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBPrint {
    pub str_: *mut libc::c_char,
    pub len: libc::c_uint,
    pub size: libc::c_uint,
    pub size_max: libc::c_uint,
    pub reserved_internal_buffer: [libc::c_char; 1usize],
    pub reserved_padding: [libc::c_char; 1000usize],
}
#[test]
fn bindgen_test_layout_AVBPrint() {
    assert_eq!(
        ::std::mem::size_of::<AVBPrint>(),
        1024usize,
        concat!("Size of: ", stringify!(AVBPrint))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBPrint>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBPrint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).size_max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(size_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBPrint>())).reserved_internal_buffer as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(reserved_internal_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).reserved_padding as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(reserved_padding)
        )
    );
}
extern "C" {
    #[doc = " Init a print buffer."]
    #[doc = ""]
    #[doc = " @param buf        buffer to init"]
    #[doc = " @param size_init  initial size (including the final 0)"]
    #[doc = " @param size_max   maximum size;"]
    #[doc = "                   0 means do not write anything, just count the length;"]
    #[doc = "                   1 is replaced by the maximum value for automatic storage;"]
    #[doc = "                   any large value means that the internal buffer will be"]
    #[doc = "                   reallocated as needed up to that limit; -1 is converted to"]
    #[doc = "                   UINT_MAX, the largest limit possible."]
    #[doc = "                   Check also AV_BPRINT_SIZE_* macros."]
    pub fn av_bprint_init(buf: *mut AVBPrint, size_init: libc::c_uint, size_max: libc::c_uint);
}
extern "C" {
    #[doc = " Init a print buffer using a pre-existing buffer."]
    #[doc = ""]
    #[doc = " The buffer will not be reallocated."]
    #[doc = ""]
    #[doc = " @param buf     buffer structure to init"]
    #[doc = " @param buffer  byte buffer to use for the string data"]
    #[doc = " @param size    size of buffer"]
    pub fn av_bprint_init_for_buffer(
        buf: *mut AVBPrint,
        buffer: *mut libc::c_char,
        size: libc::c_uint,
    );
}
extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_bprintf(buf: *mut AVBPrint, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_vbprintf(buf: *mut AVBPrint, fmt: *const libc::c_char, vl_arg: *mut __va_list_tag);
}
extern "C" {
    #[doc = " Append char c n times to a print buffer."]
    pub fn av_bprint_chars(buf: *mut AVBPrint, c: libc::c_char, n: libc::c_uint);
}
extern "C" {
    #[doc = " Append data to a print buffer."]
    #[doc = ""]
    #[doc = " param buf  bprint buffer to use"]
    #[doc = " param data pointer to data"]
    #[doc = " param size size of data"]
    pub fn av_bprint_append_data(buf: *mut AVBPrint, data: *const libc::c_char, size: libc::c_uint);
}
extern "C" {
    #[doc = " Append a formatted date and time to a print buffer."]
    #[doc = ""]
    #[doc = " param buf  bprint buffer to use"]
    #[doc = " param fmt  date and time format string, see strftime()"]
    #[doc = " param tm   broken-down time structure to translate"]
    #[doc = ""]
    #[doc = " @note due to poor design of the standard strftime function, it may"]
    #[doc = " produce poor results if the format string expands to a very long text and"]
    #[doc = " the bprint buffer is near the limit stated by the size_max option."]
    pub fn av_bprint_strftime(buf: *mut AVBPrint, fmt: *const libc::c_char, tm: *const tm);
}
extern "C" {
    #[doc = " Allocate bytes in the buffer for external use."]
    #[doc = ""]
    #[doc = " @param[in]  buf          buffer structure"]
    #[doc = " @param[in]  size         required size"]
    #[doc = " @param[out] mem          pointer to the memory area"]
    #[doc = " @param[out] actual_size  size of the memory area after allocation;"]
    #[doc = "                          can be larger or smaller than size"]
    pub fn av_bprint_get_buffer(
        buf: *mut AVBPrint,
        size: libc::c_uint,
        mem: *mut *mut libc::c_uchar,
        actual_size: *mut libc::c_uint,
    );
}
extern "C" {
    #[doc = " Reset the string to \"\" but keep internal allocated data."]
    pub fn av_bprint_clear(buf: *mut AVBPrint);
}
extern "C" {
    #[doc = " Finalize a print buffer."]
    #[doc = ""]
    #[doc = " The print buffer can no longer be used afterwards,"]
    #[doc = " but the len and size fields are still valid."]
    #[doc = ""]
    #[doc = " @arg[out] ret_str  if not NULL, used to return a permanent copy of the"]
    #[doc = "                    buffer contents, or NULL if memory allocation fails;"]
    #[doc = "                    if NULL, the buffer is discarded and freed"]
    #[doc = " @return  0 for success or error code (probably AVERROR(ENOMEM))"]
    pub fn av_bprint_finalize(buf: *mut AVBPrint, ret_str: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Escape the content in src and append it to dstbuf."]
    #[doc = ""]
    #[doc = " @param dstbuf        already inited destination bprint buffer"]
    #[doc = " @param src           string containing the text to escape"]
    #[doc = " @param special_chars string containing the special characters which"]
    #[doc = "                      need to be escaped, can be NULL"]
    #[doc = " @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros."]
    #[doc = "                      Any unknown value for mode will be considered equivalent to"]
    #[doc = "                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without"]
    #[doc = "                      notice."]
    #[doc = " @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros"]
    pub fn av_bprint_escape(
        dstbuf: *mut AVBPrint,
        src: *const libc::c_char,
        special_chars: *const libc::c_char,
        mode: AVEscapeMode,
        flags: libc::c_int,
    );
}
extern "C" {
    #[doc = " @file"]
    #[doc = " @brief Public header for libavutil CAMELLIA algorithm"]
    #[doc = " @defgroup lavu_camellia CAMELLIA"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    pub static av_camellia_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAMELLIA {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVCAMELLIA context"]
    #[doc = " To free the struct: av_free(ptr)"]
    pub fn av_camellia_alloc() -> *mut AVCAMELLIA;
}
extern "C" {
    #[doc = " Initialize an AVCAMELLIA context."]
    #[doc = ""]
    #[doc = " @param ctx an AVCAMELLIA context"]
    #[doc = " @param key a key of 16, 24, 32 bytes used for encryption/decryption"]
    #[doc = " @param key_bits number of keybits: possible are 128, 192, 256"]
    pub fn av_camellia_init(
        ctx: *mut AVCAMELLIA,
        key: *const u8,
        key_bits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context"]
    #[doc = ""]
    #[doc = " @param ctx an AVCAMELLIA context"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param count number of 16 byte blocks"]
    #[doc = " @paran iv initialization vector for CBC mode, NULL for ECB mode"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_camellia_crypt(
        ctx: *mut AVCAMELLIA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " @file"]
    #[doc = " @brief Public header for libavutil CAST5 algorithm"]
    #[doc = " @defgroup lavu_cast5 CAST5"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    pub static av_cast5_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAST5 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVCAST5 context"]
    #[doc = " To free the struct: av_free(ptr)"]
    pub fn av_cast5_alloc() -> *mut AVCAST5;
}
extern "C" {
    #[doc = " Initialize an AVCAST5 context."]
    #[doc = ""]
    #[doc = " @param ctx an AVCAST5 context"]
    #[doc = " @param key a key of 5,6,...16 bytes used for encryption/decryption"]
    #[doc = " @param key_bits number of keybits: possible are 40,48,...,128"]
    #[doc = " @return 0 on success, less than 0 on failure"]
    pub fn av_cast5_init(ctx: *mut AVCAST5, key: *const u8, key_bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context, ECB mode only"]
    #[doc = ""]
    #[doc = " @param ctx an AVCAST5 context"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param count number of 8 byte blocks"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_cast5_crypt(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context"]
    #[doc = ""]
    #[doc = " @param ctx an AVCAST5 context"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param count number of 8 byte blocks"]
    #[doc = " @param iv initialization vector for CBC mode, NULL for ECB mode"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_cast5_crypt2(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
pub const AV_CH_FRONT_LEFT: libc::c_ulonglong = 1;
pub const AV_CH_FRONT_RIGHT: libc::c_ulonglong = 2;
pub const AV_CH_FRONT_CENTER: libc::c_ulonglong = 4;
pub const AV_CH_LOW_FREQUENCY: libc::c_ulonglong = 8;
pub const AV_CH_BACK_LEFT: libc::c_ulonglong = 16;
pub const AV_CH_BACK_RIGHT: libc::c_ulonglong = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: libc::c_ulonglong = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: libc::c_ulonglong = 128;
pub const AV_CH_BACK_CENTER: libc::c_ulonglong = 256;
pub const AV_CH_SIDE_LEFT: libc::c_ulonglong = 512;
pub const AV_CH_SIDE_RIGHT: libc::c_ulonglong = 1024;
pub const AV_CH_TOP_CENTER: libc::c_ulonglong = 2048;
pub const AV_CH_TOP_FRONT_LEFT: libc::c_ulonglong = 4096;
pub const AV_CH_TOP_FRONT_CENTER: libc::c_ulonglong = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: libc::c_ulonglong = 16384;
pub const AV_CH_TOP_BACK_LEFT: libc::c_ulonglong = 32768;
pub const AV_CH_TOP_BACK_CENTER: libc::c_ulonglong = 65536;
pub const AV_CH_TOP_BACK_RIGHT: libc::c_ulonglong = 131072;
pub const AV_CH_STEREO_LEFT: libc::c_ulonglong = 536870912;
pub const AV_CH_STEREO_RIGHT: libc::c_ulonglong = 1073741824;
pub const AV_CH_WIDE_LEFT: libc::c_ulonglong = 2147483648;
pub const AV_CH_WIDE_RIGHT: libc::c_ulonglong = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: libc::c_ulonglong = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: libc::c_ulonglong = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: libc::c_ulonglong = 34359738368;
pub const AV_CH_TOP_SIDE_LEFT: libc::c_ulonglong = 68719476736;
pub const AV_CH_TOP_SIDE_RIGHT: libc::c_ulonglong = 137438953472;
pub const AV_CH_BOTTOM_FRONT_CENTER: libc::c_ulonglong = 274877906944;
pub const AV_CH_BOTTOM_FRONT_LEFT: libc::c_ulonglong = 549755813888;
pub const AV_CH_BOTTOM_FRONT_RIGHT: libc::c_ulonglong = 1099511627776;
pub const AV_CH_LAYOUT_MONO: libc::c_ulonglong = 4;
pub const AV_CH_LAYOUT_STEREO: libc::c_ulonglong = 3;
pub const AV_CH_LAYOUT_2POINT1: libc::c_ulonglong = 11;
pub const AV_CH_LAYOUT_2_1: libc::c_ulonglong = 259;
pub const AV_CH_LAYOUT_SURROUND: libc::c_ulonglong = 7;
pub const AV_CH_LAYOUT_3POINT1: libc::c_ulonglong = 15;
pub const AV_CH_LAYOUT_4POINT0: libc::c_ulonglong = 263;
pub const AV_CH_LAYOUT_4POINT1: libc::c_ulonglong = 271;
pub const AV_CH_LAYOUT_2_2: libc::c_ulonglong = 1539;
pub const AV_CH_LAYOUT_QUAD: libc::c_ulonglong = 51;
pub const AV_CH_LAYOUT_5POINT0: libc::c_ulonglong = 1543;
pub const AV_CH_LAYOUT_5POINT1: libc::c_ulonglong = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: libc::c_ulonglong = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: libc::c_ulonglong = 63;
pub const AV_CH_LAYOUT_6POINT0: libc::c_ulonglong = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: libc::c_ulonglong = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: libc::c_ulonglong = 311;
pub const AV_CH_LAYOUT_6POINT1: libc::c_ulonglong = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: libc::c_ulonglong = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: libc::c_ulonglong = 1739;
pub const AV_CH_LAYOUT_7POINT0: libc::c_ulonglong = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: libc::c_ulonglong = 1735;
pub const AV_CH_LAYOUT_7POINT1: libc::c_ulonglong = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: libc::c_ulonglong = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: libc::c_ulonglong = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: libc::c_ulonglong = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: libc::c_ulonglong = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: libc::c_ulonglong = 1610612736;
pub const AV_CH_LAYOUT_22POINT2: libc::c_ulonglong = 2164663779327;
extern "C" {
    #[doc = " Return the flags which specify extensions supported by the CPU."]
    #[doc = " The returned value is affected by av_force_cpu_flags() if that was used"]
    #[doc = " before. So av_get_cpu_flags() can easily be used in an application to"]
    #[doc = " detect the enabled cpu flags."]
    pub fn av_get_cpu_flags() -> libc::c_int;
}
extern "C" {
    #[doc = " Disables cpu detection and forces the specified flags."]
    #[doc = " -1 is a special case that disables forcing of specific flags."]
    pub fn av_force_cpu_flags(flags: libc::c_int);
}
extern "C" {
    #[doc = " Parse CPU caps from a string and update the given AV_CPU_* flags based on that."]
    #[doc = ""]
    #[doc = " @return negative on error."]
    pub fn av_parse_cpu_caps(flags: *mut libc::c_uint, s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the number of logical CPU cores present."]
    pub fn av_cpu_count() -> libc::c_int;
}
extern "C" {
    #[doc = " Overrides cpu count detection and forces the specified count."]
    #[doc = " Count < 1 disables forcing of specific count."]
    pub fn av_cpu_force_count(count: libc::c_int);
}
extern "C" {
    #[doc = " Get the maximum data alignment that may be required by FFmpeg."]
    #[doc = ""]
    #[doc = " Note that this is affected by the build configuration and the CPU flags mask,"]
    #[doc = " so e.g. if the CPU supports AVX, but libavutil has been built with"]
    #[doc = " --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through"]
    #[doc = "  av_set_cpu_flags_mask(), then this function will behave as if AVX is not"]
    #[doc = "  present."]
    pub fn av_cpu_max_align() -> usize;
}
#[doc = " @defgroup lavu_crc32 CRC"]
#[doc = " @ingroup lavu_hash"]
#[doc = " CRC (Cyclic Redundancy Check) hash function implementation."]
#[doc = ""]
#[doc = " This module supports numerous CRC polynomials, in addition to the most"]
#[doc = " widely used CRC-32-IEEE. See @ref AVCRCId for a list of available"]
#[doc = " polynomials."]
#[doc = ""]
#[doc = " @{"]
pub type AVCRC = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVCRCId {
    AV_CRC_8_ATM = 0,
    AV_CRC_16_ANSI = 1,
    AV_CRC_16_CCITT = 2,
    AV_CRC_32_IEEE = 3,
    AV_CRC_32_IEEE_LE = 4,
    AV_CRC_16_ANSI_LE = 5,
    AV_CRC_24_IEEE = 6,
    AV_CRC_8_EBU = 7,
    AV_CRC_MAX = 8,
}
extern "C" {
    #[doc = " Initialize a CRC table."]
    #[doc = " @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024"]
    #[doc = " @param le If 1, the lowest bit represents the coefficient for the highest"]
    #[doc = "           exponent of the corresponding polynomial (both for poly and"]
    #[doc = "           actual CRC)."]
    #[doc = "           If 0, you must swap the CRC parameter and the result of av_crc"]
    #[doc = "           if you need the standard representation (can be simplified in"]
    #[doc = "           most cases to e.g. bswap16):"]
    #[doc = "           av_bswap32(crc << (32-bits))"]
    #[doc = " @param bits number of bits for the CRC"]
    #[doc = " @param poly generator polynomial without the x**bits coefficient, in the"]
    #[doc = "             representation as specified by le"]
    #[doc = " @param ctx_size size of ctx in bytes"]
    #[doc = " @return <0 on failure"]
    pub fn av_crc_init(
        ctx: *mut AVCRC,
        le: libc::c_int,
        bits: libc::c_int,
        poly: u32,
        ctx_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get an initialized standard CRC table."]
    #[doc = " @param crc_id ID of a standard CRC"]
    #[doc = " @return a pointer to the CRC table or NULL on failure"]
    pub fn av_crc_get_table(crc_id: AVCRCId) -> *const AVCRC;
}
extern "C" {
    #[doc = " Calculate the CRC of a block."]
    #[doc = " @param crc CRC of previous blocks if any or initial value for CRC"]
    #[doc = " @return CRC updated with the data from the given block"]
    #[doc = ""]
    #[doc = " @see av_crc_init() \"le\" parameter"]
    pub fn av_crc(ctx: *const AVCRC, crc: u32, buffer: *const u8, length: usize) -> u32;
}
extern "C" {
    #[doc = " Extract the rotation component of the transformation matrix."]
    #[doc = ""]
    #[doc = " @param matrix the transformation matrix"]
    #[doc = " @return the angle (in degrees) by which the transformation rotates the frame"]
    #[doc = "         counterclockwise. The angle will be in range [-180.0, 180.0],"]
    #[doc = "         or NaN if the matrix is singular."]
    #[doc = ""]
    #[doc = " @note floating point numbers are inherently inexact, so callers are"]
    #[doc = "       recommended to round the return value to nearest integer before use."]
    pub fn av_display_rotation_get(matrix: *const i32) -> f64;
}
extern "C" {
    #[doc = " Initialize a transformation matrix describing a pure clockwise"]
    #[doc = " rotation by the specified angle (in degrees)."]
    #[doc = ""]
    #[doc = " @param matrix an allocated transformation matrix (will be fully overwritten"]
    #[doc = "               by this function)"]
    #[doc = " @param angle rotation angle in degrees."]
    pub fn av_display_rotation_set(matrix: *mut i32, angle: f64);
}
extern "C" {
    #[doc = " Flip the input matrix horizontally and/or vertically."]
    #[doc = ""]
    #[doc = " @param matrix an allocated transformation matrix"]
    #[doc = " @param hflip whether the matrix should be flipped horizontally"]
    #[doc = " @param vflip whether the matrix should be flipped vertically"]
    pub fn av_display_matrix_flip(matrix: *mut i32, hflip: libc::c_int, vflip: libc::c_int);
}
#[repr(u32)]
#[doc = " Possible downmix types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDownmixType {
    #[doc = "< Not indicated."]
    AV_DOWNMIX_TYPE_UNKNOWN = 0,
    #[doc = "< Lo/Ro 2-channel downmix (Stereo)."]
    AV_DOWNMIX_TYPE_LORO = 1,
    #[doc = "< Lt/Rt 2-channel downmix, Dolby Surround compatible."]
    AV_DOWNMIX_TYPE_LTRT = 2,
    #[doc = "< Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible."]
    AV_DOWNMIX_TYPE_DPLII = 3,
    #[doc = "< Number of downmix types. Not part of ABI."]
    AV_DOWNMIX_TYPE_NB = 4,
}
#[doc = " This structure describes optional metadata relevant to a downmix procedure."]
#[doc = ""]
#[doc = " All fields are set by the decoder to the value indicated in the audio"]
#[doc = " bitstream (if present), or to a \"sane\" default otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVDownmixInfo {
    #[doc = " Type of downmix preferred by the mastering engineer."]
    pub preferred_downmix_type: AVDownmixType,
    #[doc = " Absolute scale factor representing the nominal level of the center"]
    #[doc = " channel during a regular downmix."]
    pub center_mix_level: f64,
    #[doc = " Absolute scale factor representing the nominal level of the center"]
    #[doc = " channel during an Lt/Rt compatible downmix."]
    pub center_mix_level_ltrt: f64,
    #[doc = " Absolute scale factor representing the nominal level of the surround"]
    #[doc = " channels during a regular downmix."]
    pub surround_mix_level: f64,
    #[doc = " Absolute scale factor representing the nominal level of the surround"]
    #[doc = " channels during an Lt/Rt compatible downmix."]
    pub surround_mix_level_ltrt: f64,
    #[doc = " Absolute scale factor representing the level at which the LFE data is"]
    #[doc = " mixed into L/R channels during downmixing."]
    pub lfe_mix_level: f64,
}
#[test]
fn bindgen_test_layout_AVDownmixInfo() {
    assert_eq!(
        ::std::mem::size_of::<AVDownmixInfo>(),
        48usize,
        concat!("Size of: ", stringify!(AVDownmixInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDownmixInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDownmixInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).preferred_downmix_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(preferred_downmix_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDownmixInfo>())).center_mix_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(center_mix_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).center_mix_level_ltrt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(center_mix_level_ltrt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).surround_mix_level as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(surround_mix_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).surround_mix_level_ltrt as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(surround_mix_level_ltrt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDownmixInfo>())).lfe_mix_level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(lfe_mix_level)
        )
    );
}
extern "C" {
    #[doc = " Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing."]
    #[doc = ""]
    #[doc = " If the side data is absent, it is created and added to the frame."]
    #[doc = ""]
    #[doc = " @param frame the frame for which the side data is to be obtained or created"]
    #[doc = ""]
    #[doc = " @return the AVDownmixInfo structure to be edited by the caller, or NULL if"]
    #[doc = "         the structure cannot be allocated."]
    pub fn av_downmix_info_update_side_data(frame: *mut AVFrame) -> *mut AVDownmixInfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVExpr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Parse and evaluate an expression."]
    #[doc = " Note, this is significantly slower than av_expr_eval()."]
    #[doc = ""]
    #[doc = " @param res a pointer to a double where is put the result value of"]
    #[doc = " the expression, or NAN in case of error"]
    #[doc = " @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\""]
    #[doc = " @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}"]
    #[doc = " @param const_values a zero terminated array of values for the identifiers from const_names"]
    #[doc = " @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers"]
    #[doc = " @param funcs1 NULL terminated array of function pointers for functions which take 1 argument"]
    #[doc = " @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers"]
    #[doc = " @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments"]
    #[doc = " @param opaque a pointer which will be passed to all functions from funcs1 and funcs2"]
    #[doc = " @param log_ctx parent logging context"]
    #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
    #[doc = " AVERROR code otherwise"]
    pub fn av_expr_parse_and_eval(
        res: *mut f64,
        s: *const libc::c_char,
        const_names: *const *const libc::c_char,
        const_values: *const f64,
        func1_names: *const *const libc::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const libc::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        opaque: *mut libc::c_void,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse an expression."]
    #[doc = ""]
    #[doc = " @param expr a pointer where is put an AVExpr containing the parsed"]
    #[doc = " value in case of successful parsing, or NULL otherwise."]
    #[doc = " The pointed to AVExpr must be freed with av_expr_free() by the user"]
    #[doc = " when it is not needed anymore."]
    #[doc = " @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\""]
    #[doc = " @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}"]
    #[doc = " @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers"]
    #[doc = " @param funcs1 NULL terminated array of function pointers for functions which take 1 argument"]
    #[doc = " @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers"]
    #[doc = " @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments"]
    #[doc = " @param log_ctx parent logging context"]
    #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
    #[doc = " AVERROR code otherwise"]
    pub fn av_expr_parse(
        expr: *mut *mut AVExpr,
        s: *const libc::c_char,
        const_names: *const *const libc::c_char,
        func1_names: *const *const libc::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const libc::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Evaluate a previously parsed expression."]
    #[doc = ""]
    #[doc = " @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names"]
    #[doc = " @param opaque a pointer which will be passed to all functions from funcs1 and funcs2"]
    #[doc = " @return the value of the expression"]
    pub fn av_expr_eval(e: *mut AVExpr, const_values: *const f64, opaque: *mut libc::c_void)
        -> f64;
}
extern "C" {
    #[doc = " Track the presence of variables and their number of occurrences in a parsed expression"]
    #[doc = ""]
    #[doc = " @param counter a zero-initialized array where the count of each variable will be stored"]
    #[doc = " @param size size of array"]
    #[doc = " @return 0 on success, a negative value indicates that no expression or array was passed"]
    #[doc = " or size was zero"]
    pub fn av_expr_count_vars(
        e: *mut AVExpr,
        counter: *mut libc::c_uint,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Track the presence of user provided functions and their number of occurrences"]
    #[doc = " in a parsed expression."]
    #[doc = ""]
    #[doc = " @param counter a zero-initialized array where the count of each function will be stored"]
    #[doc = "                if you passed 5 functions with 2 arguments to av_expr_parse()"]
    #[doc = "                then for arg=2 this will use upto 5 entries."]
    #[doc = " @param size size of array"]
    #[doc = " @param arg number of arguments the counted functions have"]
    #[doc = " @return 0 on success, a negative value indicates that no expression or array was passed"]
    #[doc = " or size was zero"]
    pub fn av_expr_count_func(
        e: *mut AVExpr,
        counter: *mut libc::c_uint,
        size: libc::c_int,
        arg: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a parsed expression previously created with av_expr_parse()."]
    pub fn av_expr_free(e: *mut AVExpr);
}
extern "C" {
    #[doc = " Parse the string in numstr and return its value as a double. If"]
    #[doc = " the string is empty, contains only whitespaces, or does not contain"]
    #[doc = " an initial substring that has the expected syntax for a"]
    #[doc = " floating-point number, no conversion is performed. In this case,"]
    #[doc = " returns a value of zero and the value returned in tail is the value"]
    #[doc = " of numstr."]
    #[doc = ""]
    #[doc = " @param numstr a string representing a number, may contain one of"]
    #[doc = " the International System number postfixes, for example 'K', 'M',"]
    #[doc = " 'G'. If 'i' is appended after the postfix, powers of 2 are used"]
    #[doc = " instead of powers of 10. The 'B' postfix multiplies the value by"]
    #[doc = " 8, and can be appended after another postfix or used alone. This"]
    #[doc = " allows using for example 'KB', 'MiB', 'G' and 'B' as postfix."]
    #[doc = " @param tail if non-NULL puts here the pointer to the char next"]
    #[doc = " after the last parsed character"]
    pub fn av_strtod(numstr: *const libc::c_char, tail: *mut *mut libc::c_char) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFifo {
    _unused: [u8; 0],
}
#[doc = " Callback for writing or reading from a FIFO, passed to (and invoked from) the"]
#[doc = " av_fifo_*_cb() functions. It may be invoked multiple times from a single"]
#[doc = " av_fifo_*_cb() call and may process less data than the maximum size indicated"]
#[doc = " by nb_elems."]
#[doc = ""]
#[doc = " @param opaque the opaque pointer provided to the av_fifo_*_cb() function"]
#[doc = " @param buf the buffer for reading or writing the data, depending on which"]
#[doc = "            av_fifo_*_cb function is called"]
#[doc = " @param nb_elems On entry contains the maximum number of elements that can be"]
#[doc = "                 read from / written into buf. On success, the callback should"]
#[doc = "                 update it to contain the number of elements actually written."]
#[doc = ""]
#[doc = " @return 0 on success, a negative error code on failure (will be returned from"]
#[doc = "         the invoking av_fifo_*_cb() function)"]
pub type AVFifoCB = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        buf: *mut libc::c_void,
        nb_elems: *mut usize,
    ) -> libc::c_int,
>;
extern "C" {
    #[doc = " Allocate and initialize an AVFifo with a given element size."]
    #[doc = ""]
    #[doc = " @param elems     initial number of elements that can be stored in the FIFO"]
    #[doc = " @param elem_size Size in bytes of a single element. Further operations on"]
    #[doc = "                  the returned FIFO will implicitly use this element size."]
    #[doc = " @param flags a combination of AV_FIFO_FLAG_*"]
    #[doc = ""]
    #[doc = " @return newly-allocated AVFifo on success, a negative error code on failure"]
    pub fn av_fifo_alloc2(elems: usize, elem_size: usize, flags: libc::c_uint) -> *mut AVFifo;
}
extern "C" {
    #[doc = " @return Element size for FIFO operations. This element size is set at"]
    #[doc = "         FIFO allocation and remains constant during its lifetime"]
    pub fn av_fifo_elem_size(f: *const AVFifo) -> usize;
}
extern "C" {
    #[doc = " Set the maximum size (in elements) to which the FIFO can be resized"]
    #[doc = " automatically. Has no effect unless AV_FIFO_FLAG_AUTO_GROW is used."]
    pub fn av_fifo_auto_grow_limit(f: *mut AVFifo, max_elems: usize);
}
extern "C" {
    #[doc = " @return number of elements available for reading from the given FIFO."]
    pub fn av_fifo_can_read(f: *const AVFifo) -> usize;
}
extern "C" {
    #[doc = " @return number of elements that can be written into the given FIFO."]
    pub fn av_fifo_can_write(f: *const AVFifo) -> usize;
}
extern "C" {
    #[doc = " Enlarge an AVFifo."]
    #[doc = ""]
    #[doc = " On success, the FIFO will be large enough to hold exactly"]
    #[doc = " inc + av_fifo_can_read() + av_fifo_can_write()"]
    #[doc = " elements. In case of failure, the old FIFO is kept unchanged."]
    #[doc = ""]
    #[doc = " @param f AVFifo to resize"]
    #[doc = " @param inc number of elements to allocate for, in addition to the current"]
    #[doc = "            allocated size"]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_grow2(f: *mut AVFifo, inc: usize) -> libc::c_int;
}
extern "C" {
    #[doc = " Write data into a FIFO."]
    #[doc = ""]
    #[doc = " In case nb_elems > av_fifo_can_write(f), nothing is written and an error"]
    #[doc = " is returned."]
    #[doc = ""]
    #[doc = " @param f the FIFO buffer"]
    #[doc = " @param buf Data to be written. nb_elems * av_fifo_elem_size(f) bytes will be"]
    #[doc = "            read from buf on success."]
    #[doc = " @param nb_elems number of elements to write into FIFO"]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_write(f: *mut AVFifo, buf: *const libc::c_void, nb_elems: usize) -> libc::c_int;
}
extern "C" {
    #[doc = " Write data from a user-provided callback into a FIFO."]
    #[doc = ""]
    #[doc = " @param f the FIFO buffer"]
    #[doc = " @param read_cb Callback supplying the data to the FIFO. May be called"]
    #[doc = "                multiple times."]
    #[doc = " @param opaque opaque user data to be provided to read_cb"]
    #[doc = " @param nb_elems Should point to the maximum number of elements that can be"]
    #[doc = "                 written. Will be updated to contain the number of elements"]
    #[doc = "                 actually written."]
    #[doc = ""]
    #[doc = " @return non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_write_from_cb(
        f: *mut AVFifo,
        read_cb: AVFifoCB,
        opaque: *mut libc::c_void,
        nb_elems: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read data from a FIFO."]
    #[doc = ""]
    #[doc = " In case nb_elems > av_fifo_can_read(f), nothing is read and an error"]
    #[doc = " is returned."]
    #[doc = ""]
    #[doc = " @param f the FIFO buffer"]
    #[doc = " @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes"]
    #[doc = "            will be written into buf on success."]
    #[doc = " @param nb_elems number of elements to read from FIFO"]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_read(f: *mut AVFifo, buf: *mut libc::c_void, nb_elems: usize) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from a FIFO into a user-provided callback."]
    #[doc = ""]
    #[doc = " @param f the FIFO buffer"]
    #[doc = " @param write_cb Callback the data will be supplied to. May be called"]
    #[doc = "                 multiple times."]
    #[doc = " @param opaque opaque user data to be provided to write_cb"]
    #[doc = " @param nb_elems Should point to the maximum number of elements that can be"]
    #[doc = "                 read. Will be updated to contain the total number of elements"]
    #[doc = "                 actually sent to the callback."]
    #[doc = ""]
    #[doc = " @return non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_read_to_cb(
        f: *mut AVFifo,
        write_cb: AVFifoCB,
        opaque: *mut libc::c_void,
        nb_elems: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read data from a FIFO without modifying FIFO state."]
    #[doc = ""]
    #[doc = " Returns an error if an attempt is made to peek to nonexistent elements"]
    #[doc = " (i.e. if offset + nb_elems is larger than av_fifo_can_read(f))."]
    #[doc = ""]
    #[doc = " @param f the FIFO buffer"]
    #[doc = " @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes"]
    #[doc = "            will be written into buf."]
    #[doc = " @param nb_elems number of elements to read from FIFO"]
    #[doc = " @param offset number of initial elements to skip."]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_peek(
        f: *mut AVFifo,
        buf: *mut libc::c_void,
        nb_elems: usize,
        offset: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from a FIFO into a user-provided callback."]
    #[doc = ""]
    #[doc = " @param f the FIFO buffer"]
    #[doc = " @param write_cb Callback the data will be supplied to. May be called"]
    #[doc = "                 multiple times."]
    #[doc = " @param opaque opaque user data to be provided to write_cb"]
    #[doc = " @param nb_elems Should point to the maximum number of elements that can be"]
    #[doc = "                 read. Will be updated to contain the total number of elements"]
    #[doc = "                 actually sent to the callback."]
    #[doc = " @param offset number of initial elements to skip; offset + *nb_elems must not"]
    #[doc = "               be larger than av_fifo_can_read(f)."]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_peek_to_cb(
        f: *mut AVFifo,
        write_cb: AVFifoCB,
        opaque: *mut libc::c_void,
        nb_elems: *mut usize,
        offset: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Discard the specified amount of data from an AVFifo."]
    #[doc = " @param size number of elements to discard, MUST NOT be larger than"]
    #[doc = "             av_fifo_can_read(f)"]
    pub fn av_fifo_drain2(f: *mut AVFifo, size: usize);
}
extern "C" {
    pub fn av_fifo_reset2(f: *mut AVFifo);
}
extern "C" {
    #[doc = " Free an AVFifo and reset pointer to NULL."]
    #[doc = " @param f Pointer to an AVFifo to free. *f == NULL is allowed."]
    pub fn av_fifo_freep2(f: *mut *mut AVFifo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFifoBuffer {
    pub buffer: *mut u8,
    pub rptr: *mut u8,
    pub wptr: *mut u8,
    pub end: *mut u8,
    pub rndx: u32,
    pub wndx: u32,
}
#[test]
fn bindgen_test_layout_AVFifoBuffer() {
    assert_eq!(
        ::std::mem::size_of::<AVFifoBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(AVFifoBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFifoBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFifoBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).wptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(wptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).rndx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(rndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).wndx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(wndx)
        )
    );
}
extern "C" {
    #[doc = " Initialize an AVFifoBuffer."]
    #[doc = " @param size of FIFO"]
    #[doc = " @return AVFifoBuffer or NULL in case of memory allocation failure"]
    #[doc = " @deprecated use av_fifo_alloc2()"]
    pub fn av_fifo_alloc(size: libc::c_uint) -> *mut AVFifoBuffer;
}
extern "C" {
    #[doc = " Initialize an AVFifoBuffer."]
    #[doc = " @param nmemb number of elements"]
    #[doc = " @param size  size of the single element"]
    #[doc = " @return AVFifoBuffer or NULL in case of memory allocation failure"]
    #[doc = " @deprecated use av_fifo_alloc2()"]
    pub fn av_fifo_alloc_array(nmemb: usize, size: usize) -> *mut AVFifoBuffer;
}
extern "C" {
    #[doc = " Free an AVFifoBuffer."]
    #[doc = " @param f AVFifoBuffer to free"]
    #[doc = " @deprecated use the AVFifo API with av_fifo_freep2()"]
    pub fn av_fifo_free(f: *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Free an AVFifoBuffer and reset pointer to NULL."]
    #[doc = " @param f AVFifoBuffer to free"]
    #[doc = " @deprecated use the AVFifo API with av_fifo_freep2()"]
    pub fn av_fifo_freep(f: *mut *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied."]
    #[doc = " @param f AVFifoBuffer to reset"]
    #[doc = " @deprecated use av_fifo_reset2() with the new AVFifo-API"]
    pub fn av_fifo_reset(f: *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Return the amount of data in bytes in the AVFifoBuffer, that is the"]
    #[doc = " amount of data you can read from it."]
    #[doc = " @param f AVFifoBuffer to read from"]
    #[doc = " @return size"]
    #[doc = " @deprecated use av_fifo_can_read() with the new AVFifo-API"]
    pub fn av_fifo_size(f: *const AVFifoBuffer) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the amount of space in bytes in the AVFifoBuffer, that is the"]
    #[doc = " amount of data you can write into it."]
    #[doc = " @param f AVFifoBuffer to write into"]
    #[doc = " @return size"]
    #[doc = " @deprecated use av_fifo_can_write() with the new AVFifo-API"]
    pub fn av_fifo_space(f: *const AVFifoBuffer) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data at specific position from an AVFifoBuffer to a user-supplied callback."]
    #[doc = " Similar as av_fifo_gereric_read but without discarding data."]
    #[doc = " @param f AVFifoBuffer to read from"]
    #[doc = " @param offset offset from current read position"]
    #[doc = " @param buf_size number of bytes to read"]
    #[doc = " @param func generic read function"]
    #[doc = " @param dest data destination"]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    #[doc = ""]
    #[doc = " @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,"]
    #[doc = "             av_fifo_peek_to_cb() otherwise"]
    pub fn av_fifo_generic_peek_at(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        offset: libc::c_int,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback."]
    #[doc = " Similar as av_fifo_gereric_read but without discarding data."]
    #[doc = " @param f AVFifoBuffer to read from"]
    #[doc = " @param buf_size number of bytes to read"]
    #[doc = " @param func generic read function"]
    #[doc = " @param dest data destination"]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    #[doc = ""]
    #[doc = " @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,"]
    #[doc = "             av_fifo_peek_to_cb() otherwise"]
    pub fn av_fifo_generic_peek(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback."]
    #[doc = " @param f AVFifoBuffer to read from"]
    #[doc = " @param buf_size number of bytes to read"]
    #[doc = " @param func generic read function"]
    #[doc = " @param dest data destination"]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative error code on failure"]
    #[doc = ""]
    #[doc = " @deprecated use the new AVFifo-API with av_fifo_read() when func == NULL,"]
    #[doc = "             av_fifo_read_to_cb() otherwise"]
    pub fn av_fifo_generic_read(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Feed data from a user-supplied callback to an AVFifoBuffer."]
    #[doc = " @param f AVFifoBuffer to write to"]
    #[doc = " @param src data source; non-const since it may be used as a"]
    #[doc = " modifiable context by the function defined in func"]
    #[doc = " @param size number of bytes to write"]
    #[doc = " @param func generic write function; the first parameter is src,"]
    #[doc = " the second is dest_buf, the third is dest_buf_size."]
    #[doc = " func must return the number of bytes written to dest_buf, or <= 0 to"]
    #[doc = " indicate no more data available to write."]
    #[doc = " If func is NULL, src is interpreted as a simple byte array for source data."]
    #[doc = " @return the number of bytes written to the FIFO or a negative error code on failure"]
    #[doc = ""]
    #[doc = " @deprecated use the new AVFifo-API with av_fifo_write() when func == NULL,"]
    #[doc = "             av_fifo_write_from_cb() otherwise"]
    pub fn av_fifo_generic_write(
        f: *mut AVFifoBuffer,
        src: *mut libc::c_void,
        size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ) -> libc::c_int,
        >,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Resize an AVFifoBuffer."]
    #[doc = " In case of reallocation failure, the old FIFO is kept unchanged."]
    #[doc = ""]
    #[doc = " @param f AVFifoBuffer to resize"]
    #[doc = " @param size new AVFifoBuffer size in bytes"]
    #[doc = " @return <0 for failure, >=0 otherwise"]
    #[doc = ""]
    #[doc = " @deprecated use the new AVFifo-API with av_fifo_grow2() to increase FIFO size,"]
    #[doc = "             decreasing FIFO size is not supported"]
    pub fn av_fifo_realloc2(f: *mut AVFifoBuffer, size: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " Enlarge an AVFifoBuffer."]
    #[doc = " In case of reallocation failure, the old FIFO is kept unchanged."]
    #[doc = " The new fifo size may be larger than the requested size."]
    #[doc = ""]
    #[doc = " @param f AVFifoBuffer to resize"]
    #[doc = " @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()"]
    #[doc = " @return <0 for failure, >=0 otherwise"]
    #[doc = ""]
    #[doc = " @deprecated use the new AVFifo-API with av_fifo_grow2(); note that unlike"]
    #[doc = " this function it adds to the allocated size, rather than to the used size"]
    pub fn av_fifo_grow(f: *mut AVFifoBuffer, additional_space: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " Read and discard the specified amount of data from an AVFifoBuffer."]
    #[doc = " @param f AVFifoBuffer to read from"]
    #[doc = " @param size amount of data to read in bytes"]
    #[doc = ""]
    #[doc = " @deprecated use the new AVFifo-API with av_fifo_drain2()"]
    pub fn av_fifo_drain(f: *mut AVFifoBuffer, size: libc::c_int);
}
extern "C" {
    #[doc = " Read the file with name filename, and put its content in a newly"]
    #[doc = " allocated buffer or map it with mmap() when available."]
    #[doc = " In case of success set *bufptr to the read or mmapped buffer, and"]
    #[doc = " *size to the size in bytes of the buffer in *bufptr."]
    #[doc = " Unlike mmap this function succeeds with zero sized files, in this"]
    #[doc = " case *bufptr will be set to NULL and *size will be set to 0."]
    #[doc = " The returned buffer must be released with av_file_unmap()."]
    #[doc = ""]
    #[doc = " @param log_offset loglevel offset used for logging"]
    #[doc = " @param log_ctx context used for logging"]
    #[doc = " @return a non negative number in case of success, a negative value"]
    #[doc = " corresponding to an AVERROR error code in case of failure"]
    pub fn av_file_map(
        filename: *const libc::c_char,
        bufptr: *mut *mut u8,
        size: *mut usize,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Unmap or free the buffer bufptr created by av_file_map()."]
    #[doc = ""]
    #[doc = " @param size size in bytes of bufptr, must be the same as returned"]
    #[doc = " by av_file_map()"]
    pub fn av_file_unmap(bufptr: *mut u8, size: usize);
}
extern "C" {
    #[doc = " Wrapper to work around the lack of mkstemp() on mingw."]
    #[doc = " Also, tries to create file in /tmp first, if possible."]
    #[doc = " *prefix can be a character constant; *filename will be allocated internally."]
    #[doc = " @return file descriptor of opened file (or negative value corresponding to an"]
    #[doc = " AVERROR code on error)"]
    #[doc = " and opened file name in **filename."]
    #[doc = " @note On very old libcs it is necessary to set a secure umask before"]
    #[doc = "       calling this, av_tempfile() can't call umask itself as it is used in"]
    #[doc = "       libraries and could interfere with the calling application."]
    #[doc = " @deprecated as fd numbers cannot be passed saftely between libs on some platforms"]
    pub fn av_tempfile(
        prefix: *const libc::c_char,
        filename: *mut *mut libc::c_char,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
#[doc = " @example ffhash.c"]
#[doc = " This example is a simple command line application that takes one or more"]
#[doc = " arguments. It demonstrates a typical use of the hashing API with allocation,"]
#[doc = " initialization, updating, and finalizing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHashContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a hash context for the algorithm specified by name."]
    #[doc = ""]
    #[doc = " @return  >= 0 for success, a negative error code for failure"]
    #[doc = ""]
    #[doc = " @note The context is not initialized after a call to this function; you must"]
    #[doc = " call av_hash_init() to do so."]
    pub fn av_hash_alloc(ctx: *mut *mut AVHashContext, name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the names of available hash algorithms."]
    #[doc = ""]
    #[doc = " This function can be used to enumerate the algorithms."]
    #[doc = ""]
    #[doc = " @param[in] i  Index of the hash algorithm, starting from 0"]
    #[doc = " @return       Pointer to a static string or `NULL` if `i` is out of range"]
    pub fn av_hash_names(i: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the name of the algorithm corresponding to the given hash context."]
    pub fn av_hash_get_name(ctx: *const AVHashContext) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the size of the resulting hash value in bytes."]
    #[doc = ""]
    #[doc = " The maximum value this function will currently return is available as macro"]
    #[doc = " #AV_HASH_MAX_SIZE."]
    #[doc = ""]
    #[doc = " @param[in]     ctx Hash context"]
    #[doc = " @return            Size of the hash value in bytes"]
    pub fn av_hash_get_size(ctx: *const AVHashContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize or reset a hash context."]
    #[doc = ""]
    #[doc = " @param[in,out] ctx Hash context"]
    pub fn av_hash_init(ctx: *mut AVHashContext);
}
extern "C" {
    #[doc = " Update a hash context with additional data."]
    #[doc = ""]
    #[doc = " @param[in,out] ctx Hash context"]
    #[doc = " @param[in]     src Data to be added to the hash context"]
    #[doc = " @param[in]     len Size of the additional data"]
    pub fn av_hash_update(ctx: *mut AVHashContext, src: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finalize a hash context and compute the actual hash value."]
    #[doc = ""]
    #[doc = " The minimum size of `dst` buffer is given by av_hash_get_size() or"]
    #[doc = " #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged."]
    #[doc = ""]
    #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
    #[doc = " been finalized."]
    #[doc = ""]
    #[doc = " @param[in,out] ctx Hash context"]
    #[doc = " @param[out]    dst Where the final hash value will be stored"]
    #[doc = ""]
    #[doc = " @see av_hash_final_bin() provides an alternative API"]
    pub fn av_hash_final(ctx: *mut AVHashContext, dst: *mut u8);
}
extern "C" {
    #[doc = " Finalize a hash context and store the actual hash value in a buffer."]
    #[doc = ""]
    #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
    #[doc = " been finalized."]
    #[doc = ""]
    #[doc = " If `size` is smaller than the hash size (given by av_hash_get_size()), the"]
    #[doc = " hash is truncated; if size is larger, the buffer is padded with 0."]
    #[doc = ""]
    #[doc = " @param[in,out] ctx  Hash context"]
    #[doc = " @param[out]    dst  Where the final hash value will be stored"]
    #[doc = " @param[in]     size Number of bytes to write to `dst`"]
    pub fn av_hash_final_bin(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    #[doc = " Finalize a hash context and store the hexadecimal representation of the"]
    #[doc = " actual hash value as a string."]
    #[doc = ""]
    #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
    #[doc = " been finalized."]
    #[doc = ""]
    #[doc = " The string is always 0-terminated."]
    #[doc = ""]
    #[doc = " If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the"]
    #[doc = " value returned by av_hash_get_size(), the string will be truncated."]
    #[doc = ""]
    #[doc = " @param[in,out] ctx  Hash context"]
    #[doc = " @param[out]    dst  Where the string will be stored"]
    #[doc = " @param[in]     size Maximum number of bytes to write to `dst`"]
    pub fn av_hash_final_hex(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    #[doc = " Finalize a hash context and store the Base64 representation of the"]
    #[doc = " actual hash value as a string."]
    #[doc = ""]
    #[doc = " It is not safe to update or finalize a hash context again, if it has already"]
    #[doc = " been finalized."]
    #[doc = ""]
    #[doc = " The string is always 0-terminated."]
    #[doc = ""]
    #[doc = " If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is"]
    #[doc = " the value returned by av_hash_get_size(), the string will be truncated."]
    #[doc = ""]
    #[doc = " @param[in,out] ctx  Hash context"]
    #[doc = " @param[out]    dst  Where the final hash value will be stored"]
    #[doc = " @param[in]     size Maximum number of bytes to write to `dst`"]
    pub fn av_hash_final_b64(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    #[doc = " Free hash context and set hash context pointer to `NULL`."]
    #[doc = ""]
    #[doc = " @param[in,out] ctx  Pointer to hash context"]
    pub fn av_hash_freep(ctx: *mut *mut AVHashContext);
}
#[repr(u32)]
#[doc = " @defgroup lavu_hmac HMAC"]
#[doc = " @ingroup lavu_crypto"]
#[doc = " @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHMACType {
    AV_HMAC_MD5 = 0,
    AV_HMAC_SHA1 = 1,
    AV_HMAC_SHA224 = 2,
    AV_HMAC_SHA256 = 3,
    AV_HMAC_SHA384 = 4,
    AV_HMAC_SHA512 = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHMAC {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVHMAC context."]
    #[doc = " @param type The hash function used for the HMAC."]
    pub fn av_hmac_alloc(type_: AVHMACType) -> *mut AVHMAC;
}
extern "C" {
    #[doc = " Free an AVHMAC context."]
    #[doc = " @param ctx The context to free, may be NULL"]
    pub fn av_hmac_free(ctx: *mut AVHMAC);
}
extern "C" {
    #[doc = " Initialize an AVHMAC context with an authentication key."]
    #[doc = " @param ctx    The HMAC context"]
    #[doc = " @param key    The authentication key"]
    #[doc = " @param keylen The length of the key, in bytes"]
    pub fn av_hmac_init(ctx: *mut AVHMAC, key: *const u8, keylen: libc::c_uint);
}
extern "C" {
    #[doc = " Hash data with the HMAC."]
    #[doc = " @param ctx  The HMAC context"]
    #[doc = " @param data The data to hash"]
    #[doc = " @param len  The length of the data, in bytes"]
    pub fn av_hmac_update(ctx: *mut AVHMAC, data: *const u8, len: libc::c_uint);
}
extern "C" {
    #[doc = " Finish hashing and output the HMAC digest."]
    #[doc = " @param ctx    The HMAC context"]
    #[doc = " @param out    The output buffer to write the digest into"]
    #[doc = " @param outlen The length of the out buffer, in bytes"]
    #[doc = " @return       The number of bytes written to out, or a negative error code."]
    pub fn av_hmac_final(ctx: *mut AVHMAC, out: *mut u8, outlen: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " Hash an array of data with a key."]
    #[doc = " @param ctx    The HMAC context"]
    #[doc = " @param data   The data to hash"]
    #[doc = " @param len    The length of the data, in bytes"]
    #[doc = " @param key    The authentication key"]
    #[doc = " @param keylen The length of the key, in bytes"]
    #[doc = " @param out    The output buffer to write the digest into"]
    #[doc = " @param outlen The length of the out buffer, in bytes"]
    #[doc = " @return       The number of bytes written to out, or a negative error code."]
    pub fn av_hmac_calc(
        ctx: *mut AVHMAC,
        data: *const u8,
        len: libc::c_uint,
        key: *const u8,
        keylen: libc::c_uint,
        out: *mut u8,
        outlen: libc::c_uint,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVComponentDescriptor {
    #[doc = " Which of the 4 planes contains the component."]
    pub plane: libc::c_int,
    #[doc = " Number of elements between 2 horizontally consecutive pixels."]
    #[doc = " Elements are bits for bitstream formats, bytes otherwise."]
    pub step: libc::c_int,
    #[doc = " Number of elements before the component of the first pixel."]
    #[doc = " Elements are bits for bitstream formats, bytes otherwise."]
    pub offset: libc::c_int,
    #[doc = " Number of least significant bits that must be shifted away"]
    #[doc = " to get the value."]
    pub shift: libc::c_int,
    #[doc = " Number of bits in the component."]
    pub depth: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVComponentDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVComponentDescriptor>(),
        20usize,
        concat!("Size of: ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVComponentDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).plane as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(plane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).step as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).shift as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " Descriptor that unambiguously describes how the bits of a pixel are"]
#[doc = " stored in the up to 4 data planes of an image. It also stores the"]
#[doc = " subsampling factors and number of components."]
#[doc = ""]
#[doc = " @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV"]
#[doc = "       and all the YUV variants) AVPixFmtDescriptor just stores how values"]
#[doc = "       are stored not what these values represent."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPixFmtDescriptor {
    pub name: *const libc::c_char,
    #[doc = "< The number of components each pixel has, (1-4)"]
    pub nb_components: u8,
    #[doc = " Amount to shift the luma width right to find the chroma width."]
    #[doc = " For YV12 this is 1 for example."]
    #[doc = " chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)"]
    #[doc = " The note above is needed to ensure rounding up."]
    #[doc = " This value only refers to the chroma components."]
    pub log2_chroma_w: u8,
    #[doc = " Amount to shift the luma height right to find the chroma height."]
    #[doc = " For YV12 this is 1 for example."]
    #[doc = " chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)"]
    #[doc = " The note above is needed to ensure rounding up."]
    #[doc = " This value only refers to the chroma components."]
    pub log2_chroma_h: u8,
    #[doc = " Combination of AV_PIX_FMT_FLAG_... flags."]
    pub flags: u64,
    #[doc = " Parameters that describe how pixels are packed."]
    #[doc = " If the format has 1 or 2 components, then luma is 0."]
    #[doc = " If the format has 3 or 4 components:"]
    #[doc = "   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;"]
    #[doc = "   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V."]
    #[doc = ""]
    #[doc = " If present, the Alpha channel is always the last component."]
    pub comp: [AVComponentDescriptor; 4usize],
    #[doc = " Alternative comma-separated names."]
    pub alias: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVPixFmtDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVPixFmtDescriptor>(),
        112usize,
        concat!("Size of: ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPixFmtDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVPixFmtDescriptor>())).nb_components as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(nb_components)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVPixFmtDescriptor>())).log2_chroma_w as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_w)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVPixFmtDescriptor>())).log2_chroma_h as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).comp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).alias as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(alias)
        )
    );
}
extern "C" {
    #[doc = " Return the number of bits per pixel used by the pixel format"]
    #[doc = " described by pixdesc. Note that this is not the same as the number"]
    #[doc = " of bits per sample."]
    #[doc = ""]
    #[doc = " The returned number of bits refers to the number of bits actually"]
    #[doc = " used for storing the pixel information, that is padding bits are"]
    #[doc = " not counted."]
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the number of bits per pixel for the pixel format"]
    #[doc = " described by pixdesc, including any padding or unused bits."]
    pub fn av_get_padded_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> libc::c_int;
}
extern "C" {
    #[doc = " @return a pixel format descriptor for provided pixel format or NULL if"]
    #[doc = " this pixel format is unknown."]
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " Iterate over all pixel format descriptors known to libavutil."]
    #[doc = ""]
    #[doc = " @param prev previous descriptor. NULL to get the first descriptor."]
    #[doc = ""]
    #[doc = " @return next descriptor or NULL after the last descriptor"]
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc"]
    #[doc = " is not a valid pointer to a pixel format descriptor."]
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Utility function to access log2_chroma_w log2_chroma_h from"]
    #[doc = " the pixel format AVPixFmtDescriptor."]
    #[doc = ""]
    #[doc = " @param[in]  pix_fmt the pixel format"]
    #[doc = " @param[out] h_shift store log2_chroma_w (horizontal/width shift)"]
    #[doc = " @param[out] v_shift store log2_chroma_h (vertical/height shift)"]
    #[doc = ""]
    #[doc = " @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format"]
    pub fn av_pix_fmt_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut libc::c_int,
        v_shift: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a"]
    #[doc = " valid pixel format."]
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color range or NULL if unknown."]
    pub fn av_color_range_name(range: AVColorRange) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorRange value for name or an AVError if not found."]
    pub fn av_color_range_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color primaries or NULL if unknown."]
    pub fn av_color_primaries_name(primaries: AVColorPrimaries) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorPrimaries value for name or an AVError if not found."]
    pub fn av_color_primaries_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color transfer or NULL if unknown."]
    pub fn av_color_transfer_name(transfer: AVColorTransferCharacteristic) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorTransferCharacteristic value for name or an AVError if not found."]
    pub fn av_color_transfer_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color space or NULL if unknown."]
    pub fn av_color_space_name(space: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVColorSpace value for name or an AVError if not found."]
    pub fn av_color_space_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @return the name for provided chroma location or NULL if unknown."]
    pub fn av_chroma_location_name(location: AVChromaLocation) -> *const libc::c_char;
}
extern "C" {
    #[doc = " @return the AVChromaLocation value for name or an AVError if not found."]
    pub fn av_chroma_location_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the pixel format corresponding to name."]
    #[doc = ""]
    #[doc = " If there is no pixel format with name name, then looks for a"]
    #[doc = " pixel format with the name corresponding to the native endian"]
    #[doc = " format of name."]
    #[doc = " For example in a little-endian system, first looks for \"gray16\","]
    #[doc = " then for \"gray16le\"."]
    #[doc = ""]
    #[doc = " Finally if no pixel format has been found, returns AV_PIX_FMT_NONE."]
    pub fn av_get_pix_fmt(name: *const libc::c_char) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Return the short name for a pixel format, NULL in case pix_fmt is"]
    #[doc = " unknown."]
    #[doc = ""]
    #[doc = " @see av_get_pix_fmt(), av_get_pix_fmt_string()"]
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Print in buf the string corresponding to the pixel format with"]
    #[doc = " number pix_fmt, or a header if pix_fmt is negative."]
    #[doc = ""]
    #[doc = " @param buf the buffer where to write the string"]
    #[doc = " @param buf_size the size of buf"]
    #[doc = " @param pix_fmt the number of the pixel format to print the"]
    #[doc = " corresponding info string, or a negative value to print the"]
    #[doc = " corresponding header."]
    pub fn av_get_pix_fmt_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Read a line from an image, and write the values of the"]
    #[doc = " pixel format component c to dst."]
    #[doc = ""]
    #[doc = " @param data the array containing the pointers to the planes of the image"]
    #[doc = " @param linesize the array containing the linesizes of the image"]
    #[doc = " @param desc the pixel format descriptor for the image"]
    #[doc = " @param x the horizontal coordinate of the first pixel to read"]
    #[doc = " @param y the vertical coordinate of the first pixel to read"]
    #[doc = " @param w the width of the line to read, that is the number of"]
    #[doc = " values to write to dst"]
    #[doc = " @param read_pal_component if not zero and the format is a paletted"]
    #[doc = " format writes the values corresponding to the palette"]
    #[doc = " component c in data[1] to dst, rather than the palette indexes in"]
    #[doc = " data[0]. The behavior is undefined if the format is not paletted."]
    #[doc = " @param dst_element_size size of elements in dst array (2 or 4 byte)"]
    pub fn av_read_image_line2(
        dst: *mut libc::c_void,
        data: *mut *const u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
        read_pal_component: libc::c_int,
        dst_element_size: libc::c_int,
    );
}
extern "C" {
    pub fn av_read_image_line(
        dst: *mut u16,
        data: *mut *const u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
        read_pal_component: libc::c_int,
    );
}
extern "C" {
    #[doc = " Write the values from src to the pixel format component c of an"]
    #[doc = " image line."]
    #[doc = ""]
    #[doc = " @param src array containing the values to write"]
    #[doc = " @param data the array containing the pointers to the planes of the"]
    #[doc = " image to write into. It is supposed to be zeroed."]
    #[doc = " @param linesize the array containing the linesizes of the image"]
    #[doc = " @param desc the pixel format descriptor for the image"]
    #[doc = " @param x the horizontal coordinate of the first pixel to write"]
    #[doc = " @param y the vertical coordinate of the first pixel to write"]
    #[doc = " @param w the width of the line to write, that is the number of"]
    #[doc = " values to write to the image line"]
    #[doc = " @param src_element_size size of elements in src array (2 or 4 byte)"]
    pub fn av_write_image_line2(
        src: *const libc::c_void,
        data: *mut *mut u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
        src_element_size: libc::c_int,
    );
}
extern "C" {
    pub fn av_write_image_line(
        src: *const u16,
        data: *mut *mut u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
    );
}
extern "C" {
    #[doc = " Utility function to swap the endianness of a pixel format."]
    #[doc = ""]
    #[doc = " @param[in]  pix_fmt the pixel format"]
    #[doc = ""]
    #[doc = " @return pixel format with swapped endianness if it exists,"]
    #[doc = " otherwise AV_PIX_FMT_NONE"]
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific"]
    #[doc = " pixel format to another."]
    #[doc = " When converting from one pixel format to another, information loss may occur."]
    #[doc = " For example, when converting from RGB24 to GRAY, the color information will"]
    #[doc = " be lost. Similarly, other losses occur when converting from some formats to"]
    #[doc = " other formats. These losses can involve loss of chroma, but also loss of"]
    #[doc = " resolution, loss of color depth, loss due to the color space conversion, loss"]
    #[doc = " of the alpha bits or loss due to color quantization."]
    #[doc = " av_get_fix_fmt_loss() informs you about the various types of losses"]
    #[doc = " which will occur when converting from one pixel format to another."]
    #[doc = ""]
    #[doc = " @param[in] dst_pix_fmt destination pixel format"]
    #[doc = " @param[in] src_pix_fmt source pixel format"]
    #[doc = " @param[in] has_alpha Whether the source pixel format alpha channel is used."]
    #[doc = " @return Combination of flags informing you what kind of losses will occur"]
    #[doc = " (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific"]
    #[doc = " pixel format to another."]
    #[doc = " When converting from one pixel format to another, information loss may occur."]
    #[doc = " For example, when converting from RGB24 to GRAY, the color information will"]
    #[doc = " be lost. Similarly, other losses occur when converting from some formats to"]
    #[doc = " other formats. These losses can involve loss of chroma, but also loss of"]
    #[doc = " resolution, loss of color depth, loss due to the color space conversion, loss"]
    #[doc = " of the alpha bits or loss due to color quantization."]
    #[doc = " av_get_fix_fmt_loss() informs you about the various types of losses"]
    #[doc = " which will occur when converting from one pixel format to another."]
    #[doc = ""]
    #[doc = " @param[in] dst_pix_fmt destination pixel format"]
    #[doc = " @param[in] src_pix_fmt source pixel format"]
    #[doc = " @param[in] has_alpha Whether the source pixel format alpha channel is used."]
    #[doc = " @return Combination of flags informing you what kind of losses will occur"]
    #[doc = " (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute the max pixel step for each plane of an image with a"]
    #[doc = " format described by pixdesc."]
    #[doc = ""]
    #[doc = " The pixel step is the distance in bytes between the first byte of"]
    #[doc = " the group of bytes which describe a pixel component and the first"]
    #[doc = " byte of the successive group in the same plane for the same"]
    #[doc = " component."]
    #[doc = ""]
    #[doc = " @param max_pixsteps an array which is filled with the max pixel step"]
    #[doc = " for each plane. Since a plane may contain different pixel"]
    #[doc = " components, the computed max_pixsteps[plane] is relative to the"]
    #[doc = " component in the plane with the max pixel step."]
    #[doc = " @param max_pixstep_comps an array which is filled with the component"]
    #[doc = " for each plane which has the max pixel step. May be NULL."]
    pub fn av_image_fill_max_pixsteps(
        max_pixsteps: *mut libc::c_int,
        max_pixstep_comps: *mut libc::c_int,
        pixdesc: *const AVPixFmtDescriptor,
    );
}
extern "C" {
    #[doc = " Compute the size of an image line with format pix_fmt and width"]
    #[doc = " width for the plane plane."]
    #[doc = ""]
    #[doc = " @return the computed size in bytes"]
    pub fn av_image_get_linesize(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        plane: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill plane linesizes for an image with pixel format pix_fmt and"]
    #[doc = " width width."]
    #[doc = ""]
    #[doc = " @param linesizes array to be filled with the linesize for each plane"]
    #[doc = " @return >= 0 in case of success, a negative error code otherwise"]
    pub fn av_image_fill_linesizes(
        linesizes: *mut libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill plane sizes for an image with pixel format pix_fmt and height height."]
    #[doc = ""]
    #[doc = " @param size the array to be filled with the size of each image plane"]
    #[doc = " @param linesizes the array containing the linesize for each"]
    #[doc = "        plane, should be filled by av_image_fill_linesizes()"]
    #[doc = " @return >= 0 in case of success, a negative error code otherwise"]
    #[doc = ""]
    #[doc = " @note The linesize parameters have the type ptrdiff_t here, while they are"]
    #[doc = "       int for av_image_fill_linesizes()."]
    pub fn av_image_fill_plane_sizes(
        size: *mut usize,
        pix_fmt: AVPixelFormat,
        height: libc::c_int,
        linesizes: *const isize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers for an image with pixel format pix_fmt and"]
    #[doc = " height height."]
    #[doc = ""]
    #[doc = " @param data pointers array to be filled with the pointer for each image plane"]
    #[doc = " @param ptr the pointer to a buffer which will contain the image"]
    #[doc = " @param linesizes the array containing the linesize for each"]
    #[doc = " plane, should be filled by av_image_fill_linesizes()"]
    #[doc = " @return the size in bytes required for the image buffer, a negative"]
    #[doc = " error code in case of failure"]
    pub fn av_image_fill_pointers(
        data: *mut *mut u8,
        pix_fmt: AVPixelFormat,
        height: libc::c_int,
        ptr: *mut u8,
        linesizes: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate an image with size w and h and pixel format pix_fmt, and"]
    #[doc = " fill pointers and linesizes accordingly."]
    #[doc = " The allocated image buffer has to be freed by using"]
    #[doc = " av_freep(&pointers[0])."]
    #[doc = ""]
    #[doc = " @param align the value to use for buffer size alignment"]
    #[doc = " @return the size in bytes required for the image buffer, a negative"]
    #[doc = " error code in case of failure"]
    pub fn av_image_alloc(
        pointers: *mut *mut u8,
        linesizes: *mut libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        pix_fmt: AVPixelFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy image plane from src to dst."]
    #[doc = " That is, copy \"height\" number of lines of \"bytewidth\" bytes each."]
    #[doc = " The first byte of each successive line is separated by *_linesize"]
    #[doc = " bytes."]
    #[doc = ""]
    #[doc = " bytewidth must be contained by both absolute values of dst_linesize"]
    #[doc = " and src_linesize, otherwise the function behavior is undefined."]
    #[doc = ""]
    #[doc = " @param dst_linesize linesize for the image plane in dst"]
    #[doc = " @param src_linesize linesize for the image plane in src"]
    pub fn av_image_copy_plane(
        dst: *mut u8,
        dst_linesize: libc::c_int,
        src: *const u8,
        src_linesize: libc::c_int,
        bytewidth: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where"]
    #[doc = " available, this function will use special functionality for reading from such"]
    #[doc = " memory, which may result in greatly improved performance compared to plain"]
    #[doc = " av_image_copy_plane()."]
    #[doc = ""]
    #[doc = " bytewidth must be contained by both absolute values of dst_linesize"]
    #[doc = " and src_linesize, otherwise the function behavior is undefined."]
    #[doc = ""]
    #[doc = " @note The linesize parameters have the type ptrdiff_t here, while they are"]
    #[doc = "       int for av_image_copy_plane()."]
    #[doc = " @note On x86, the linesizes currently need to be aligned to the cacheline"]
    #[doc = "       size (i.e. 64) to get improved performance."]
    pub fn av_image_copy_plane_uc_from(
        dst: *mut u8,
        dst_linesize: isize,
        src: *const u8,
        src_linesize: isize,
        bytewidth: isize,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " Copy image in src_data to dst_data."]
    #[doc = ""]
    #[doc = " @param dst_linesizes linesizes for the image in dst_data"]
    #[doc = " @param src_linesizes linesizes for the image in src_data"]
    pub fn av_image_copy(
        dst_data: *mut *mut u8,
        dst_linesizes: *mut libc::c_int,
        src_data: *mut *const u8,
        src_linesizes: *const libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where"]
    #[doc = " available, this function will use special functionality for reading from such"]
    #[doc = " memory, which may result in greatly improved performance compared to plain"]
    #[doc = " av_image_copy()."]
    #[doc = ""]
    #[doc = " The data pointers and the linesizes must be aligned to the maximum required"]
    #[doc = " by the CPU architecture."]
    #[doc = ""]
    #[doc = " @note The linesize parameters have the type ptrdiff_t here, while they are"]
    #[doc = "       int for av_image_copy()."]
    #[doc = " @note On x86, the linesizes currently need to be aligned to the cacheline"]
    #[doc = "       size (i.e. 64) to get improved performance."]
    pub fn av_image_copy_uc_from(
        dst_data: *mut *mut u8,
        dst_linesizes: *const isize,
        src_data: *mut *const u8,
        src_linesizes: *const isize,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    #[doc = " Setup the data pointers and linesizes based on the specified image"]
    #[doc = " parameters and the provided array."]
    #[doc = ""]
    #[doc = " The fields of the given image are filled in by using the src"]
    #[doc = " address which points to the image data buffer. Depending on the"]
    #[doc = " specified pixel format, one or multiple image data pointers and"]
    #[doc = " line sizes will be set.  If a planar format is specified, several"]
    #[doc = " pointers will be set pointing to the different picture planes and"]
    #[doc = " the line sizes of the different planes will be stored in the"]
    #[doc = " lines_sizes array. Call with src == NULL to get the required"]
    #[doc = " size for the src buffer."]
    #[doc = ""]
    #[doc = " To allocate the buffer and fill in the dst_data and dst_linesize in"]
    #[doc = " one call, use av_image_alloc()."]
    #[doc = ""]
    #[doc = " @param dst_data      data pointers to be filled in"]
    #[doc = " @param dst_linesize  linesizes for the image in dst_data to be filled in"]
    #[doc = " @param src           buffer which will contain or contains the actual image data, can be NULL"]
    #[doc = " @param pix_fmt       the pixel format of the image"]
    #[doc = " @param width         the width of the image in pixels"]
    #[doc = " @param height        the height of the image in pixels"]
    #[doc = " @param align         the value used in src for linesize alignment"]
    #[doc = " @return the size in bytes required for src, a negative error code"]
    #[doc = " in case of failure"]
    pub fn av_image_fill_arrays(
        dst_data: *mut *mut u8,
        dst_linesize: *mut libc::c_int,
        src: *const u8,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the size in bytes of the amount of data required to store an"]
    #[doc = " image with the given parameters."]
    #[doc = ""]
    #[doc = " @param pix_fmt  the pixel format of the image"]
    #[doc = " @param width    the width of the image in pixels"]
    #[doc = " @param height   the height of the image in pixels"]
    #[doc = " @param align    the assumed linesize alignment"]
    #[doc = " @return the buffer size in bytes, a negative error code in case of failure"]
    pub fn av_image_get_buffer_size(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy image data from an image into a buffer."]
    #[doc = ""]
    #[doc = " av_image_get_buffer_size() can be used to compute the required size"]
    #[doc = " for the buffer to fill."]
    #[doc = ""]
    #[doc = " @param dst           a buffer into which picture data will be copied"]
    #[doc = " @param dst_size      the size in bytes of dst"]
    #[doc = " @param src_data      pointers containing the source image data"]
    #[doc = " @param src_linesize  linesizes for the image in src_data"]
    #[doc = " @param pix_fmt       the pixel format of the source image"]
    #[doc = " @param width         the width of the source image in pixels"]
    #[doc = " @param height        the height of the source image in pixels"]
    #[doc = " @param align         the assumed linesize alignment for dst"]
    #[doc = " @return the number of bytes written to dst, or a negative value"]
    #[doc = " (error code) on error"]
    pub fn av_image_copy_to_buffer(
        dst: *mut u8,
        dst_size: libc::c_int,
        src_data: *const *const u8,
        src_linesize: *const libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all"]
    #[doc = " bytes of the image can be addressed with a signed int."]
    #[doc = ""]
    #[doc = " @param w the width of the picture"]
    #[doc = " @param h the height of the picture"]
    #[doc = " @param log_offset the offset to sum to the log level for logging with log_ctx"]
    #[doc = " @param log_ctx the parent logging context, it may be NULL"]
    #[doc = " @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size(
        w: libc::c_uint,
        h: libc::c_uint,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all"]
    #[doc = " bytes of a plane of an image with the specified pix_fmt can be addressed"]
    #[doc = " with a signed int."]
    #[doc = ""]
    #[doc = " @param w the width of the picture"]
    #[doc = " @param h the height of the picture"]
    #[doc = " @param max_pixels the maximum number of pixels the user wants to accept"]
    #[doc = " @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown."]
    #[doc = " @param log_offset the offset to sum to the log level for logging with log_ctx"]
    #[doc = " @param log_ctx the parent logging context, it may be NULL"]
    #[doc = " @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size2(
        w: libc::c_uint,
        h: libc::c_uint,
        max_pixels: i64,
        pix_fmt: AVPixelFormat,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the given sample aspect ratio of an image is valid."]
    #[doc = ""]
    #[doc = " It is considered invalid if the denominator is 0 or if applying the ratio"]
    #[doc = " to the image size would make the smaller dimension less than 1. If the"]
    #[doc = " sar numerator is 0, it is considered unknown and will return as valid."]
    #[doc = ""]
    #[doc = " @param w width of the image"]
    #[doc = " @param h height of the image"]
    #[doc = " @param sar sample aspect ratio of the image"]
    #[doc = " @return 0 if valid, a negative AVERROR code otherwise"]
    pub fn av_image_check_sar(w: libc::c_uint, h: libc::c_uint, sar: AVRational) -> libc::c_int;
}
extern "C" {
    #[doc = " Overwrite the image data with black. This is suitable for filling a"]
    #[doc = " sub-rectangle of an image, meaning the padding between the right most pixel"]
    #[doc = " and the left most pixel on the next line will not be overwritten. For some"]
    #[doc = " formats, the image size might be rounded up due to inherent alignment."]
    #[doc = ""]
    #[doc = " If the pixel format has alpha, the alpha is cleared to opaque."]
    #[doc = ""]
    #[doc = " This can return an error if the pixel format is not supported. Normally, all"]
    #[doc = " non-hwaccel pixel formats should be supported."]
    #[doc = ""]
    #[doc = " Passing NULL for dst_data is allowed. Then the function returns whether the"]
    #[doc = " operation would have succeeded. (It can return an error if the pix_fmt is"]
    #[doc = " not supported.)"]
    #[doc = ""]
    #[doc = " @param dst_data      data pointers to destination image"]
    #[doc = " @param dst_linesize  linesizes for the destination image"]
    #[doc = " @param pix_fmt       the pixel format of the image"]
    #[doc = " @param range         the color range of the image (important for colorspaces such as YUV)"]
    #[doc = " @param width         the width of the image in pixels"]
    #[doc = " @param height        the height of the image in pixels"]
    #[doc = " @return 0 if the image data was cleared, a negative AVERROR code otherwise"]
    pub fn av_image_fill_black(
        dst_data: *mut *mut u8,
        dst_linesize: *const isize,
        pix_fmt: AVPixelFormat,
        range: AVColorRange,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
#[doc = " Context structure for the Lagged Fibonacci PRNG."]
#[doc = " The exact layout, types and content of this struct may change and should"]
#[doc = " not be accessed directly. Only its sizeof() is guranteed to stay the same"]
#[doc = " to allow easy instanciation."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVLFG {
    pub state: [libc::c_uint; 64usize],
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVLFG() {
    assert_eq!(
        ::std::mem::size_of::<AVLFG>(),
        260usize,
        concat!("Size of: ", stringify!(AVLFG))
    );
    assert_eq!(
        ::std::mem::align_of::<AVLFG>(),
        4usize,
        concat!("Alignment of ", stringify!(AVLFG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVLFG>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLFG),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVLFG>())).index as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLFG),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn av_lfg_init(c: *mut AVLFG, seed: libc::c_uint);
}
extern "C" {
    #[doc = " Seed the state of the ALFG using binary data."]
    #[doc = ""]
    #[doc = " Return value: 0 on success, negative value (AVERROR) on failure."]
    pub fn av_lfg_init_from_data(
        c: *mut AVLFG,
        data: *const u8,
        length: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the next two numbers generated by a Box-Muller Gaussian"]
    #[doc = " generator using the random numbers issued by lfg."]
    #[doc = ""]
    #[doc = " @param out array where the two generated numbers are placed"]
    pub fn av_bmg_get(lfg: *mut AVLFG, out: *mut f64);
}
extern "C" {
    #[doc = " @brief Decodes LZO 1x compressed data."]
    #[doc = " @param out output buffer"]
    #[doc = " @param outlen size of output buffer, number of bytes left are returned here"]
    #[doc = " @param in input buffer"]
    #[doc = " @param inlen size of input buffer, number of bytes left are returned here"]
    #[doc = " @return 0 on success, otherwise a combination of the error flags above"]
    #[doc = ""]
    #[doc = " Make sure all buffers are appropriately padded, in must provide"]
    #[doc = " AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes."]
    pub fn av_lzo1x_decode(
        out: *mut libc::c_void,
        outlen: *mut libc::c_int,
        in_: *const libc::c_void,
        inlen: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @defgroup lavu_md5 MD5"]
    #[doc = " @ingroup lavu_hash"]
    #[doc = " MD5 hash function implementation."]
    #[doc = ""]
    #[doc = " @{"]
    pub static av_md5_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMD5 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVMD5 context."]
    pub fn av_md5_alloc() -> *mut AVMD5;
}
extern "C" {
    #[doc = " Initialize MD5 hashing."]
    #[doc = ""]
    #[doc = " @param ctx pointer to the function context (of size av_md5_size)"]
    pub fn av_md5_init(ctx: *mut AVMD5);
}
extern "C" {
    #[doc = " Update hash value."]
    #[doc = ""]
    #[doc = " @param ctx hash function context"]
    #[doc = " @param src input data to update hash with"]
    #[doc = " @param len input data length"]
    pub fn av_md5_update(ctx: *mut AVMD5, src: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value."]
    #[doc = ""]
    #[doc = " @param ctx hash function context"]
    #[doc = " @param dst buffer where output digest value is stored"]
    pub fn av_md5_final(ctx: *mut AVMD5, dst: *mut u8);
}
extern "C" {
    #[doc = " Hash an array of data."]
    #[doc = ""]
    #[doc = " @param dst The output buffer to write the digest into"]
    #[doc = " @param src The data to hash"]
    #[doc = " @param len The length of the data, in bytes"]
    pub fn av_md5_sum(dst: *mut u8, src: *const u8, len: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVMotionVector {
    #[doc = " Where the current macroblock comes from; negative value when it comes"]
    #[doc = " from the past, positive value when it comes from the future."]
    #[doc = " XXX: set exact relative ref frame reference instead of a +/- 1 \"direction\"."]
    pub source: i32,
    #[doc = " Width and height of the block."]
    pub w: u8,
    #[doc = " Width and height of the block."]
    pub h: u8,
    #[doc = " Absolute source position. Can be outside the frame area."]
    pub src_x: i16,
    #[doc = " Absolute source position. Can be outside the frame area."]
    pub src_y: i16,
    #[doc = " Absolute destination position. Can be outside the frame area."]
    pub dst_x: i16,
    #[doc = " Absolute destination position. Can be outside the frame area."]
    pub dst_y: i16,
    #[doc = " Extra flag information."]
    #[doc = " Currently unused."]
    pub flags: u64,
    #[doc = " Motion vector"]
    #[doc = " src_x = dst_x + motion_x / motion_scale"]
    #[doc = " src_y = dst_y + motion_y / motion_scale"]
    pub motion_x: i32,
    #[doc = " Motion vector"]
    #[doc = " src_x = dst_x + motion_x / motion_scale"]
    #[doc = " src_y = dst_y + motion_y / motion_scale"]
    pub motion_y: i32,
    pub motion_scale: u16,
}
#[test]
fn bindgen_test_layout_AVMotionVector() {
    assert_eq!(
        ::std::mem::size_of::<AVMotionVector>(),
        40usize,
        concat!("Size of: ", stringify!(AVMotionVector))
    );
    assert_eq!(
        ::std::mem::align_of::<AVMotionVector>(),
        8usize,
        concat!("Alignment of ", stringify!(AVMotionVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).h as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).src_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).src_y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).dst_x as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).dst_y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).motion_x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).motion_y as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).motion_scale as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_scale)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMurMur3 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVMurMur3 hash context."]
    #[doc = ""]
    #[doc = " @return Uninitialized hash context or `NULL` in case of error"]
    pub fn av_murmur3_alloc() -> *mut AVMurMur3;
}
extern "C" {
    #[doc = " Initialize or reinitialize an AVMurMur3 hash context with a seed."]
    #[doc = ""]
    #[doc = " @param[out] c    Hash context"]
    #[doc = " @param[in]  seed Random seed"]
    #[doc = ""]
    #[doc = " @see av_murmur3_init()"]
    #[doc = " @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of"]
    #[doc = " seeds for MurmurHash3."]
    pub fn av_murmur3_init_seeded(c: *mut AVMurMur3, seed: u64);
}
extern "C" {
    #[doc = " Initialize or reinitialize an AVMurMur3 hash context."]
    #[doc = ""]
    #[doc = " Equivalent to av_murmur3_init_seeded() with a built-in seed."]
    #[doc = ""]
    #[doc = " @param[out] c    Hash context"]
    #[doc = ""]
    #[doc = " @see av_murmur3_init_seeded()"]
    #[doc = " @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of"]
    #[doc = " seeds for MurmurHash3."]
    pub fn av_murmur3_init(c: *mut AVMurMur3);
}
extern "C" {
    #[doc = " Update hash context with new data."]
    #[doc = ""]
    #[doc = " @param[out] c    Hash context"]
    #[doc = " @param[in]  src  Input data to update hash with"]
    #[doc = " @param[in]  len  Number of bytes to read from `src`"]
    pub fn av_murmur3_update(c: *mut AVMurMur3, src: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value."]
    #[doc = ""]
    #[doc = " @param[in,out] c    Hash context"]
    #[doc = " @param[out]    dst  Buffer where output digest value is stored"]
    pub fn av_murmur3_final(c: *mut AVMurMur3, dst: *mut u8);
}
extern "C" {
    #[doc = " Parse str and store the parsed ratio in q."]
    #[doc = ""]
    #[doc = " Note that a ratio with infinite (1/0) or negative value is"]
    #[doc = " considered valid, so you should check on the returned value if you"]
    #[doc = " want to exclude those values."]
    #[doc = ""]
    #[doc = " The undefined value can be expressed using the \"0:0\" string."]
    #[doc = ""]
    #[doc = " @param[in,out] q pointer to the AVRational which will contain the ratio"]
    #[doc = " @param[in] str the string to parse: it has to be a string in the format"]
    #[doc = " num:den, a float number or an expression"]
    #[doc = " @param[in] max the maximum allowed numerator and denominator"]
    #[doc = " @param[in] log_offset log level offset which is applied to the log"]
    #[doc = " level of log_ctx"]
    #[doc = " @param[in] log_ctx parent logging context"]
    #[doc = " @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_ratio(
        q: *mut AVRational,
        str_: *const libc::c_char,
        max: libc::c_int,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse str and put in width_ptr and height_ptr the detected values."]
    #[doc = ""]
    #[doc = " @param[in,out] width_ptr pointer to the variable which will contain the detected"]
    #[doc = " width value"]
    #[doc = " @param[in,out] height_ptr pointer to the variable which will contain the detected"]
    #[doc = " height value"]
    #[doc = " @param[in] str the string to parse: it has to be a string in the format"]
    #[doc = " width x height or a valid video size abbreviation."]
    #[doc = " @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_video_size(
        width_ptr: *mut libc::c_int,
        height_ptr: *mut libc::c_int,
        str_: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse str and store the detected values in *rate."]
    #[doc = ""]
    #[doc = " @param[in,out] rate pointer to the AVRational which will contain the detected"]
    #[doc = " frame rate"]
    #[doc = " @param[in] str the string to parse: it has to be a string in the format"]
    #[doc = " rate_num / rate_den, a float number or a valid video rate abbreviation"]
    #[doc = " @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_video_rate(rate: *mut AVRational, str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Put the RGBA values that correspond to color_string in rgba_color."]
    #[doc = ""]
    #[doc = " @param color_string a string specifying a color. It can be the name of"]
    #[doc = " a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,"]
    #[doc = " possibly followed by \"@\" and a string representing the alpha"]
    #[doc = " component."]
    #[doc = " The alpha component may be a string composed by \"0x\" followed by an"]
    #[doc = " hexadecimal number or a decimal number between 0.0 and 1.0, which"]
    #[doc = " represents the opacity value (0x00/0.0 means completely transparent,"]
    #[doc = " 0xff/1.0 completely opaque)."]
    #[doc = " If the alpha component is not specified then 0xff is assumed."]
    #[doc = " The string \"random\" will result in a random color."]
    #[doc = " @param slen length of the initial part of color_string containing the"]
    #[doc = " color. It can be set to -1 if color_string is a null terminated string"]
    #[doc = " containing nothing else than the color."]
    #[doc = " @return >= 0 in case of success, a negative value in case of"]
    #[doc = " failure (for example if color_string cannot be parsed)."]
    pub fn av_parse_color(
        rgba_color: *mut u8,
        color_string: *const libc::c_char,
        slen: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name of a color from the internal table of hard-coded named"]
    #[doc = " colors."]
    #[doc = ""]
    #[doc = " This function is meant to enumerate the color names recognized by"]
    #[doc = " av_parse_color()."]
    #[doc = ""]
    #[doc = " @param color_idx index of the requested color, starting from 0"]
    #[doc = " @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB"]
    #[doc = " @return the color name string or NULL if color_idx is not in the array"]
    pub fn av_get_known_color_name(
        color_idx: libc::c_int,
        rgb: *mut *const u8,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Parse timestr and return in *time a corresponding number of"]
    #[doc = " microseconds."]
    #[doc = ""]
    #[doc = " @param timeval puts here the number of microseconds corresponding"]
    #[doc = " to the string in timestr. If the string represents a duration, it"]
    #[doc = " is the number of microseconds contained in the time interval.  If"]
    #[doc = " the string is a date, is the number of microseconds since 1st of"]
    #[doc = " January, 1970 up to the time of the parsed date.  If timestr cannot"]
    #[doc = " be successfully parsed, set *time to INT64_MIN."]
    #[doc = ""]
    #[doc = " @param timestr a string representing a date or a duration."]
    #[doc = " - If a date the syntax is:"]
    #[doc = " @code"]
    #[doc = " [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]"]
    #[doc = " now"]
    #[doc = " @endcode"]
    #[doc = " If the value is \"now\" it takes the current time."]
    #[doc = " Time is local time unless Z is appended, in which case it is"]
    #[doc = " interpreted as UTC."]
    #[doc = " If the year-month-day part is not specified it takes the current"]
    #[doc = " year-month-day."]
    #[doc = " - If a duration the syntax is:"]
    #[doc = " @code"]
    #[doc = " [-][HH:]MM:SS[.m...]"]
    #[doc = " [-]S+[.m...]"]
    #[doc = " @endcode"]
    #[doc = " @param duration flag which tells how to interpret timestr, if not"]
    #[doc = " zero timestr is interpreted as a duration, otherwise as a date"]
    #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
    #[doc = " AVERROR code otherwise"]
    pub fn av_parse_time(
        timeval: *mut i64,
        timestr: *const libc::c_char,
        duration: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Attempt to find a specific tag in a URL."]
    #[doc = ""]
    #[doc = " syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done."]
    #[doc = " Return 1 if found."]
    pub fn av_find_info_tag(
        arg: *mut libc::c_char,
        arg_size: libc::c_int,
        tag1: *const libc::c_char,
        info: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Simplified version of strptime"]
    #[doc = ""]
    #[doc = " Parse the input string p according to the format string fmt and"]
    #[doc = " store its results in the structure dt."]
    #[doc = " This implementation supports only a subset of the formats supported"]
    #[doc = " by the standard strptime()."]
    #[doc = ""]
    #[doc = " The supported input field descriptors are listed below."]
    #[doc = " - %H: the hour as a decimal number, using a 24-hour clock, in the"]
    #[doc = "   range '00' through '23'"]
    #[doc = " - %J: hours as a decimal number, in the range '0' through INT_MAX"]
    #[doc = " - %M: the minute as a decimal number, using a 24-hour clock, in the"]
    #[doc = "   range '00' through '59'"]
    #[doc = " - %S: the second as a decimal number, using a 24-hour clock, in the"]
    #[doc = "   range '00' through '59'"]
    #[doc = " - %Y: the year as a decimal number, using the Gregorian calendar"]
    #[doc = " - %m: the month as a decimal number, in the range '1' through '12'"]
    #[doc = " - %d: the day of the month as a decimal number, in the range '1'"]
    #[doc = "   through '31'"]
    #[doc = " - %T: alias for '%H:%M:%S'"]
    #[doc = " - %%: a literal '%'"]
    #[doc = ""]
    #[doc = " @return a pointer to the first character not processed in this function"]
    #[doc = "         call. In case the input string contains more characters than"]
    #[doc = "         required by the format string the return value points right after"]
    #[doc = "         the last consumed input character. In case the whole input string"]
    #[doc = "         is consumed the return value points to the null byte at the end of"]
    #[doc = "         the string. On failure NULL is returned."]
    pub fn av_small_strptime(
        p: *const libc::c_char,
        fmt: *const libc::c_char,
        dt: *mut tm,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Convert the decomposed UTC time in tm to a time_t value."]
    pub fn av_timegm(tm: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Get a seed to use in conjunction with random functions."]
    #[doc = " This function tries to provide a good seed at a best effort bases."]
    #[doc = " Its possible to call this function multiple times if more bits are needed."]
    #[doc = " It can be quite slow, which is why it should only be used as seed for a faster"]
    #[doc = " PRNG. The quality of the seed depends on the platform."]
    pub fn av_get_random_seed() -> u32;
}
#[doc = " ReplayGain information (see"]
#[doc = " http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification)."]
#[doc = " The size of this struct is a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVReplayGain {
    #[doc = " Track replay gain in microbels (divide by 100000 to get the value in dB)."]
    #[doc = " Should be set to INT32_MIN when unknown."]
    pub track_gain: i32,
    #[doc = " Peak track amplitude, with 100000 representing full scale (but values"]
    #[doc = " may overflow). 0 when unknown."]
    pub track_peak: u32,
    #[doc = " Same as track_gain, but for the whole album."]
    pub album_gain: i32,
    #[doc = " Same as track_peak, but for the whole album,"]
    pub album_peak: u32,
}
#[test]
fn bindgen_test_layout_AVReplayGain() {
    assert_eq!(
        ::std::mem::size_of::<AVReplayGain>(),
        16usize,
        concat!("Size of: ", stringify!(AVReplayGain))
    );
    assert_eq!(
        ::std::mem::align_of::<AVReplayGain>(),
        4usize,
        concat!("Alignment of ", stringify!(AVReplayGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).track_gain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(track_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).track_peak as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(track_peak)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).album_gain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(album_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).album_peak as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(album_peak)
        )
    );
}
extern "C" {
    #[doc = " @defgroup lavu_ripemd RIPEMD"]
    #[doc = " @ingroup lavu_hash"]
    #[doc = " RIPEMD hash function implementation."]
    #[doc = ""]
    #[doc = " @{"]
    pub static av_ripemd_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRIPEMD {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVRIPEMD context."]
    pub fn av_ripemd_alloc() -> *mut AVRIPEMD;
}
extern "C" {
    #[doc = " Initialize RIPEMD hashing."]
    #[doc = ""]
    #[doc = " @param context pointer to the function context (of size av_ripemd_size)"]
    #[doc = " @param bits    number of bits in digest (128, 160, 256 or 320 bits)"]
    #[doc = " @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_ripemd_init(context: *mut AVRIPEMD, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Update hash value."]
    #[doc = ""]
    #[doc = " @param context hash function context"]
    #[doc = " @param data    input data to update hash with"]
    #[doc = " @param len     input data length"]
    pub fn av_ripemd_update(context: *mut AVRIPEMD, data: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value."]
    #[doc = ""]
    #[doc = " @param context hash function context"]
    #[doc = " @param digest  buffer where output digest value is stored"]
    pub fn av_ripemd_final(context: *mut AVRIPEMD, digest: *mut u8);
}
extern "C" {
    #[doc = " @defgroup lavu_sha SHA"]
    #[doc = " @ingroup lavu_hash"]
    #[doc = " SHA-1 and SHA-256 (Secure Hash Algorithm) hash function implementations."]
    #[doc = ""]
    #[doc = " This module supports the following SHA hash functions:"]
    #[doc = ""]
    #[doc = " - SHA-1: 160 bits"]
    #[doc = " - SHA-224: 224 bits, as a variant of SHA-2"]
    #[doc = " - SHA-256: 256 bits, as a variant of SHA-2"]
    #[doc = ""]
    #[doc = " @see For SHA-384, SHA-512, and variants thereof, see @ref lavu_sha512."]
    #[doc = ""]
    #[doc = " @{"]
    pub static av_sha_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVSHA context."]
    pub fn av_sha_alloc() -> *mut AVSHA;
}
extern "C" {
    #[doc = " Initialize SHA-1 or SHA-2 hashing."]
    #[doc = ""]
    #[doc = " @param context pointer to the function context (of size av_sha_size)"]
    #[doc = " @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)"]
    #[doc = " @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_sha_init(context: *mut AVSHA, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Update hash value."]
    #[doc = ""]
    #[doc = " @param ctx     hash function context"]
    #[doc = " @param data    input data to update hash with"]
    #[doc = " @param len     input data length"]
    pub fn av_sha_update(ctx: *mut AVSHA, data: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value."]
    #[doc = ""]
    #[doc = " @param context hash function context"]
    #[doc = " @param digest  buffer where output digest value is stored"]
    pub fn av_sha_final(context: *mut AVSHA, digest: *mut u8);
}
extern "C" {
    #[doc = " @defgroup lavu_sha512 SHA-512"]
    #[doc = " @ingroup lavu_hash"]
    #[doc = " SHA-512 (Secure Hash Algorithm) hash function implementations."]
    #[doc = ""]
    #[doc = " This module supports the following SHA-2 hash functions:"]
    #[doc = ""]
    #[doc = " - SHA-512/224: 224 bits"]
    #[doc = " - SHA-512/256: 256 bits"]
    #[doc = " - SHA-384: 384 bits"]
    #[doc = " - SHA-512: 512 bits"]
    #[doc = ""]
    #[doc = " @see For SHA-1, SHA-256, and variants thereof, see @ref lavu_sha."]
    #[doc = ""]
    #[doc = " @{"]
    pub static av_sha512_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA512 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVSHA512 context."]
    pub fn av_sha512_alloc() -> *mut AVSHA512;
}
extern "C" {
    #[doc = " Initialize SHA-2 512 hashing."]
    #[doc = ""]
    #[doc = " @param context pointer to the function context (of size av_sha512_size)"]
    #[doc = " @param bits    number of bits in digest (224, 256, 384 or 512 bits)"]
    #[doc = " @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_sha512_init(context: *mut AVSHA512, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Update hash value."]
    #[doc = ""]
    #[doc = " @param context hash function context"]
    #[doc = " @param data    input data to update hash with"]
    #[doc = " @param len     input data length"]
    pub fn av_sha512_update(context: *mut AVSHA512, data: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value."]
    #[doc = ""]
    #[doc = " @param context hash function context"]
    #[doc = " @param digest  buffer where output digest value is stored"]
    pub fn av_sha512_final(context: *mut AVSHA512, digest: *mut u8);
}
#[repr(u32)]
#[doc = " List of possible 3D Types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVStereo3DType {
    #[doc = " Video is not stereoscopic (and metadata has to be there)."]
    AV_STEREO3D_2D = 0,
    #[doc = " Views are next to each other."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LLLLRRRR"]
    #[doc = "    LLLLRRRR"]
    #[doc = "    LLLLRRRR"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    AV_STEREO3D_SIDEBYSIDE = 1,
    #[doc = " Views are on top of each other."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    RRRRRRRR"]
    #[doc = "    RRRRRRRR"]
    #[doc = " @endcode"]
    AV_STEREO3D_TOPBOTTOM = 2,
    #[doc = " Views are alternated temporally."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "     frame0   frame1   frame2   ..."]
    #[doc = "    LLLLLLLL RRRRRRRR LLLLLLLL"]
    #[doc = "    LLLLLLLL RRRRRRRR LLLLLLLL"]
    #[doc = "    LLLLLLLL RRRRRRRR LLLLLLLL"]
    #[doc = "    ...      ...      ..."]
    #[doc = " @endcode"]
    AV_STEREO3D_FRAMESEQUENCE = 3,
    #[doc = " Views are packed in a checkerboard-like structure per pixel."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    RLRLRLRL"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    AV_STEREO3D_CHECKERBOARD = 4,
    #[doc = " Views are next to each other, but when upscaling"]
    #[doc = " apply a checkerboard pattern."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "     LLLLRRRR          L L L L    R R R R"]
    #[doc = "     LLLLRRRR    =>     L L L L  R R R R"]
    #[doc = "     LLLLRRRR          L L L L    R R R R"]
    #[doc = "     LLLLRRRR           L L L L  R R R R"]
    #[doc = " @endcode"]
    AV_STEREO3D_SIDEBYSIDE_QUINCUNX = 5,
    #[doc = " Views are packed per line, as if interlaced."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    RRRRRRRR"]
    #[doc = "    LLLLLLLL"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    AV_STEREO3D_LINES = 6,
    #[doc = " Views are packed per column."]
    #[doc = ""]
    #[doc = " @code{.unparsed}"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    LRLRLRLR"]
    #[doc = "    ..."]
    #[doc = " @endcode"]
    AV_STEREO3D_COLUMNS = 7,
}
#[repr(u32)]
#[doc = " List of possible view types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVStereo3DView {
    #[doc = " Frame contains two packed views."]
    AV_STEREO3D_VIEW_PACKED = 0,
    #[doc = " Frame contains only the left view."]
    AV_STEREO3D_VIEW_LEFT = 1,
    #[doc = " Frame contains only the right view."]
    AV_STEREO3D_VIEW_RIGHT = 2,
}
#[doc = " Stereo 3D type: this structure describes how two videos are packed"]
#[doc = " within a single video surface, with additional information as needed."]
#[doc = ""]
#[doc = " @note The struct must be allocated with av_stereo3d_alloc() and"]
#[doc = "       its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVStereo3D {
    #[doc = " How views are packed within the video."]
    pub type_: AVStereo3DType,
    #[doc = " Additional information about the frame packing."]
    pub flags: libc::c_int,
    #[doc = " Determines which views are packed."]
    pub view: AVStereo3DView,
}
#[test]
fn bindgen_test_layout_AVStereo3D() {
    assert_eq!(
        ::std::mem::size_of::<AVStereo3D>(),
        12usize,
        concat!("Size of: ", stringify!(AVStereo3D))
    );
    assert_eq!(
        ::std::mem::align_of::<AVStereo3D>(),
        4usize,
        concat!("Alignment of ", stringify!(AVStereo3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStereo3D>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStereo3D>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStereo3D>())).view as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(view)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVStereo3D structure and set its fields to default values."]
    #[doc = " The resulting struct can be freed using av_freep()."]
    #[doc = ""]
    #[doc = " @return An AVStereo3D filled with default values or NULL on failure."]
    pub fn av_stereo3d_alloc() -> *mut AVStereo3D;
}
extern "C" {
    #[doc = " Allocate a complete AVFrameSideData and add it to the frame."]
    #[doc = ""]
    #[doc = " @param frame The frame which side data is added to."]
    #[doc = ""]
    #[doc = " @return The AVStereo3D structure to be filled by caller."]
    pub fn av_stereo3d_create_side_data(frame: *mut AVFrame) -> *mut AVStereo3D;
}
extern "C" {
    #[doc = " Provide a human-readable name of a given stereo3d type."]
    #[doc = ""]
    #[doc = " @param type The input stereo3d type value."]
    #[doc = ""]
    #[doc = " @return The name of the stereo3d value, or \"unknown\"."]
    pub fn av_stereo3d_type_name(type_: libc::c_uint) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the AVStereo3DType form a human-readable name."]
    #[doc = ""]
    #[doc = " @param name The input string."]
    #[doc = ""]
    #[doc = " @return The AVStereo3DType value, or -1 if not found."]
    pub fn av_stereo3d_from_name(name: *const libc::c_char) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVThreadMessageQueue {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVThreadMessageFlags {
    #[doc = " Perform non-blocking operation."]
    #[doc = " If this flag is set, send and recv operations are non-blocking and"]
    #[doc = " return AVERROR(EAGAIN) immediately if they can not proceed."]
    AV_THREAD_MESSAGE_NONBLOCK = 1,
}
extern "C" {
    #[doc = " Allocate a new message queue."]
    #[doc = ""]
    #[doc = " @param mq      pointer to the message queue"]
    #[doc = " @param nelem   maximum number of elements in the queue"]
    #[doc = " @param elsize  size of each element in the queue"]
    #[doc = " @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if"]
    #[doc = "          lavu was built without thread support"]
    pub fn av_thread_message_queue_alloc(
        mq: *mut *mut AVThreadMessageQueue,
        nelem: libc::c_uint,
        elsize: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a message queue."]
    #[doc = ""]
    #[doc = " The message queue must no longer be in use by another thread."]
    pub fn av_thread_message_queue_free(mq: *mut *mut AVThreadMessageQueue);
}
extern "C" {
    #[doc = " Send a message on the queue."]
    pub fn av_thread_message_queue_send(
        mq: *mut AVThreadMessageQueue,
        msg: *mut libc::c_void,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Receive a message from the queue."]
    pub fn av_thread_message_queue_recv(
        mq: *mut AVThreadMessageQueue,
        msg: *mut libc::c_void,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the sending error code."]
    #[doc = ""]
    #[doc = " If the error code is set to non-zero, av_thread_message_queue_send() will"]
    #[doc = " return it immediately. Conventional values, such as AVERROR_EOF or"]
    #[doc = " AVERROR(EAGAIN), can be used to cause the sending thread to stop or"]
    #[doc = " suspend its operation."]
    pub fn av_thread_message_queue_set_err_send(mq: *mut AVThreadMessageQueue, err: libc::c_int);
}
extern "C" {
    #[doc = " Set the receiving error code."]
    #[doc = ""]
    #[doc = " If the error code is set to non-zero, av_thread_message_queue_recv() will"]
    #[doc = " return it immediately when there are no longer available messages."]
    #[doc = " Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used"]
    #[doc = " to cause the receiving thread to stop or suspend its operation."]
    pub fn av_thread_message_queue_set_err_recv(mq: *mut AVThreadMessageQueue, err: libc::c_int);
}
extern "C" {
    #[doc = " Set the optional free message callback function which will be called if an"]
    #[doc = " operation is removing messages from the queue."]
    pub fn av_thread_message_queue_set_free_func(
        mq: *mut AVThreadMessageQueue,
        free_func: ::std::option::Option<unsafe extern "C" fn(msg: *mut libc::c_void)>,
    );
}
extern "C" {
    #[doc = " Return the current number of messages in the queue."]
    #[doc = ""]
    #[doc = " @return the current number of messages or AVERROR(ENOSYS) if lavu was built"]
    #[doc = "         without thread support"]
    pub fn av_thread_message_queue_nb_elems(mq: *mut AVThreadMessageQueue) -> libc::c_int;
}
extern "C" {
    #[doc = " Flush the message queue"]
    #[doc = ""]
    #[doc = " This function is mostly equivalent to reading and free-ing every message"]
    #[doc = " except that it will be done in a single operation (no lock/unlock between"]
    #[doc = " reads)."]
    pub fn av_thread_message_flush(mq: *mut AVThreadMessageQueue);
}
extern "C" {
    #[doc = " Get the current time in microseconds."]
    pub fn av_gettime() -> i64;
}
extern "C" {
    #[doc = " Get the current time in microseconds since some unspecified starting point."]
    #[doc = " On platforms that support it, the time comes from a monotonic clock"]
    #[doc = " This property makes this time source ideal for measuring relative time."]
    #[doc = " The returned values may not be monotonic on platforms where a monotonic"]
    #[doc = " clock is not available."]
    pub fn av_gettime_relative() -> i64;
}
extern "C" {
    #[doc = " Indicates with a boolean result if the av_gettime_relative() time source"]
    #[doc = " is monotonic."]
    pub fn av_gettime_relative_is_monotonic() -> libc::c_int;
}
extern "C" {
    #[doc = " Sleep for a period of time.  Although the duration is expressed in"]
    #[doc = " microseconds, the actual delay may be rounded to the precision of the"]
    #[doc = " system timer."]
    #[doc = ""]
    #[doc = " @param  usec Number of microseconds to sleep."]
    #[doc = " @return zero on success or (negative) error code."]
    pub fn av_usleep(usec: libc::c_uint) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVTimecodeFlag {
    #[doc = "< timecode is drop frame"]
    AV_TIMECODE_FLAG_DROPFRAME = 1,
    #[doc = "< timecode wraps after 24 hours"]
    AV_TIMECODE_FLAG_24HOURSMAX = 2,
    #[doc = "< negative time values are allowed"]
    AV_TIMECODE_FLAG_ALLOWNEGATIVE = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVTimecode {
    #[doc = "< timecode frame start (first base frame number)"]
    pub start: libc::c_int,
    #[doc = "< flags such as drop frame, +24 hours support, ..."]
    pub flags: u32,
    #[doc = "< frame rate in rational form"]
    pub rate: AVRational,
    #[doc = "< frame per second; must be consistent with the rate field"]
    pub fps: libc::c_uint,
}
#[test]
fn bindgen_test_layout_AVTimecode() {
    assert_eq!(
        ::std::mem::size_of::<AVTimecode>(),
        20usize,
        concat!("Size of: ", stringify!(AVTimecode))
    );
    assert_eq!(
        ::std::mem::align_of::<AVTimecode>(),
        4usize,
        concat!("Alignment of ", stringify!(AVTimecode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).rate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).fps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(fps)
        )
    );
}
extern "C" {
    #[doc = " Adjust frame number for NTSC drop frame time code."]
    #[doc = ""]
    #[doc = " @param framenum frame number to adjust"]
    #[doc = " @param fps      frame per second, multiples of 30"]
    #[doc = " @return         adjusted frame number"]
    #[doc = " @warning        adjustment is only valid for multiples of NTSC 29.97"]
    pub fn av_timecode_adjust_ntsc_framenum2(
        framenum: libc::c_int,
        fps: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert frame number to SMPTE 12M binary representation."]
    #[doc = ""]
    #[doc = " @param tc       timecode data correctly initialized"]
    #[doc = " @param framenum frame number"]
    #[doc = " @return         the SMPTE binary representation"]
    #[doc = ""]
    #[doc = " See SMPTE ST 314M-2005 Sec 4.4.2.2.1 \"Time code pack (TC)\""]
    #[doc = " the format description as follows:"]
    #[doc = " bits 0-5:   hours, in BCD(6bits)"]
    #[doc = " bits 6:     BGF1"]
    #[doc = " bits 7:     BGF2 (NTSC) or FIELD (PAL)"]
    #[doc = " bits 8-14:  minutes, in BCD(7bits)"]
    #[doc = " bits 15:    BGF0 (NTSC) or BGF2 (PAL)"]
    #[doc = " bits 16-22: seconds, in BCD(7bits)"]
    #[doc = " bits 23:    FIELD (NTSC) or BGF0 (PAL)"]
    #[doc = " bits 24-29: frames, in BCD(6bits)"]
    #[doc = " bits 30:    drop  frame flag (0: non drop,    1: drop)"]
    #[doc = " bits 31:    color frame flag (0: unsync mode, 1: sync mode)"]
    #[doc = " @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens."]
    #[doc = " @note Frame number adjustment is automatically done in case of drop timecode,"]
    #[doc = "       you do NOT have to call av_timecode_adjust_ntsc_framenum2()."]
    #[doc = " @note The frame number is relative to tc->start."]
    #[doc = " @note Color frame (CF) and binary group flags (BGF) bits are set to zero."]
    pub fn av_timecode_get_smpte_from_framenum(tc: *const AVTimecode, framenum: libc::c_int)
        -> u32;
}
extern "C" {
    #[doc = " Convert sei info to SMPTE 12M binary representation."]
    #[doc = ""]
    #[doc = " @param rate     frame rate in rational form"]
    #[doc = " @param drop     drop flag"]
    #[doc = " @param hh       hour"]
    #[doc = " @param mm       minute"]
    #[doc = " @param ss       second"]
    #[doc = " @param ff       frame number"]
    #[doc = " @return         the SMPTE binary representation"]
    pub fn av_timecode_get_smpte(
        rate: AVRational,
        drop: libc::c_int,
        hh: libc::c_int,
        mm: libc::c_int,
        ss: libc::c_int,
        ff: libc::c_int,
    ) -> u32;
}
extern "C" {
    #[doc = " Load timecode string in buf."]
    #[doc = ""]
    #[doc = " @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
    #[doc = " @param tc       timecode data correctly initialized"]
    #[doc = " @param framenum frame number"]
    #[doc = " @return         the buf parameter"]
    #[doc = ""]
    #[doc = " @note Timecode representation can be a negative timecode and have more than"]
    #[doc = "       24 hours, but will only be honored if the flags are correctly set."]
    #[doc = " @note The frame number is relative to tc->start."]
    pub fn av_timecode_make_string(
        tc: *const AVTimecode,
        buf: *mut libc::c_char,
        framenum: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the SMPTE timecode format."]
    #[doc = ""]
    #[doc = " In contrast to av_timecode_make_smpte_tc_string this function supports 50/60"]
    #[doc = " fps timecodes by using the field bit."]
    #[doc = ""]
    #[doc = " @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
    #[doc = " @param rate       frame rate of the timecode"]
    #[doc = " @param tcsmpte    the 32-bit SMPTE timecode"]
    #[doc = " @param prevent_df prevent the use of a drop flag when it is known the DF bit"]
    #[doc = "                   is arbitrary"]
    #[doc = " @param skip_field prevent the use of a field flag when it is known the field"]
    #[doc = "                   bit is arbitrary (e.g. because it is used as PC flag)"]
    #[doc = " @return           the buf parameter"]
    pub fn av_timecode_make_smpte_tc_string2(
        buf: *mut libc::c_char,
        rate: AVRational,
        tcsmpte: u32,
        prevent_df: libc::c_int,
        skip_field: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the SMPTE timecode format."]
    #[doc = ""]
    #[doc = " @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
    #[doc = " @param tcsmpte    the 32-bit SMPTE timecode"]
    #[doc = " @param prevent_df prevent the use of a drop flag when it is known the DF bit"]
    #[doc = "                   is arbitrary"]
    #[doc = " @return           the buf parameter"]
    pub fn av_timecode_make_smpte_tc_string(
        buf: *mut libc::c_char,
        tcsmpte: u32,
        prevent_df: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the 25-bit timecode format (MPEG GOP format)."]
    #[doc = ""]
    #[doc = " @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long"]
    #[doc = " @param tc25bit the 25-bits timecode"]
    #[doc = " @return        the buf parameter"]
    pub fn av_timecode_make_mpeg_tc_string(
        buf: *mut libc::c_char,
        tc25bit: u32,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Init a timecode struct with the passed parameters."]
    #[doc = ""]
    #[doc = " @param log_ctx     a pointer to an arbitrary struct of which the first field"]
    #[doc = "                    is a pointer to an AVClass struct (used for av_log)"]
    #[doc = " @param tc          pointer to an allocated AVTimecode"]
    #[doc = " @param rate        frame rate in rational form"]
    #[doc = " @param flags       miscellaneous flags such as drop frame, +24 hours, ..."]
    #[doc = "                    (see AVTimecodeFlag)"]
    #[doc = " @param frame_start the first frame number"]
    #[doc = " @return            0 on success, AVERROR otherwise"]
    pub fn av_timecode_init(
        tc: *mut AVTimecode,
        rate: AVRational,
        flags: libc::c_int,
        frame_start: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Init a timecode struct from the passed timecode components."]
    #[doc = ""]
    #[doc = " @param log_ctx     a pointer to an arbitrary struct of which the first field"]
    #[doc = "                    is a pointer to an AVClass struct (used for av_log)"]
    #[doc = " @param tc          pointer to an allocated AVTimecode"]
    #[doc = " @param rate        frame rate in rational form"]
    #[doc = " @param flags       miscellaneous flags such as drop frame, +24 hours, ..."]
    #[doc = "                    (see AVTimecodeFlag)"]
    #[doc = " @param hh          hours"]
    #[doc = " @param mm          minutes"]
    #[doc = " @param ss          seconds"]
    #[doc = " @param ff          frames"]
    #[doc = " @return            0 on success, AVERROR otherwise"]
    pub fn av_timecode_init_from_components(
        tc: *mut AVTimecode,
        rate: AVRational,
        flags: libc::c_int,
        hh: libc::c_int,
        mm: libc::c_int,
        ss: libc::c_int,
        ff: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Parse timecode representation (hh:mm:ss[:;.]ff)."]
    #[doc = ""]
    #[doc = " @param log_ctx a pointer to an arbitrary struct of which the first field is a"]
    #[doc = "                pointer to an AVClass struct (used for av_log)."]
    #[doc = " @param tc      pointer to an allocated AVTimecode"]
    #[doc = " @param rate    frame rate in rational form"]
    #[doc = " @param str     timecode string which will determine the frame start"]
    #[doc = " @return        0 on success, AVERROR otherwise"]
    pub fn av_timecode_init_from_string(
        tc: *mut AVTimecode,
        rate: AVRational,
        str_: *const libc::c_char,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the timecode feature is available for the given frame rate"]
    #[doc = ""]
    #[doc = " @return 0 if supported, <0 otherwise"]
    pub fn av_timecode_check_frame_rate(rate: AVRational) -> libc::c_int;
}
extern "C" {
    #[doc = " @file"]
    #[doc = " @brief Public header for libavutil TWOFISH algorithm"]
    #[doc = " @defgroup lavu_twofish TWOFISH"]
    #[doc = " @ingroup lavu_crypto"]
    #[doc = " @{"]
    pub static av_twofish_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTWOFISH {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVTWOFISH context"]
    #[doc = " To free the struct: av_free(ptr)"]
    pub fn av_twofish_alloc() -> *mut AVTWOFISH;
}
extern "C" {
    #[doc = " Initialize an AVTWOFISH context."]
    #[doc = ""]
    #[doc = " @param ctx an AVTWOFISH context"]
    #[doc = " @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption"]
    #[doc = " @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise"]
    pub fn av_twofish_init(
        ctx: *mut AVTWOFISH,
        key: *const u8,
        key_bits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context"]
    #[doc = ""]
    #[doc = " @param ctx an AVTWOFISH context"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param count number of 16 byte blocks"]
    #[doc = " @paran iv initialization vector for CBC mode, NULL for ECB mode"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_twofish_crypt(
        ctx: *mut AVTWOFISH,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[doc = " @file"]
#[doc = " @brief Public header for libavutil XTEA algorithm"]
#[doc = " @defgroup lavu_xtea XTEA"]
#[doc = " @ingroup lavu_crypto"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVXTEA {
    pub key: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_AVXTEA() {
    assert_eq!(
        ::std::mem::size_of::<AVXTEA>(),
        64usize,
        concat!("Size of: ", stringify!(AVXTEA))
    );
    assert_eq!(
        ::std::mem::align_of::<AVXTEA>(),
        4usize,
        concat!("Alignment of ", stringify!(AVXTEA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVXTEA>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVXTEA),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVXTEA context."]
    pub fn av_xtea_alloc() -> *mut AVXTEA;
}
extern "C" {
    #[doc = " Initialize an AVXTEA context."]
    #[doc = ""]
    #[doc = " @param ctx an AVXTEA context"]
    #[doc = " @param key a key of 16 bytes used for encryption/decryption,"]
    #[doc = "            interpreted as big endian 32 bit numbers"]
    pub fn av_xtea_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    #[doc = " Initialize an AVXTEA context."]
    #[doc = ""]
    #[doc = " @param ctx an AVXTEA context"]
    #[doc = " @param key a key of 16 bytes used for encryption/decryption,"]
    #[doc = "            interpreted as little endian 32 bit numbers"]
    pub fn av_xtea_le_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context,"]
    #[doc = " in big endian format."]
    #[doc = ""]
    #[doc = " @param ctx an AVXTEA context"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param count number of 8 byte blocks"]
    #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_xtea_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context,"]
    #[doc = " in little endian format."]
    #[doc = ""]
    #[doc = " @param ctx an AVXTEA context"]
    #[doc = " @param dst destination array, can be equal to src"]
    #[doc = " @param src source array, can be equal to dst"]
    #[doc = " @param count number of 8 byte blocks"]
    #[doc = " @param iv initialization vector for CBC mode, if NULL then ECB will be used"]
    #[doc = " @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_xtea_le_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[repr(u32)]
#[doc = " Dithering algorithms"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SwrDitherType {
    SWR_DITHER_NONE = 0,
    SWR_DITHER_RECTANGULAR = 1,
    SWR_DITHER_TRIANGULAR = 2,
    SWR_DITHER_TRIANGULAR_HIGHPASS = 3,
    #[doc = "< not part of API/ABI"]
    SWR_DITHER_NS = 64,
    SWR_DITHER_NS_LIPSHITZ = 65,
    SWR_DITHER_NS_F_WEIGHTED = 66,
    SWR_DITHER_NS_MODIFIED_E_WEIGHTED = 67,
    SWR_DITHER_NS_IMPROVED_E_WEIGHTED = 68,
    SWR_DITHER_NS_SHIBATA = 69,
    SWR_DITHER_NS_LOW_SHIBATA = 70,
    SWR_DITHER_NS_HIGH_SHIBATA = 71,
    #[doc = "< not part of API/ABI"]
    SWR_DITHER_NB = 72,
}
#[repr(u32)]
#[doc = " Resampling Engines"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SwrEngine {
    #[doc = "< SW Resampler"]
    SWR_ENGINE_SWR = 0,
    #[doc = "< SoX Resampler"]
    SWR_ENGINE_SOXR = 1,
    #[doc = "< not part of API/ABI"]
    SWR_ENGINE_NB = 2,
}
#[repr(u32)]
#[doc = " Resampling Filter Types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SwrFilterType {
    #[doc = "< Cubic"]
    SWR_FILTER_TYPE_CUBIC = 0,
    #[doc = "< Blackman Nuttall windowed sinc"]
    SWR_FILTER_TYPE_BLACKMAN_NUTTALL = 1,
    #[doc = "< Kaiser windowed sinc"]
    SWR_FILTER_TYPE_KAISER = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwrContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the AVClass for SwrContext. It can be used in combination with"]
    #[doc = " AV_OPT_SEARCH_FAKE_OBJ for examining options."]
    #[doc = ""]
    #[doc = " @see av_opt_find()."]
    #[doc = " @return the AVClass of SwrContext"]
    pub fn swr_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Allocate SwrContext."]
    #[doc = ""]
    #[doc = " If you use this function you will need to set the parameters (manually or"]
    #[doc = " with swr_alloc_set_opts2()) before calling swr_init()."]
    #[doc = ""]
    #[doc = " @see swr_alloc_set_opts2(), swr_init(), swr_free()"]
    #[doc = " @return NULL on error, allocated context otherwise"]
    pub fn swr_alloc() -> *mut SwrContext;
}
extern "C" {
    #[doc = " Initialize context after user parameters have been set."]
    #[doc = " @note The context must be configured using the AVOption API."]
    #[doc = ""]
    #[doc = " @see av_opt_set_int()"]
    #[doc = " @see av_opt_set_dict()"]
    #[doc = ""]
    #[doc = " @param[in,out]   s Swr context to initialize"]
    #[doc = " @return AVERROR error code in case of failure."]
    pub fn swr_init(s: *mut SwrContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Check whether an swr context has been initialized or not."]
    #[doc = ""]
    #[doc = " @param[in]       s Swr context to check"]
    #[doc = " @see swr_init()"]
    #[doc = " @return positive if it has been initialized, 0 if not initialized"]
    pub fn swr_is_initialized(s: *mut SwrContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate SwrContext if needed and set/reset common parameters."]
    #[doc = ""]
    #[doc = " This function does not require s to be allocated with swr_alloc(). On the"]
    #[doc = " other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters"]
    #[doc = " on the allocated context."]
    #[doc = ""]
    #[doc = " @param s               existing Swr context if available, or NULL if not"]
    #[doc = " @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)"]
    #[doc = " @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*)."]
    #[doc = " @param out_sample_rate output sample rate (frequency in Hz)"]
    #[doc = " @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)"]
    #[doc = " @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*)."]
    #[doc = " @param in_sample_rate  input sample rate (frequency in Hz)"]
    #[doc = " @param log_offset      logging level offset"]
    #[doc = " @param log_ctx         parent logging context, can be NULL"]
    #[doc = ""]
    #[doc = " @see swr_init(), swr_free()"]
    #[doc = " @return NULL on error, allocated context otherwise"]
    #[doc = " @deprecated use @ref swr_alloc_set_opts2()"]
    pub fn swr_alloc_set_opts(
        s: *mut SwrContext,
        out_ch_layout: i64,
        out_sample_fmt: AVSampleFormat,
        out_sample_rate: libc::c_int,
        in_ch_layout: i64,
        in_sample_fmt: AVSampleFormat,
        in_sample_rate: libc::c_int,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> *mut SwrContext;
}
extern "C" {
    #[doc = " Allocate SwrContext if needed and set/reset common parameters."]
    #[doc = ""]
    #[doc = " This function does not require *ps to be allocated with swr_alloc(). On the"]
    #[doc = " other hand, swr_alloc() can use swr_alloc_set_opts2() to set the parameters"]
    #[doc = " on the allocated context."]
    #[doc = ""]
    #[doc = " @param ps              Pointer to an existing Swr context if available, or to NULL if not."]
    #[doc = "                        On success, *ps will be set to the allocated context."]
    #[doc = " @param out_ch_layout   output channel layout (e.g. AV_CHANNEL_LAYOUT_*)"]
    #[doc = " @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*)."]
    #[doc = " @param out_sample_rate output sample rate (frequency in Hz)"]
    #[doc = " @param in_ch_layout    input channel layout (e.g. AV_CHANNEL_LAYOUT_*)"]
    #[doc = " @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*)."]
    #[doc = " @param in_sample_rate  input sample rate (frequency in Hz)"]
    #[doc = " @param log_offset      logging level offset"]
    #[doc = " @param log_ctx         parent logging context, can be NULL"]
    #[doc = ""]
    #[doc = " @see swr_init(), swr_free()"]
    #[doc = " @return 0 on success, a negative AVERROR code on error."]
    #[doc = "         On error, the Swr context is freed and *ps set to NULL."]
    pub fn swr_alloc_set_opts2(
        ps: *mut *mut SwrContext,
        out_ch_layout: *mut AVChannelLayout,
        out_sample_fmt: AVSampleFormat,
        out_sample_rate: libc::c_int,
        in_ch_layout: *mut AVChannelLayout,
        in_sample_fmt: AVSampleFormat,
        in_sample_rate: libc::c_int,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free the given SwrContext and set the pointer to NULL."]
    #[doc = ""]
    #[doc = " @param[in] s a pointer to a pointer to Swr context"]
    pub fn swr_free(s: *mut *mut SwrContext);
}
extern "C" {
    #[doc = " Closes the context so that swr_is_initialized() returns 0."]
    #[doc = ""]
    #[doc = " The context can be brought back to life by running swr_init(),"]
    #[doc = " swr_init() can also be used without swr_close()."]
    #[doc = " This function is mainly provided for simplifying the usecase"]
    #[doc = " where one tries to support libavresample and libswresample."]
    #[doc = ""]
    #[doc = " @param[in,out] s Swr context to be closed"]
    pub fn swr_close(s: *mut SwrContext);
}
extern "C" {
    #[doc = " Convert audio."]
    #[doc = ""]
    #[doc = " in and in_count can be set to 0 to flush the last few samples out at the"]
    #[doc = " end."]
    #[doc = ""]
    #[doc = " If more input is provided than output space, then the input will be buffered."]
    #[doc = " You can avoid this buffering by using swr_get_out_samples() to retrieve an"]
    #[doc = " upper bound on the required number of output samples for the given number of"]
    #[doc = " input samples. Conversion will run directly without copying whenever possible."]
    #[doc = ""]
    #[doc = " @param s         allocated Swr context, with parameters set"]
    #[doc = " @param out       output buffers, only the first one need be set in case of packed audio"]
    #[doc = " @param out_count amount of space available for output in samples per channel"]
    #[doc = " @param in        input buffers, only the first one need to be set in case of packed audio"]
    #[doc = " @param in_count  number of input samples available in one channel"]
    #[doc = ""]
    #[doc = " @return number of samples output per channel, negative value on error"]
    pub fn swr_convert(
        s: *mut SwrContext,
        out: *mut *mut u8,
        out_count: libc::c_int,
        in_: *mut *const u8,
        in_count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert the next timestamp from input to output"]
    #[doc = " timestamps are in 1/(in_sample_rate * out_sample_rate) units."]
    #[doc = ""]
    #[doc = " @note There are 2 slightly differently behaving modes."]
    #[doc = "       @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)"]
    #[doc = "              in this case timestamps will be passed through with delays compensated"]
    #[doc = "       @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)"]
    #[doc = "              in this case the output timestamps will match output sample numbers."]
    #[doc = "              See ffmpeg-resampler(1) for the two modes of compensation."]
    #[doc = ""]
    #[doc = " @param s[in]     initialized Swr context"]
    #[doc = " @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown"]
    #[doc = " @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are"]
    #[doc = "      function used internally for timestamp compensation."]
    #[doc = " @return the output timestamp for the next output sample"]
    pub fn swr_next_pts(s: *mut SwrContext, pts: i64) -> i64;
}
extern "C" {
    #[doc = " Activate resampling compensation (\"soft\" compensation). This function is"]
    #[doc = " internally called when needed in swr_next_pts()."]
    #[doc = ""]
    #[doc = " @param[in,out] s             allocated Swr context. If it is not initialized,"]
    #[doc = "                              or SWR_FLAG_RESAMPLE is not set, swr_init() is"]
    #[doc = "                              called with the flag set."]
    #[doc = " @param[in]     sample_delta  delta in PTS per sample"]
    #[doc = " @param[in]     compensation_distance number of samples to compensate for"]
    #[doc = " @return    >= 0 on success, AVERROR error codes if:"]
    #[doc = "            @li @c s is NULL,"]
    #[doc = "            @li @c compensation_distance is less than 0,"]
    #[doc = "            @li @c compensation_distance is 0 but sample_delta is not,"]
    #[doc = "            @li compensation unsupported by resampler, or"]
    #[doc = "            @li swr_init() fails when called."]
    pub fn swr_set_compensation(
        s: *mut SwrContext,
        sample_delta: libc::c_int,
        compensation_distance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a customized input channel mapping."]
    #[doc = ""]
    #[doc = " @param[in,out] s           allocated Swr context, not yet initialized"]
    #[doc = " @param[in]     channel_map customized input channel mapping (array of channel"]
    #[doc = "                            indexes, -1 for a muted channel)"]
    #[doc = " @return >= 0 on success, or AVERROR error code in case of failure."]
    pub fn swr_set_channel_mapping(
        s: *mut SwrContext,
        channel_map: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Generate a channel mixing matrix."]
    #[doc = ""]
    #[doc = " This function is the one used internally by libswresample for building the"]
    #[doc = " default mixing matrix. It is made public just as a utility function for"]
    #[doc = " building custom matrices."]
    #[doc = ""]
    #[doc = " @param in_layout           input channel layout"]
    #[doc = " @param out_layout          output channel layout"]
    #[doc = " @param center_mix_level    mix level for the center channel"]
    #[doc = " @param surround_mix_level  mix level for the surround channel(s)"]
    #[doc = " @param lfe_mix_level       mix level for the low-frequency effects channel"]
    #[doc = " @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent"]
    #[doc = "                            overflow. if INT_MAX, coefficients will not be"]
    #[doc = "                            normalized."]
    #[doc = " @param[out] matrix         mixing coefficients; matrix[i + stride * o] is"]
    #[doc = "                            the weight of input channel i in output channel o."]
    #[doc = " @param stride              distance between adjacent input channels in the"]
    #[doc = "                            matrix array"]
    #[doc = " @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)"]
    #[doc = " @param log_ctx             parent logging context, can be NULL"]
    #[doc = " @return                    0 on success, negative AVERROR code on failure"]
    #[doc = " @deprecated                use @ref swr_build_matrix2()"]
    pub fn swr_build_matrix(
        in_layout: u64,
        out_layout: u64,
        center_mix_level: f64,
        surround_mix_level: f64,
        lfe_mix_level: f64,
        rematrix_maxval: f64,
        rematrix_volume: f64,
        matrix: *mut f64,
        stride: libc::c_int,
        matrix_encoding: AVMatrixEncoding,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Generate a channel mixing matrix."]
    #[doc = ""]
    #[doc = " This function is the one used internally by libswresample for building the"]
    #[doc = " default mixing matrix. It is made public just as a utility function for"]
    #[doc = " building custom matrices."]
    #[doc = ""]
    #[doc = " @param in_layout           input channel layout"]
    #[doc = " @param out_layout          output channel layout"]
    #[doc = " @param center_mix_level    mix level for the center channel"]
    #[doc = " @param surround_mix_level  mix level for the surround channel(s)"]
    #[doc = " @param lfe_mix_level       mix level for the low-frequency effects channel"]
    #[doc = " @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent"]
    #[doc = "                            overflow. if INT_MAX, coefficients will not be"]
    #[doc = "                            normalized."]
    #[doc = " @param[out] matrix         mixing coefficients; matrix[i + stride * o] is"]
    #[doc = "                            the weight of input channel i in output channel o."]
    #[doc = " @param stride              distance between adjacent input channels in the"]
    #[doc = "                            matrix array"]
    #[doc = " @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)"]
    #[doc = " @param log_ctx             parent logging context, can be NULL"]
    #[doc = " @return                    0 on success, negative AVERROR code on failure"]
    pub fn swr_build_matrix2(
        in_layout: *const AVChannelLayout,
        out_layout: *const AVChannelLayout,
        center_mix_level: f64,
        surround_mix_level: f64,
        lfe_mix_level: f64,
        maxval: f64,
        rematrix_volume: f64,
        matrix: *mut f64,
        stride: isize,
        matrix_encoding: AVMatrixEncoding,
        log_context: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a customized remix matrix."]
    #[doc = ""]
    #[doc = " @param s       allocated Swr context, not yet initialized"]
    #[doc = " @param matrix  remix coefficients; matrix[i + stride * o] is"]
    #[doc = "                the weight of input channel i in output channel o"]
    #[doc = " @param stride  offset between lines of the matrix"]
    #[doc = " @return  >= 0 on success, or AVERROR error code in case of failure."]
    pub fn swr_set_matrix(
        s: *mut SwrContext,
        matrix: *const f64,
        stride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Drops the specified number of output samples."]
    #[doc = ""]
    #[doc = " This function, along with swr_inject_silence(), is called by swr_next_pts()"]
    #[doc = " if needed for \"hard\" compensation."]
    #[doc = ""]
    #[doc = " @param s     allocated Swr context"]
    #[doc = " @param count number of samples to be dropped"]
    #[doc = ""]
    #[doc = " @return >= 0 on success, or a negative AVERROR code on failure"]
    pub fn swr_drop_output(s: *mut SwrContext, count: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Injects the specified number of silence samples."]
    #[doc = ""]
    #[doc = " This function, along with swr_drop_output(), is called by swr_next_pts()"]
    #[doc = " if needed for \"hard\" compensation."]
    #[doc = ""]
    #[doc = " @param s     allocated Swr context"]
    #[doc = " @param count number of samples to be dropped"]
    #[doc = ""]
    #[doc = " @return >= 0 on success, or a negative AVERROR code on failure"]
    pub fn swr_inject_silence(s: *mut SwrContext, count: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Gets the delay the next input sample will experience relative to the next output sample."]
    #[doc = ""]
    #[doc = " Swresample can buffer data if more input has been provided than available"]
    #[doc = " output space, also converting between sample rates needs a delay."]
    #[doc = " This function returns the sum of all such delays."]
    #[doc = " The exact delay is not necessarily an integer value in either input or"]
    #[doc = " output sample rate. Especially when downsampling by a large value, the"]
    #[doc = " output sample rate may be a poor choice to represent the delay, similarly"]
    #[doc = " for upsampling and the input sample rate."]
    #[doc = ""]
    #[doc = " @param s     swr context"]
    #[doc = " @param base  timebase in which the returned delay will be:"]
    #[doc = "              @li if it's set to 1 the returned delay is in seconds"]
    #[doc = "              @li if it's set to 1000 the returned delay is in milliseconds"]
    #[doc = "              @li if it's set to the input sample rate then the returned"]
    #[doc = "                  delay is in input samples"]
    #[doc = "              @li if it's set to the output sample rate then the returned"]
    #[doc = "                  delay is in output samples"]
    #[doc = "              @li if it's the least common multiple of in_sample_rate and"]
    #[doc = "                  out_sample_rate then an exact rounding-free delay will be"]
    #[doc = "                  returned"]
    #[doc = " @returns     the delay in 1 / @c base units."]
    pub fn swr_get_delay(s: *mut SwrContext, base: i64) -> i64;
}
extern "C" {
    #[doc = " Find an upper bound on the number of samples that the next swr_convert"]
    #[doc = " call will output, if called with in_samples of input samples. This"]
    #[doc = " depends on the internal state, and anything changing the internal state"]
    #[doc = " (like further swr_convert() calls) will may change the number of samples"]
    #[doc = " swr_get_out_samples() returns for the same number of input samples."]
    #[doc = ""]
    #[doc = " @param in_samples    number of input samples."]
    #[doc = " @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()"]
    #[doc = "       or swr_set_compensation() invalidates this limit"]
    #[doc = " @note it is recommended to pass the correct available buffer size"]
    #[doc = "       to all functions like swr_convert() even if swr_get_out_samples()"]
    #[doc = "       indicates that less would be used."]
    #[doc = " @returns an upper bound on the number of samples that the next swr_convert"]
    #[doc = "          will output or a negative value to indicate an error"]
    pub fn swr_get_out_samples(s: *mut SwrContext, in_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the @ref LIBSWRESAMPLE_VERSION_INT constant."]
    #[doc = ""]
    #[doc = " This is useful to check if the build-time libswresample has the same version"]
    #[doc = " as the run-time one."]
    #[doc = ""]
    #[doc = " @returns     the unsigned int-typed version"]
    pub fn swresample_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the swr build-time configuration."]
    #[doc = ""]
    #[doc = " @returns     the build-time @c ./configure flags"]
    pub fn swresample_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the swr license."]
    #[doc = ""]
    #[doc = " @returns     the license of libswresample, determined at build-time"]
    pub fn swresample_license() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Convert the samples in the input AVFrame and write them to the output AVFrame."]
    #[doc = ""]
    #[doc = " Input and output AVFrames must have channel_layout, sample_rate and format set."]
    #[doc = ""]
    #[doc = " If the output AVFrame does not have the data pointers allocated the nb_samples"]
    #[doc = " field will be set using av_frame_get_buffer()"]
    #[doc = " is called to allocate the frame."]
    #[doc = ""]
    #[doc = " The output AVFrame can be NULL or have fewer allocated samples than required."]
    #[doc = " In this case, any remaining samples not written to the output will be added"]
    #[doc = " to an internal FIFO buffer, to be returned at the next call to this function"]
    #[doc = " or to swr_convert()."]
    #[doc = ""]
    #[doc = " If converting sample rate, there may be data remaining in the internal"]
    #[doc = " resampling delay buffer. swr_get_delay() tells the number of"]
    #[doc = " remaining samples. To get this data as output, call this function or"]
    #[doc = " swr_convert() with NULL input."]
    #[doc = ""]
    #[doc = " If the SwrContext configuration does not match the output and"]
    #[doc = " input AVFrame settings the conversion does not take place and depending on"]
    #[doc = " which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED"]
    #[doc = " or the result of a bitwise-OR of them is returned."]
    #[doc = ""]
    #[doc = " @see swr_delay()"]
    #[doc = " @see swr_convert()"]
    #[doc = " @see swr_get_delay()"]
    #[doc = ""]
    #[doc = " @param swr             audio resample context"]
    #[doc = " @param output          output AVFrame"]
    #[doc = " @param input           input AVFrame"]
    #[doc = " @return                0 on success, AVERROR on failure or nonmatching"]
    #[doc = "                        configuration."]
    pub fn swr_convert_frame(
        swr: *mut SwrContext,
        output: *mut AVFrame,
        input: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Configure or reconfigure the SwrContext using the information"]
    #[doc = " provided by the AVFrames."]
    #[doc = ""]
    #[doc = " The original resampling context is reset even on failure."]
    #[doc = " The function calls swr_close() internally if the context is open."]
    #[doc = ""]
    #[doc = " @see swr_close();"]
    #[doc = ""]
    #[doc = " @param swr             audio resample context"]
    #[doc = " @param output          output AVFrame"]
    #[doc = " @param input           input AVFrame"]
    #[doc = " @return                0 on success, AVERROR on failure."]
    pub fn swr_config_frame(
        swr: *mut SwrContext,
        out: *const AVFrame,
        in_: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @defgroup libsws libswscale"]
    #[doc = " Color conversion and scaling library."]
    #[doc = ""]
    #[doc = " @{"]
    #[doc = ""]
    #[doc = " Return the LIBSWSCALE_VERSION_INT constant."]
    pub fn swscale_version() -> libc::c_uint;
}
extern "C" {
    #[doc = " Return the libswscale build-time configuration."]
    pub fn swscale_configuration() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the libswscale license."]
    pub fn swscale_license() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return a pointer to yuv<->rgb coefficients for the given colorspace"]
    #[doc = " suitable for sws_setColorspaceDetails()."]
    #[doc = ""]
    #[doc = " @param colorspace One of the SWS_CS_* macros. If invalid,"]
    #[doc = " SWS_CS_DEFAULT is used."]
    pub fn sws_getCoefficients(colorspace: libc::c_int) -> *const libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SwsVector {
    #[doc = "< pointer to the list of coefficients"]
    pub coeff: *mut f64,
    #[doc = "< number of coefficients in the vector"]
    pub length: libc::c_int,
}
#[test]
fn bindgen_test_layout_SwsVector() {
    assert_eq!(
        ::std::mem::size_of::<SwsVector>(),
        16usize,
        concat!("Size of: ", stringify!(SwsVector))
    );
    assert_eq!(
        ::std::mem::align_of::<SwsVector>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsVector>())).coeff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsVector>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
#[test]
fn bindgen_test_layout_SwsFilter() {
    assert_eq!(
        ::std::mem::size_of::<SwsFilter>(),
        32usize,
        concat!("Size of: ", stringify!(SwsFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<SwsFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).lumH as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).lumV as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).chrH as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).chrV as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrV)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported input format, 0"]
    #[doc = " otherwise."]
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported output format, 0"]
    #[doc = " otherwise."]
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " @param[in]  pix_fmt the pixel format"]
    #[doc = " @return a positive value if an endianness conversion for pix_fmt is"]
    #[doc = " supported, 0 otherwise."]
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate an empty SwsContext. This must be filled and passed to"]
    #[doc = " sws_init_context(). For filling see AVOptions, options.c and"]
    #[doc = " sws_setColorspaceDetails()."]
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    #[doc = " Initialize the swscaler context sws_context."]
    #[doc = ""]
    #[doc = " @return zero or positive value on success, a negative value on"]
    #[doc = " error"]
    pub fn sws_init_context(
        sws_context: *mut SwsContext,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free the swscaler context swsContext."]
    #[doc = " If swsContext is NULL, then does nothing."]
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    #[doc = " Allocate and return an SwsContext. You need it to perform"]
    #[doc = " scaling/conversion operations using sws_scale()."]
    #[doc = ""]
    #[doc = " @param srcW the width of the source image"]
    #[doc = " @param srcH the height of the source image"]
    #[doc = " @param srcFormat the source image format"]
    #[doc = " @param dstW the width of the destination image"]
    #[doc = " @param dstH the height of the destination image"]
    #[doc = " @param dstFormat the destination image format"]
    #[doc = " @param flags specify which algorithm and options to use for rescaling"]
    #[doc = " @param param extra parameters to tune the used scaler"]
    #[doc = "              For SWS_BICUBIC param[0] and [1] tune the shape of the basis"]
    #[doc = "              function, param[0] tunes f(1) and param[1] f´(1)"]
    #[doc = "              For SWS_GAUSS param[0] tunes the exponent and thus cutoff"]
    #[doc = "              frequency"]
    #[doc = "              For SWS_LANCZOS param[0] tunes the width of the window function"]
    #[doc = " @return a pointer to an allocated context, or NULL in case of error"]
    #[doc = " @note this function is to be removed after a saner alternative is"]
    #[doc = "       written"]
    pub fn sws_getContext(
        srcW: libc::c_int,
        srcH: libc::c_int,
        srcFormat: AVPixelFormat,
        dstW: libc::c_int,
        dstH: libc::c_int,
        dstFormat: AVPixelFormat,
        flags: libc::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Scale the image slice in srcSlice and put the resulting scaled"]
    #[doc = " slice in the image in dst. A slice is a sequence of consecutive"]
    #[doc = " rows in an image."]
    #[doc = ""]
    #[doc = " Slices have to be provided in sequential order, either in"]
    #[doc = " top-bottom or bottom-top order. If slices are provided in"]
    #[doc = " non-sequential order the behavior of the function is undefined."]
    #[doc = ""]
    #[doc = " @param c         the scaling context previously created with"]
    #[doc = "                  sws_getContext()"]
    #[doc = " @param srcSlice  the array containing the pointers to the planes of"]
    #[doc = "                  the source slice"]
    #[doc = " @param srcStride the array containing the strides for each plane of"]
    #[doc = "                  the source image"]
    #[doc = " @param srcSliceY the position in the source image of the slice to"]
    #[doc = "                  process, that is the number (counted starting from"]
    #[doc = "                  zero) in the image of the first row of the slice"]
    #[doc = " @param srcSliceH the height of the source slice, that is the number"]
    #[doc = "                  of rows in the slice"]
    #[doc = " @param dst       the array containing the pointers to the planes of"]
    #[doc = "                  the destination image"]
    #[doc = " @param dstStride the array containing the strides for each plane of"]
    #[doc = "                  the destination image"]
    #[doc = " @return          the height of the output slice"]
    pub fn sws_scale(
        c: *mut SwsContext,
        srcSlice: *const *const u8,
        srcStride: *const libc::c_int,
        srcSliceY: libc::c_int,
        srcSliceH: libc::c_int,
        dst: *const *mut u8,
        dstStride: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Scale source data from src and write the output to dst."]
    #[doc = ""]
    #[doc = " This is merely a convenience wrapper around"]
    #[doc = " - sws_frame_start()"]
    #[doc = " - sws_send_slice(0, src->height)"]
    #[doc = " - sws_receive_slice(0, dst->height)"]
    #[doc = " - sws_frame_end()"]
    #[doc = ""]
    #[doc = " @param dst The destination frame. See documentation for sws_frame_start() for"]
    #[doc = "            more details."]
    #[doc = " @param src The source frame."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR code on failure"]
    pub fn sws_scale_frame(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize the scaling process for a given pair of source/destination frames."]
    #[doc = " Must be called before any calls to sws_send_slice() and sws_receive_slice()."]
    #[doc = ""]
    #[doc = " This function will retain references to src and dst, so they must both use"]
    #[doc = " refcounted buffers (if allocated by the caller, in case of dst)."]
    #[doc = ""]
    #[doc = " @param dst The destination frame."]
    #[doc = ""]
    #[doc = "            The data buffers may either be already allocated by the caller or"]
    #[doc = "            left clear, in which case they will be allocated by the scaler."]
    #[doc = "            The latter may have performance advantages - e.g. in certain cases"]
    #[doc = "            some output planes may be references to input planes, rather than"]
    #[doc = "            copies."]
    #[doc = ""]
    #[doc = "            Output data will be written into this frame in successful"]
    #[doc = "            sws_receive_slice() calls."]
    #[doc = " @param src The source frame. The data buffers must be allocated, but the"]
    #[doc = "            frame data does not have to be ready at this point. Data"]
    #[doc = "            availability is then signalled by sws_send_slice()."]
    #[doc = " @return 0 on success, a negative AVERROR code on failure"]
    #[doc = ""]
    #[doc = " @see sws_frame_end()"]
    pub fn sws_frame_start(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Finish the scaling process for a pair of source/destination frames previously"]
    #[doc = " submitted with sws_frame_start(). Must be called after all sws_send_slice()"]
    #[doc = " and sws_receive_slice() calls are done, before any new sws_frame_start()"]
    #[doc = " calls."]
    pub fn sws_frame_end(c: *mut SwsContext);
}
extern "C" {
    #[doc = " Indicate that a horizontal slice of input data is available in the source"]
    #[doc = " frame previously provided to sws_frame_start(). The slices may be provided in"]
    #[doc = " any order, but may not overlap. For vertically subsampled pixel formats, the"]
    #[doc = " slices must be aligned according to subsampling."]
    #[doc = ""]
    #[doc = " @param slice_start first row of the slice"]
    #[doc = " @param slice_height number of rows in the slice"]
    #[doc = ""]
    #[doc = " @return a non-negative number on success, a negative AVERROR code on failure."]
    pub fn sws_send_slice(
        c: *mut SwsContext,
        slice_start: libc::c_uint,
        slice_height: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Request a horizontal slice of the output data to be written into the frame"]
    #[doc = " previously provided to sws_frame_start()."]
    #[doc = ""]
    #[doc = " @param slice_start first row of the slice; must be a multiple of"]
    #[doc = "                    sws_receive_slice_alignment()"]
    #[doc = " @param slice_height number of rows in the slice; must be a multiple of"]
    #[doc = "                     sws_receive_slice_alignment(), except for the last slice"]
    #[doc = "                     (i.e. when slice_start+slice_height is equal to output"]
    #[doc = "                     frame height)"]
    #[doc = ""]
    #[doc = " @return a non-negative number if the data was successfully written into the output"]
    #[doc = "         AVERROR(EAGAIN) if more input data needs to be provided before the"]
    #[doc = "                         output can be produced"]
    #[doc = "         another negative AVERROR code on other kinds of scaling failure"]
    pub fn sws_receive_slice(
        c: *mut SwsContext,
        slice_start: libc::c_uint,
        slice_height: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @return alignment required for output slices requested with sws_receive_slice()."]
    #[doc = "         Slice offsets and sizes passed to sws_receive_slice() must be"]
    #[doc = "         multiples of the value returned from this function."]
    pub fn sws_receive_slice_alignment(c: *const SwsContext) -> libc::c_uint;
}
extern "C" {
    #[doc = " @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)"]
    #[doc = " @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)"]
    #[doc = " @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]"]
    #[doc = " @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]"]
    #[doc = " @param brightness 16.16 fixed point brightness correction"]
    #[doc = " @param contrast 16.16 fixed point contrast correction"]
    #[doc = " @param saturation 16.16 fixed point saturation correction"]
    #[doc = "#if LIBSWSCALE_VERSION_MAJOR > 6"]
    #[doc = " @return negative error code on error, non negative otherwise"]
    #[doc = "#else"]
    #[doc = " @return -1 if not supported"]
    #[doc = "#endif"]
    pub fn sws_setColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *const libc::c_int,
        srcRange: libc::c_int,
        table: *const libc::c_int,
        dstRange: libc::c_int,
        brightness: libc::c_int,
        contrast: libc::c_int,
        saturation: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "#if LIBSWSCALE_VERSION_MAJOR > 6"]
    #[doc = " @return negative error code on error, non negative otherwise"]
    #[doc = "#else"]
    #[doc = " @return -1 if not supported"]
    #[doc = "#endif"]
    pub fn sws_getColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *mut *mut libc::c_int,
        srcRange: *mut libc::c_int,
        table: *mut *mut libc::c_int,
        dstRange: *mut libc::c_int,
        brightness: *mut libc::c_int,
        contrast: *mut libc::c_int,
        saturation: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate and return an uninitialized vector with length coefficients."]
    pub fn sws_allocVec(length: libc::c_int) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Return a normalized Gaussian curve used to filter stuff"]
    #[doc = " quality = 3 is high quality, lower is lower quality."]
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Scale all the coefficients of a by the scalar value."]
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    #[doc = " Scale all the coefficients of a so that their sum equals height."]
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(
        lumaGBlur: f32,
        chromaGBlur: f32,
        lumaSharpen: f32,
        chromaSharpen: f32,
        chromaHShift: f32,
        chromaVShift: f32,
        verbose: libc::c_int,
    ) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    #[doc = " Check if context can be reused, otherwise reallocate a new one."]
    #[doc = ""]
    #[doc = " If context is NULL, just calls sws_getContext() to get a new"]
    #[doc = " context. Otherwise, checks if the parameters are the ones already"]
    #[doc = " saved in context. If that is the case, returns the current"]
    #[doc = " context. Otherwise, frees context and gets a new context with"]
    #[doc = " the new parameters."]
    #[doc = ""]
    #[doc = " Be warned that srcFilter and dstFilter are not checked, they"]
    #[doc = " are assumed to remain the same."]
    pub fn sws_getCachedContext(
        context: *mut SwsContext,
        srcW: libc::c_int,
        srcH: libc::c_int,
        srcFormat: AVPixelFormat,
        dstW: libc::c_int,
        dstH: libc::c_int,
        dstFormat: AVPixelFormat,
        flags: libc::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 32 bits."]
    #[doc = ""]
    #[doc = " The output frame will have the same packed format as the palette."]
    #[doc = ""]
    #[doc = " @param src        source frame buffer"]
    #[doc = " @param dst        destination frame buffer"]
    #[doc = " @param num_pixels number of pixels to convert"]
    #[doc = " @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked32(
        src: *const u8,
        dst: *mut u8,
        num_pixels: libc::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 24 bits."]
    #[doc = ""]
    #[doc = " With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\"."]
    #[doc = ""]
    #[doc = " @param src        source frame buffer"]
    #[doc = " @param dst        destination frame buffer"]
    #[doc = " @param num_pixels number of pixels to convert"]
    #[doc = " @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked24(
        src: *const u8,
        dst: *mut u8,
        num_pixels: libc::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Get the AVClass for swsContext. It can be used in combination with"]
    #[doc = " AV_OPT_SEARCH_FAKE_OBJ for examining options."]
    #[doc = ""]
    #[doc = " @see av_opt_find()."]
    pub fn sws_get_class() -> *const AVClass;
}
pub const AV_DRM_MAX_PLANES: _bindgen_ty_8 = _bindgen_ty_8::AV_DRM_MAX_PLANES;
#[repr(u32)]
#[doc = " @file"]
#[doc = " API-specific header for AV_HWDEVICE_TYPE_DRM."]
#[doc = ""]
#[doc = " Internal frame allocation is not currently supported - all frames"]
#[doc = " must be allocated by the user.  Thus AVHWFramesContext is always"]
#[doc = " NULL, though this may change if support for frame allocation is"]
#[doc = " added in future."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    #[doc = " The maximum number of layers/planes in a DRM frame."]
    AV_DRM_MAX_PLANES = 4,
}
#[doc = " DRM object descriptor."]
#[doc = ""]
#[doc = " Describes a single DRM object, addressing it as a PRIME file"]
#[doc = " descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMObjectDescriptor {
    #[doc = " DRM PRIME fd for the object."]
    pub fd: libc::c_int,
    #[doc = " Total size of the object."]
    #[doc = ""]
    #[doc = " (This includes any parts not which do not contain image data.)"]
    pub size: usize,
    #[doc = " Format modifier applied to the object (DRM_FORMAT_MOD_*)."]
    #[doc = ""]
    #[doc = " If the format modifier is unknown then this should be set to"]
    #[doc = " DRM_FORMAT_MOD_INVALID."]
    pub format_modifier: u64,
}
#[test]
fn bindgen_test_layout_AVDRMObjectDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVDRMObjectDescriptor>(),
        24usize,
        concat!("Size of: ", stringify!(AVDRMObjectDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDRMObjectDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDRMObjectDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMObjectDescriptor>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMObjectDescriptor),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMObjectDescriptor>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMObjectDescriptor),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDRMObjectDescriptor>())).format_modifier as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMObjectDescriptor),
            "::",
            stringify!(format_modifier)
        )
    );
}
#[doc = " DRM plane descriptor."]
#[doc = ""]
#[doc = " Describes a single plane of a layer, which is contained within"]
#[doc = " a single object."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMPlaneDescriptor {
    #[doc = " Index of the object containing this plane in the objects"]
    #[doc = " array of the enclosing frame descriptor."]
    pub object_index: libc::c_int,
    #[doc = " Offset within that object of this plane."]
    pub offset: isize,
    #[doc = " Pitch (linesize) of this plane."]
    pub pitch: isize,
}
#[test]
fn bindgen_test_layout_AVDRMPlaneDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVDRMPlaneDescriptor>(),
        24usize,
        concat!("Size of: ", stringify!(AVDRMPlaneDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDRMPlaneDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDRMPlaneDescriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDRMPlaneDescriptor>())).object_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMPlaneDescriptor),
            "::",
            stringify!(object_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMPlaneDescriptor>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMPlaneDescriptor),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMPlaneDescriptor>())).pitch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMPlaneDescriptor),
            "::",
            stringify!(pitch)
        )
    );
}
#[doc = " DRM layer descriptor."]
#[doc = ""]
#[doc = " Describes a single layer within a frame.  This has the structure"]
#[doc = " defined by its format, and will contain one or more planes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMLayerDescriptor {
    #[doc = " Format of the layer (DRM_FORMAT_*)."]
    pub format: u32,
    #[doc = " Number of planes in the layer."]
    #[doc = ""]
    #[doc = " This must match the number of planes required by format."]
    pub nb_planes: libc::c_int,
    #[doc = " Array of planes in this layer."]
    pub planes: [AVDRMPlaneDescriptor; 4usize],
}
#[test]
fn bindgen_test_layout_AVDRMLayerDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVDRMLayerDescriptor>(),
        104usize,
        concat!("Size of: ", stringify!(AVDRMLayerDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDRMLayerDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDRMLayerDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMLayerDescriptor>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMLayerDescriptor),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMLayerDescriptor>())).nb_planes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMLayerDescriptor),
            "::",
            stringify!(nb_planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMLayerDescriptor>())).planes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMLayerDescriptor),
            "::",
            stringify!(planes)
        )
    );
}
#[doc = " DRM frame descriptor."]
#[doc = ""]
#[doc = " This is used as the data pointer for AV_PIX_FMT_DRM_PRIME frames."]
#[doc = " It is also used by user-allocated frame pools - allocating in"]
#[doc = " AVHWFramesContext.pool must return AVBufferRefs which contain"]
#[doc = " an object of this type."]
#[doc = ""]
#[doc = " The fields of this structure should be set such it can be"]
#[doc = " imported directly by EGL using the EGL_EXT_image_dma_buf_import"]
#[doc = " and EGL_EXT_image_dma_buf_import_modifiers extensions."]
#[doc = " (Note that the exact layout of a particular format may vary between"]
#[doc = " platforms - we only specify that the same platform should be able"]
#[doc = " to import it.)"]
#[doc = ""]
#[doc = " The total number of planes must not exceed AV_DRM_MAX_PLANES, and"]
#[doc = " the order of the planes by increasing layer index followed by"]
#[doc = " increasing plane index must be the same as the order which would"]
#[doc = " be used for the data pointers in the equivalent software format."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMFrameDescriptor {
    #[doc = " Number of DRM objects making up this frame."]
    pub nb_objects: libc::c_int,
    #[doc = " Array of objects making up the frame."]
    pub objects: [AVDRMObjectDescriptor; 4usize],
    #[doc = " Number of layers in the frame."]
    pub nb_layers: libc::c_int,
    #[doc = " Array of layers in the frame."]
    pub layers: [AVDRMLayerDescriptor; 4usize],
}
#[test]
fn bindgen_test_layout_AVDRMFrameDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVDRMFrameDescriptor>(),
        528usize,
        concat!("Size of: ", stringify!(AVDRMFrameDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDRMFrameDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDRMFrameDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMFrameDescriptor>())).nb_objects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMFrameDescriptor),
            "::",
            stringify!(nb_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMFrameDescriptor>())).objects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMFrameDescriptor),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMFrameDescriptor>())).nb_layers as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMFrameDescriptor),
            "::",
            stringify!(nb_layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMFrameDescriptor>())).layers as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMFrameDescriptor),
            "::",
            stringify!(layers)
        )
    );
}
#[doc = " DRM device."]
#[doc = ""]
#[doc = " Allocated as AVHWDeviceContext.hwctx."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDRMDeviceContext {
    #[doc = " File descriptor of DRM device."]
    #[doc = ""]
    #[doc = " This is used as the device to create frames on, and may also be"]
    #[doc = " used in some derivation and mapping operations."]
    #[doc = ""]
    #[doc = " If no device is required, set to -1."]
    pub fd: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDRMDeviceContext() {
    assert_eq!(
        ::std::mem::size_of::<AVDRMDeviceContext>(),
        4usize,
        concat!("Size of: ", stringify!(AVDRMDeviceContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDRMDeviceContext>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDRMDeviceContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDRMDeviceContext>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDRMDeviceContext),
            "::",
            stringify!(fd)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct URLContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterCommand {
    pub _address: u8,
}
